;;; gui.xtm -- simple 2D GUI library

;; Author: Ben Swift
;; Keywords: extempore
;; Required dylibs: libGL, libglfw3, libnanovg

;;; Commentary:

;; 

;;; Code:

(sys:load "libs/gui.xtm" 'quiet)
(sys:load-preload-check 'gui)
(define *xtmlib-gui-loaded* #f)

(impc:aot:suppress-aot-do
 (sys:load "libs/core/std.xtm")
 (sys:load "libs/external/nanovg.xtm")
 (sys:load "libs/external/glfw3.xtm"))
(impc:aot:insert-sexp '(sys:load "libs/core/std.xtm" 'quiet))
(impc:aot:insert-sexp '(sys:load "libs/external/nanovg.xtm" 'quiet))
(impc:aot:insert-sexp '(sys:load "libs/external/glfw3.xtm" 'quiet))

(impc:aot:insert-header "xtmgui")

;; <x,y,w,h>
(bind-type Rect <float,float,float,float>)

(bind-func Rect_print
  (lambda (rect:Rect*)
    (printf "<Rect: x=%.3f y=%.3f w=%.3f h=%.3f>"
            (convert (tref rect 0) double)
            (convert (tref rect 1) double)
            (convert (tref rect 2) double)
            (convert (tref rect 3) double))
    void))

(bind-poly print Rect_print)

;; 0. id
;; 1. size
;; 2. type (flags)
;; 3. callback (to draw widget, handle events)
;; 4. parent widget
;; 5. left child widget
;; 6. right child widget
(bind-type Widget <i32,float,i64,[void,Widget*,Rect*]*,Widget*,Widget*,Widget*>)

(bind-alias WidgetCB [void,Widget*,Rect*]*)

;; accessors
(bind-func Widget_id
  (lambda (widget:Widget*)
    (tref widget 0)))

(bind-func Widget_size
  (lambda (widget:Widget*)
    (tref widget 1)))

(bind-func Widget_set_size
  (lambda (widget:Widget* size)
    (tset! widget 1 size)))

(bind-func Widget_type
  (lambda (widget:Widget*)
    (tref widget 2)))

(bind-func Widget_cb
  (lambda (widget:Widget*)
    (tref widget 3)))

(bind-func Widget_set_cb
  (lambda (widget:Widget* cb:WidgetCB)
    (tset! widget 3 cb)))

(bind-func Widget_parent
  (lambda (widget:Widget*)
    (tref widget 4)))

(bind-func Widget_set_parent
  (lambda (child:Widget* parent)
    (tset! child 4 parent)))

(bind-func Widget_left_child
  (lambda (widget:Widget*)
    (tref widget 5)))

(bind-func Widget_set_left_child
  (lambda (parent:Widget* child)
    (tset! parent 5 child)))

(bind-func Widget_right_child
  (lambda (widget:Widget*)
    (tref widget 6)))

(bind-func Widget_set_right_child
  (lambda (parent:Widget* child)
    (tset! parent 6 child)))

(bind-func Widget_print
  (lambda (widget:Widget*)
    (if (null? widget)
        (printf "<Widget 0x0>")
        (printf "<Widget %p\n        id=%d\n        size=%.3f\n        type=%lld\n        parent=%p\n        Lchild=%p\n        Rchild=%p\n>"
                widget
                (Widget_id widget)
                (convert (Widget_size widget) double)
                (Widget_type widget)
                ;; (Widget_cb widget) ;; callback
                (Widget_parent widget)
                (Widget_left_child widget)
                (Widget_right_child widget)))
    void))

(bind-func Widget_tostring
  (lambda (widget:Widget*)
    (let ((s:i8* (salloc 1024)))
      (if (null? widget)
          (sprintf s "<Widget 0x0>")
          (sprintf s
                   "<Widget %p\n        id=%d\n        size=%.3f\n        type=%lld\n        parent=%p\n        Lchild=%p\n        Rchild=%p\n>"
                   widget
                   (Widget_id widget)
                   (convert (Widget_size widget) double)
                   (Widget_type widget)
                   ;; (Widget_cb widget) ;; callback
                   (Widget_parent widget)
                   (Widget_left_child widget)
                   (Widget_right_child widget)))
      (Str s))))

(bind-poly print Widget_print)
(bind-poly tostring Widget_tostring)

;; create

(bind-func Widget_create_with_cb
  (lambda (id size type cb:WidgetCB)
    (Widget_h id size type cb null null null)))

(bind-poly Widget_create Widget_create_with_cb)

;; destroy (free)

;; this should really fix up the widget tree as well, but that makes
;; it a fair bit more complicated. left as an excercise to the reader :)
(bind-func Widget_destroy
  (lambda (widget:Widget*)
    (free widget)))

(bind-func Widget_leaf_p
  (lambda (widget:Widget*)
    (and (null? (Widget_left_child widget))
         (null? (Widget_right_child widget)))))

(bind-func Widget_inner_p
  (lambda (widget:Widget*)
    (not (Widget_leaf_p widget))))

(bind-func Widget_parent_p
  (lambda (child:Widget* parent:Widget*)
    (= (Widget_parent child) parent)))

(bind-func Widget_child_p
  (lambda (parent:Widget* child:Widget*)
    (or (= (Widget_left_child parent) child)
        (= (Widget_right_child parent) child))))

;; walk the widget tree (preorder), applying fn to each widget
(bind-func Widget_walk_preorder
  (lambda (widget:Widget* visit_fn:[void,Widget*]*)
    (if (null? widget)
        widget
        (begin
          (visit_fn widget)
          (Widget_walk_preorder (Widget_left_child widget) visit_fn)
          (Widget_walk_preorder (Widget_right_child widget) visit_fn)
          null))))

;; returns the first widget for which pred returns true
(bind-func Widget_find_preorder
  (lambda (widget:Widget* pred:[i1,Widget*]*)
    (if (and (not (null? widget)) (pred widget))
        widget
        (if (not (null? widget))
            (begin
              (Widget_find_preorder (Widget_left_child widget) pred)
              (Widget_find_preorder (Widget_right_child widget) pred))
            null))))

;; this is untested
(bind-func Widget_find_inorder
  (lambda (widget:Widget* pred:[i1,Widget*]*)
    (if (not (null? widget))
        (begin
          (Widget_find_inorder (Widget_left_child widget) pred)
          (if (and (not (null? widget)) (pred widget))
              widget
              
              (Widget_find_inorder (Widget_right_child widget) pred)))
        null)))

;; this is untested
(bind-func Widget_find_postorder
  (lambda (widget:Widget* pred:[i1,Widget*]*)
    (if (not (null? widget))
        (begin
          (Widget_find_postorder (Widget_left_child widget) pred)
          (Widget_find_postorder (Widget_right_child widget) pred)
          (if (and (not (null? widget)) (pred widget)) widget
              null)))))

;; the GUI type

;; 0. GLFW window
;; 1. nanovg context
;; 2. root widget
;; 3. width
;; 4. height
;; 5. pixel ratio
(bind-type GUI <GLFWwindow*,NVGcontext*,Widget*,float,float,float>)

;; accessors
(bind-func GUI_window
  (lambda (gui:GUI*)
    (tref gui 0)))

(bind-func GUI_context
  (lambda (gui:GUI*)
    (tref gui 1)))

(bind-func GUI_root
  (lambda (gui:GUI*)
    (tref gui 2)))

(bind-func GUI_set_root
  (lambda (gui:GUI* widget)
    (tset! gui 2 widget)))

(bind-func GUI_width
  (lambda (gui:GUI*)
    (tref gui 3)))

(bind-func GUI_height
  (lambda (gui:GUI*)
    (tref gui 4)))

(bind-func GUI_pixel_ratio
  (lambda (gui:GUI*)
    (tref gui 5)))

(bind-func GUI_print
  (lambda (gui:GUI*)
    (if (null? gui)
        (printf "<GUI 0x0>")
        (printf "<GUI %p\n     window=%p\n     context=%p\n     root=%p\n     width=%.1f\n     height=%.1f\n     pixelRatio=%.1f\n>"
                gui
                (GUI_window gui)
                (GUI_context gui)
                (GUI_root gui)
                (convert (GUI_width gui) double)
                (convert (GUI_height gui) double)
                (convert (GUI_pixel_ratio gui) double)))
    void))

(bind-func GUI_tostring
  (lambda (gui:GUI*)
    (let ((s:i8* (salloc 1024)))
      (if (null? gui)
          (sprintf s "<GUI 0x0>")
          (sprintf s
                   "<GUI %p\n     window=%p\n     context=%p\n     root=%p\n     width=%.1f\n     height=%.1f\n     pixelRatio=%.1f\n>"
                   gui
                   (GUI_window gui)
                   (GUI_context gui)
                   (GUI_root gui)
                   (convert (GUI_width gui) double)
                   (convert (GUI_height gui) double)
                   (convert (GUI_pixel_ratio gui) double)))
      (Str s))))

(bind-poly print GUI_print)
(bind-poly tostring GUI_tostring)

;; this is the global gui structure - there can only be one in each
;; Extempore process

(bind-val EXTEMPORE_GUI GUI*)

(bind-func gui_init
  (lambda (width height)
    ;; (if (not (null? EXTEMPORE_GUI))
    ;;     (begin
    ;;       (println "Extempore GUI is already initialised, and cannot be re-initialised.")
    ;;       EXTEMPORE_GUI))
    (let ((ww:i32* (alloc))
          (wh:i32* (alloc))
          (fbw:i32* (alloc))
          (fbh:i32* (alloc))
          (window null)
          (vg null))
      ;; set up GLFW
      (glfwSetErrorCallback (convert (get_native_fptr glfw_error_callback)))
      (set! window (glfw_init_and_create_interaction_window width height))
      ;; (glfwSetInputMode window GLFW_STICKY_KEYS 1)
      ;; (glfwSetInputMode window GLFW_STICKY_MOUSE_BUTTONS 1)
      ;; set up nanovg
      (set! vg (nvg_create_context))
      (glfwGetWindowSize window ww wh)
      (glfwGetFramebufferSize window fbw fbh)
      ;; create the new GUI data type
      (set! EXTEMPORE_GUI
            (GUI_h
             window
             vg
             null
             (convert (pref ww 0) float)
             (convert (pref wh 0) float)
             (/ (convert (pref fbw 0) float) (convert (pref ww 0) float)))))))

(bind-val WIDGET_SPLIT_VERTICAL i64 (real->integer (expt 2 0)))
(bind-val WIDGET_SPLIT_HORIZONTAL i64 (real->integer (expt 2 1)))

;; walks the tree in pre-order
(bind-func gui_render_subtree
  (lambda (widget:Widget* bounds:Rect*)
    (if (null? widget)
        widget
        (if (and (null? (Widget_left_child widget))
                 (null? (Widget_right_child widget)))
            ;; if a leaf node, set the nanovg transform matrix and
            ;; call the render callback
            (let ((winWidth (GUI_width EXTEMPORE_GUI))
                  (winHeight (GUI_height EXTEMPORE_GUI))
                  (vg (GUI_context EXTEMPORE_GUI)))
              ;; (nvgResetTransform vg)
              ;; (nvgTranslate vg x y)
              ;; (nvgScale vg w h)
              ((Widget_cb widget) widget bounds)
              null)
            ;; otherwise recurse into the child widgets - horizontal
            ;; splits only at this point
            (let ((lchild (Widget_left_child widget))
                  (rchild (Widget_right_child widget))
                  (lsize (Widget_size lchild))
                  (rsize (Widget_size rchild))
                  (totalsize (+ lsize rsize)))
              ;; normalise sizes
              (set! lsize (/ lsize totalsize))
              (set! rsize (/ rsize totalsize))
              ;; recurse into children
              (if (= (& WIDGET_SPLIT_VERTICAL (Widget_type widget))
                     WIDGET_SPLIT_VERTICAL)
                  ;; split horizontally (default)
                  (begin
                    (gui_render_subtree (Widget_left_child widget)
                                        (Rect (tref bounds 0)
                                              (tref bounds 1)
                                              (tref bounds 2)
                                              (* lsize (tref bounds 3))))
                    (gui_render_subtree (Widget_right_child widget)
                                        (Rect (tref bounds 0)
                                              (+ (tref bounds 1)
                                                 (* lsize (tref bounds 3)))
                                              (tref bounds 2)
                                              (* rsize (tref bounds 3)))))
                  ;; split vertically
                  (begin
                    (gui_render_subtree (Widget_left_child widget)
                                        (Rect (tref bounds 0)
                                              (tref bounds 1)
                                              (* lsize (tref bounds 2))
                                              (tref bounds 3)))
                    (gui_render_subtree (Widget_right_child widget)
                                        (Rect (+ (tref bounds 0)
                                                 (* lsize (tref bounds 2)))
                                              (tref bounds 1)
                                              (* rsize (tref bounds 2))
                                              (tref bounds 3)))))
              (convert null))))))

(bind-func gui_render
  (lambda ()
    (glClear (bitwise-or GL_COLOR_BUFFER_BIT
                         GL_DEPTH_BUFFER_BIT
                         GL_STENCIL_BUFFER_BIT))
    (nvgBeginFrame (GUI_context EXTEMPORE_GUI)
                   (convert (GUI_width EXTEMPORE_GUI))
                   (convert (GUI_height EXTEMPORE_GUI))
                   (GUI_pixel_ratio EXTEMPORE_GUI))
    (gui_render_subtree (GUI_root EXTEMPORE_GUI) (Rect 0. 0. (GUI_width EXTEMPORE_GUI) (GUI_height EXTEMPORE_GUI)))
    (nvgEndFrame (GUI_context EXTEMPORE_GUI))
    (glfwPollEvents)
    (glfwSwapBuffers (GUI_window EXTEMPORE_GUI))))

;; some useful helper search functions

(bind-func gui_find_parent
  (lambda (widget:Widget*)
    (Widget_find_preorder
     (GUI_root EXTEMPORE_GUI)
     (lambda (w)
       (Widget_parent_p widget w)))))

(bind-func gui_find_leaf_preorder
  (lambda ()
    (Widget_find_preorder
     (GUI_root EXTEMPORE_GUI)
     Widget_leaf_p)))

(bind-func gui_find_leaf_inorder
  (lambda ()
    (Widget_find_inorder
     (GUI_root EXTEMPORE_GUI)
     Widget_leaf_p)))

(bind-func gui_find_leaf_postorder
  (lambda ()
    (Widget_find_postorder
     (GUI_root EXTEMPORE_GUI)
     Widget_leaf_p)))

(bind-func gui_find_widget_with_id
  (lambda (id)
    (Widget_find_preorder
     (GUI_root EXTEMPORE_GUI)
     (lambda (w)
       (= (Widget_id w) id)))))

;; modify the GUI tree

(bind-func gui_add_widget
  (lambda (new_widget:Widget* split)
    (if (not (Widget_leaf_p new_widget))
        (begin (println "Cannot add non-leaf widget")
               new_widget)
        (let ((old_leaf (gui_find_leaf_preorder)))
          (if (null? old_leaf)
              (GUI_set_root EXTEMPORE_GUI new_widget)
              (let (;; reverse these two assignments to add the new
                    ;; widget as the left child
                    (new_lchild old_leaf)
                    (new_rchild new_widget)
                    (old_parent (Widget_parent old_leaf))
                    (new_parent (Widget_h -1 ;; internal nodes have id -1
                                          (Widget_size old_leaf)
                                          split
                                          null
                                          (Widget_parent old_leaf)
                                          new_lchild
                                          new_rchild)))
                ;; set up new parent pointers
                (Widget_set_parent new_lchild new_parent)
                (Widget_set_parent new_rchild new_parent)
                ;; if necessary, reconnect the widget tree
                (if (null? old_parent)
                    ;; if old leaf node was the root node
                    (GUI_set_root EXTEMPORE_GUI new_parent)
                    ;; otherwise set child pointers in old parent
                    (if (= (Widget_left_child old_parent) old_leaf)
                        (Widget_set_left_child old_parent new_parent)
                        (if (= (Widget_right_child old_parent) old_leaf)
                            (Widget_set_right_child old_parent new_parent))
                        (println "Error in gui_add_widget: could not reconnect the widget tree")))
                ;; return the new_lchild
                new_lchild))))))

(bind-func gui_validate
  (lambda ()
    ;; check that all nodes are either full, or leaves
    (null?
     (Widget_find_preorder
      (GUI_root EXTEMPORE_GUI)
      (lambda (w)
        ;; need an exclusive or...
        (not (or (and (null? (Widget_left_child w))
                      (null? (Widget_right_child w)))
                 (and (not (null? (Widget_left_child w)))
                      (not (null? (Widget_right_child w)))))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; mouse/keyboard input ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;

;; these functions are heavily glfw-based, and they must be called
;; from inside a widget callback, since they use the current nanovg
;; transform to do hit-detection

(bind-func gui_mouse_x
  (lambda ()
    (let ((x_ptr:double* (salloc))
          (y_ptr:double* (salloc)))
      (glfwGetCursorPos (GUI_window EXTEMPORE_GUI) x_ptr y_ptr)
      (convert (pref x_ptr 0) float))))

(bind-func gui_mouse_y
  (lambda ()
    (let ((x_ptr:double* (salloc))
          (y_ptr:double* (salloc)))
      (glfwGetCursorPos (GUI_window EXTEMPORE_GUI) x_ptr y_ptr)
      (convert (pref y_ptr 0) float))))

(bind-func gui_inbounds_p
  (lambda (bounds:Rect*)
    (let ((x (gui_mouse_x))
          (y (gui_mouse_y))
          (xmin (tref bounds 0))
          (xmax (+ xmin (tref bounds 2)))
          (ymin (tref bounds 1))
          (ymax (+ ymin (tref bounds 3))))
      ;; a simple hit-test
      (and (< xmin x) (> xmax x)
           (< ymin y) (> ymax y)))))

(bind-func gui_click_p
  (lambda (bounds:Rect* button)
    (and (gui_inbounds_p bounds)
         (= (glfwGetMouseButton (GUI_window EXTEMPORE_GUI)
                                button)
            GLFW_PRESS))))

(bind-func gui_left_click_p
  (lambda (bounds:Rect*)
    (gui_click_p bounds GLFW_MOUSE_BUTTON_1)))

(bind-func gui_right_click_p
  (lambda (bounds:Rect*)
    (gui_click_p bounds GLFW_MOUSE_BUTTON_2)))

(bind-func gui_enter_p
  (let ((prev 0)
        (curr 0))
    (lambda (bounds:Rect*)
      (set! curr (gui_inbounds_p bounds))
      (if (and (not prev) curr)
          (begin (set! prev curr) 1)
          (begin (set! prev curr) 0)))))

(bind-func gui_leave_p
  (let ((prev 0)
        (curr 0))
    (lambda (bounds:Rect*)
      (set! curr (gui_inbounds_p bounds))
      (if (and prev (not curr))
          (begin (set! prev curr) 1)
          (begin (set! prev curr) 0)))))

(bind-func gui_keypress_p
  (lambda (key)
    (= (glfwGetKey (GUI_window EXTEMPORE_GUI) key)
       GLFW_PRESS)))

(bind-func gui_keyrelease_p
  (lambda (key)
    (= (glfwGetKey (GUI_window EXTEMPORE_GUI) key)
       GLFW_RELEASE)))

;; fonts

(bind-func gui_load_opensans_fonts
  "load OpenSans .ttf fonts

If you don't have OpenSans on your system, you can download it for free from www.fontsquirrel.com"
  (lambda (opensans_dir:i8*)
    (let ((path:i8* (zalloc 256)))
      (sprintf path "%s/OpenSans-Bold.ttf" opensans_dir)
      (nvgCreateFont (GUI_context EXTEMPORE_GUI) "Bold" path)
      (sprintf path "%s/OpenSans-BoldItalic.ttf" opensans_dir)
      (nvgCreateFont (GUI_context EXTEMPORE_GUI) "BoldItalic" path)
      (sprintf path "%s/OpenSans-ExtraBold.ttf" opensans_dir)
      (nvgCreateFont (GUI_context EXTEMPORE_GUI) "ExtraBold" path)
      (sprintf path "%s/OpenSans-ExtraBoldItalic.ttf" opensans_dir)
      (nvgCreateFont (GUI_context EXTEMPORE_GUI) "ExtraBoldItalic" path)
      (sprintf path "%s/OpenSans-Italic.ttf" opensans_dir)
      (nvgCreateFont (GUI_context EXTEMPORE_GUI) "Italic" path)
      (sprintf path "%s/OpenSans-Light.ttf" opensans_dir)
      (nvgCreateFont (GUI_context EXTEMPORE_GUI) "Light" path)
      (sprintf path "%s/OpenSans-LightItalic.ttf" opensans_dir)
      (nvgCreateFont (GUI_context EXTEMPORE_GUI) "LightItalic" path)
      (sprintf path "%s/OpenSans-Regular.ttf" opensans_dir)
      (nvgCreateFont (GUI_context EXTEMPORE_GUI) "Regular" path)
      (sprintf path "%s/OpenSans-Semibold.ttf" opensans_dir)
      (nvgCreateFont (GUI_context EXTEMPORE_GUI) "Semibold" path)
      (sprintf path "%s/OpenSans-SemiboldItalic.ttf" opensans_dir)
      (nvgCreateFont (GUI_context EXTEMPORE_GUI) "SemiboldItalic" path))))

;; default colours

(bind-val GUI_COLOR_BG NVGcolor*)
(bind-val GUI_COLOR_BORDER NVGcolor*)
(bind-val GUI_COLOR_HOVER NVGcolor*)
(bind-val GUI_COLOR_CLICK NVGcolor*)
(bind-val GUI_COLOR_TEXT NVGcolor*)

(bind-func gui_set_default_color_theme
  (lambda ()
    (set! GUI_COLOR_BG (NVGcolor .11 .11 .2 1.))
    (set! GUI_COLOR_BORDER (NVGcolor .3 .27 .4 1.))
    (set! GUI_COLOR_HOVER (NVGcolor .19 .21 .25 1.))
    (set! GUI_COLOR_CLICK (NVGcolor .4 .42 .51 1.))
    (set! GUI_COLOR_TEXT (NVGcolor .67 .7 .73 1.))
    void))

;;;;;;;;;;;;;
;; widgets ;;
;;;;;;;;;;;;;

(bind-val WIDGET_BUTTON i64 (real->integer (expt 2 2)))
(bind-val WIDGET_LABEL i64 (real->integer (expt 2 3)))
(bind-val WIDGET_IMAGE i64 (real->integer (expt 2 4)))
(bind-val WIDGET_FBO i64 (real->integer (expt 2 5)))

;; button

(bind-func Widget_create_button
  (lambda (id size label:i8*)
    (let ((lab (Str label))
          (cb (lambda (widget:Widget* bounds:Rect*)
                (let ((vg (GUI_context EXTEMPORE_GUI)))
                  (nvgSave vg)
                  (nvgBeginPath vg)
                  ;; assume matrix transform -> [0,1]^2 has been applied
                  (cond ((gui_left_click_p bounds)
                         (_nvgFillColor vg GUI_COLOR_CLICK))
                        ((gui_inbounds_p bounds)
                         (_nvgFillColor vg GUI_COLOR_HOVER))
                        (else
                         (_nvgFillColor vg GUI_COLOR_BG)))
                  (nvgRect vg
                           (tref bounds 0)
                           (tref bounds 1)
                           (tref bounds 2)
                           (tref bounds 3))
                  (nvgFill vg)
                  (nvgRestore vg))
                void)))
      (Widget_create id size WIDGET_BUTTON cb))))


(impc:aot:insert-footer "xtmgui")
(define *xtmlib-gui-loaded* #t)
