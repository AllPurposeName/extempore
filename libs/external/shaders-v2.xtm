(sys:load "libs/shaders-v2.xtm" 'quiet)
(sys:load-preload-check 'shaders-v2)
(define *xtmlib-shaders-v2-loaded* #f)

(impc:aot:suppress-aot-do
 (sys:load "libs/external/gl.xtm")
 (sys:load "libs/external/stb_image.xtm"))
(impc:aot:insert-sexp '(sys:load "libs/external/gl.xtm" 'quiet))
(impc:aot:insert-sexp '(sys:load "libs/external/stb_image.xtm" 'quiet))

(impc:aot:insert-header "xtmshaders-v2")

(bind-alias GLbitfield i32)
(bind-alias GLboolean i8)
(bind-alias GLbyte i8)
(bind-alias GLclampf i32)
(bind-alias GLenum i32)
(bind-alias GLfloat i32)
(bind-alias GLint i32)
(bind-alias GLshort i16)
(bind-alias GLsizei i32)
(bind-alias GLubyte i8)
(bind-alias GLuint i32)
(bind-alias GLushort i16)
(bind-alias GLvoid i8)
(bind-alias GLintptr i64)
(bind-alias GLsizeiptr i64)

;; id, type, size (bytes), data
(bind-type VBO <GLuint,GLenum,GLsizeiptr,GLvoid*>)

;; accessors

(bind-func VBO_id
  (lambda (vbo:VBO*)
    (tref vbo 0)))

(bind-func VBO_type
  (lambda (vbo:VBO*)
    (tref vbo 1)))

(bind-func VBO_size
  (lambda (vbo:VBO*)
    (tref vbo 2)))

(bind-func VBO_data
  (lambda (vbo:VBO*)
    (tref vbo 3)))

(bind-func VBO_print
  (lambda (vbo:VBO*)
    (printf "VBO: <id=%d type=%s nbytes=%d data=%p>"
            (tref vbo 0)
            (let ((type (VBO_type vbo)))
              (cond ((= type GL_BYTE) "byte")
                    ((= type GL_SHORT) "short")
                    ((= type GL_INT) "int")
                    ((= type GL_FLOAT) "float")
                    (else "unknown")))
            (tref vbo 2)
            (tref vbo 3))
    void))

(bind-poly print VBO_print)

(bind-func VBO_tostring
  (lambda (vbo:VBO*)
    (let ((s:i8* (salloc 256)))
      (sprintf s "VBO: <id=%d type=%s nbytes=%d data=%p>"
               (tref vbo 0)
               (let ((type (VBO_type vbo)))
                 (cond ((= type GL_BYTE) "byte")
                    ((= type GL_SHORT) "short")
                    ((= type GL_INT) "int")
                    ((= type GL_FLOAT) "float")
                    (else "unknown")))
               (tref vbo 2)
               (tref vbo 3))
      (Str s))))

(bind-poly tostring VBO_tostring)

(bind-func VBO_create_float
  (lambda (buf:float* buflen)
    (let ((vbo:VBO* (zalloc))
          (id:GLuint* (salloc)))
      (glGenBuffers 1 id)
      (gl_print_error "Error creating VBO")
      (tfill! vbo
              (pref id 0)
              GL_FLOAT
              (* buflen 4) ;; sizeof(float)
              (cast buf GLvoid*))
      (glBindBuffer GL_ARRAY_BUFFER (VBO_id vbo))
      (glBufferData GL_ARRAY_BUFFER (VBO_size vbo) (VBO_data vbo) GL_STREAM_DRAW)
      (gl_print_error "Error setting VBO data")
      (printf "Created ") (VBO_print vbo) (printf "\n")
      vbo)))

(bind-func VBO_create_i32
  (lambda (buf:i32* buflen)
    (let ((vbo:VBO* (zalloc))
          (id:GLuint* (salloc)))
      (glGenBuffers 1 id)
      (gl_print_error "Error creating VBO")
      (tfill! vbo
              (pref id 0)
              GL_INT
              (* buflen 4) ;; sizeof(float)
              (cast buf GLvoid*))
      (glBindBuffer GL_ARRAY_BUFFER (VBO_id vbo))
      (glBufferData GL_ARRAY_BUFFER (VBO_size vbo) (VBO_data vbo) GL_STREAM_DRAW)
      (gl_print_error "Error setting VBO data")
      (printf "Created ") (VBO_print vbo) (printf "\n")
      vbo)))

(bind-poly VBO_create VBO_create_float)
(bind-poly VBO_create VBO_create_i32)

(bind-func VBO_update_data
  "update the full buffer"
  (lambda (vbo:VBO*)
    (glBindBuffer GL_ARRAY_BUFFER (VBO_id vbo))
    (gl_print_error "Error binding VBO")
    (glBufferSubData GL_ARRAY_BUFFER 0 (VBO_size vbo) (VBO_data vbo))
    (gl_print_error "Error updating VBO subdata")
    (glBindBuffer GL_ARRAY_BUFFER 0)))

(bind-func VBO_delete
  (lambda (vbo:VBO*)
    (let ((id:GLuint* (salloc)))
      (pset! id 0 (VBO_id vbo))
      (glDeleteBuffers 1 id)
      (gl_print_error "Error deleting VBO")
      (free vbo))))

(bind-type VAO <GLuint>)

(bind-func VAO_id
  (lambda (vao:VAO*)
    (tref vao 0)))

(bind-func VAO_print
  (lambda (vao:VAO*)
    (printf "VAO: id %d" (tref vao 0))
    void))

(bind-poly print VAO_print)

(bind-func VAO_tostring
  (lambda (vao:VAO*)
    (let ((s:i8* (salloc 256)))
      (sprintf s "VAO: id %d" (tref vao 0))
      (Str s))))

(bind-poly tostring VAO_tostring)

(bind-func VAO_create
  (lambda ()
    (let ((vao:VAO* (zalloc))
          (id:GLuint* (salloc)))
      (glGenVertexArrays 1 id)
      (gl_print_error "Error creating VAO")
      (tset! vao 0 (pref id 0))
      vao)))

(bind-func bind_attribute_full
  (lambda (vao:VAO* vbo:VBO* index size stride offset)
    (glBindVertexArray (VAO_id vao))
    (gl_print_error "Error binding VAO")
    (glBindBuffer GL_ARRAY_BUFFER (VBO_id vbo))
    (gl_print_error "Error binding VBO")
    (let ((component_size 4)) ;; for for GL_FLOAT and GL_INT
      (glVertexAttribPointer index
                             size
                             (VBO_type vbo)
                             GL_FALSE
                             (* component_size stride)
                             (pref-ptr (cast null GLvoid*) (* component_size offset))))
    (gl_print_error "Error binding VAO attribute")
    (glEnableVertexAttribArray index)
    (gl_print_error "Error enabling VAO attribute")
    (glBindVertexArray 0)))

(bind-func bind_attribute_packed
  (lambda (vao vbo index size)
    (bind_attribute_full vao vbo index size 0 0)))

(bind-poly bind_attribute bind_attribute_full)
(bind-poly bind_attribute bind_attribute_packed)

(bind-func draw_vertex_array
  (lambda (vao:VAO* draw_mode first_element count)
    (glBindVertexArray (VAO_id vao))
    (gl_print_error "Error binding vertex array")
    (glDrawArrays draw_mode first_element count)
    (gl_print_error "Error drawing vertex array")
    (glBindVertexArray 0)))

(bind-func VAO_delete
  (lambda (vao:VAO*)
    (let ((id:GLuint* (salloc)))
      (pset! id 0 (VAO_id vao))
      (glDeleteVertexArrays 1 id)
      (gl_print_error "Error deleting VAO")
      (free vao))))

(bind-alias Texture GLuint)

(bind-func Texture_create
  (lambda ()
    (let ((id:GLuint* (salloc)))
      (glGenTextures 1 id)
      (gl_print_error "Error creating Texture")
      (pref id 0))))

;; (bind-func Texture_bind
;;   (lambda (tex:Texture data:GLvoid*)
;;     (glBindTexture GL_TEXTURE_2D (Texture_id tex))
;;     (glTexImage2D GL_TEXTURE_2D 0 GL_RGB 2 2 0 GL_RGB GL_FLOAT data)
;;     (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_WRAP_S GL_CLAMP_TO_EDGE)
;;     (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_WRAP_T GL_CLAMP_TO_EDGE)
;;     (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_MIN_FILTER GL_LINEAR)
;;     (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_MAG_FILTER GL_LINEAR)
;;     void))

(bind-func Texture_delete
  (lambda (tex:Texture)
    (let ((id:GLuint* (salloc)))
      (pset! id 0 tex)
      (glDeleteTextures 1 id)
      (gl_print_error "Error deleting Texture"))))

(bind-func bind_image_texture
  (lambda (tex:Texture filename)
    (let ((width_ptr:i32* (salloc))
          (height_ptr:i32* (salloc))
          (comp_ptr:i32* (salloc))
          (data (stbi_load filename width_ptr height_ptr comp_ptr 4)))
      (if (null? data)
          (begin (println (stbi_failure_reason))
                 -1)
          (begin
            (glActiveTexture GL_TEXTURE0)
            (glBindTexture GL_TEXTURE_2D tex)
            (glTexImage2D GL_TEXTURE_2D 0
                          GL_RGBA
                          (pref width_ptr 0)
                          (pref height_ptr 0)
                          0
                          GL_RGBA
                          GL_UNSIGNED_BYTE
                          data)
            ;; set some parameters
            (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_WRAP_S GL_CLAMP_TO_EDGE)
            (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_WRAP_T GL_CLAMP_TO_EDGE)
            (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_MIN_FILTER GL_LINEAR)
            (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_MAG_FILTER GL_LINEAR)
            (gl_print_error "couldn't bind_image_texture")
            tex)))))

;; shaders

;;                <id    ,type  >
(bind-type Shader <GLuint,GLenum>)
(bind-alias ShaderProgram GLuint)

(bind-func Shader_id
  (lambda (shader:Shader*)
    (tref shader 0)))

(bind-func Shader_type
  (lambda (shader:Shader*)
    (tref shader 1)))

(bind-func Shader_print_info_log
  (let ((max_log_length 4096)
        (logbuf:i8* (zalloc max_log_length)))
    (lambda (shader:Shader*)
      (let ((len_ptr (salloc 1 i32)))
        (glGetShaderInfoLog (Shader_id shader)
                            max_log_length
                            len_ptr
                            logbuf)
        (printf "%s shader info log: %s\n"
                (cond ((= (Shader_type shader) GL_VERTEX_SHADER)
                       "Vert")
                      ((= (Shader_type shader) GL_FRAGMENT_SHADER)
                       "Frag")
                      ((= (Shader_type shader) GL_GEOMETRY_SHADER)
                       "Geom")
                      (else ""))
                (if (= (pref len_ptr 0) 0)
                    "OK"
                    logbuf))
        (if (= (pref len_ptr 0) 0) 0 1)))))

(bind-func ShaderProgram_print_info_log
  (let ((max_log_length 4096)
        (logbuf:i8* (zalloc max_log_length)))
    (lambda (program:ShaderProgram)
      (let ((len_ptr (salloc 1 i32)))
        (glGetProgramInfoLog program
                             max_log_length
                             len_ptr
                             logbuf)
        (printf "Program info log: %s\n"
                (if (= (pref len_ptr 0) 0)
                    "OK"
                    logbuf))
        (if (= (pref len_ptr 0) 0) 0 1)))))

(bind-func Shader_create
  "create (and compile) an OpenGL shader"
  (lambda (source:i8* type:GLenum)
    (if (not (or (= type GL_VERTEX_SHADER)
                 (= type GL_FRAGMENT_SHADER)
                 (= type GL_GEOMETRY_SHADER)))
        (begin (println "Error: shader type must be one of GL_VERTEX_SHADER, GL_FRAGMENT_SHADER or GL_GEOMETRY_SHADER")
               null)
        (let ((shader_id (glCreateShader type))
              (source_ptr:i8** (salloc))
              (shader (Shader shader_id type)))
          (pset! source_ptr 0 source)
          (glShaderSource shader_id 1 source_ptr (cast null i32*))
          (glCompileShader shader_id)
          (Shader_print_info_log shader)
          shader))))

(bind-func ShaderProgram_create_vf
  "compile and link shader program (vert and frag shader)"
  (lambda (vert:Shader* frag:Shader*)
    (if (not (and (= (Shader_type vert) GL_VERTEX_SHADER)
                  (= (Shader_type frag) GL_FRAGMENT_SHADER)))
        (begin (println "Error: input shader types must be vert and frag respectively.")
               -1)
        (let ((program (glCreateProgram)))
          (glAttachShader program (Shader_id vert))
          (glAttachShader program (Shader_id frag))
          (glLinkProgram program)
          (ShaderProgram_print_info_log program)
          program))))

(bind-func ShaderProgram_create_vgf
  "compile and link shader program (vert and frag shader)"
  (lambda (vert:Shader* geom:Shader* frag:Shader*)
    (if (not (and (= (Shader_type vert) GL_VERTEX_SHADER)
                  (= (Shader_type geom) GL_GEOMETRY_SHADER)
                  (= (Shader_type frag) GL_FRAGMENT_SHADER)))
        (begin (println "Error: input shader types must be vert and frag respectively.")
               -1)
        (let ((program (glCreateProgram)))
          (glAttachShader program (Shader_id vert))
          (glAttachShader program (Shader_id geom))
          (glAttachShader program (Shader_id frag))
          (glLinkProgram program)
          (ShaderProgram_print_info_log program)
          program))))

;; these ones are handy when you want to create a new shader program
;; directly from the sources

(bind-func ShaderProgram_create_vsfs
  "compile and link shader program (vert and frag shader source)"
  (lambda (vsource:i8* fsource:i8*)
    (let ((vert (Shader_create vsource GL_VERTEX_SHADER))
          (frag (Shader_create fsource GL_FRAGMENT_SHADER)))
      (if (or (null? vert) (null? frag))
          -1
          (ShaderProgram_create_vf vert frag)))))

(bind-func ShaderProgram_create_vsgsfs
  "compile and link shader program (vert and frag shader source)"
  (lambda (vsource:i8* gsource:i8* fsource:i8*)
    (let ((vert (Shader_create vsource GL_VERTEX_SHADER))
          (geom (Shader_create vsource GL_GEOMETRY_SHADER))
          (frag (Shader_create fsource GL_FRAGMENT_SHADER)))
      (if (or (null? vert) (null? geom) (null? frag))
          -1
          (ShaderProgram_create_vgf vert geom frag)))))

(bind-poly ShaderProgram_create ShaderProgram_create_vf)
(bind-poly ShaderProgram_create ShaderProgram_create_vgf)
(bind-poly ShaderProgram_create ShaderProgram_create_vsfs)
(bind-poly ShaderProgram_create ShaderProgram_create_vsgsfs)

(impc:aot:insert-footer "xtmshaders-v2")
(define *xtmlib-shaders-v2-loaded* #t)
