;; to compile math lib:
;; (sys:load "libs/precompile-lib.xtm")
;; (sys:precomp:compile-xtm-file "libs/core/math.xtm" #t #t)

(sys:load "libs/core/math.xtm")

;; set up the current dylib name and path (for precompilation)
(sys:precomp:set-dylib-name-info
 'libcpic2
 (cond ((string=? (sys:platform) "OSX")
        "/Users/ben/Code/src/pic2/libcpic2.dylib")
       ((string=? (sys:platform) "Linux")
        "libcpic2.so")
       ((string=? (sys:platform) "Windows")
        "libcpic2.dll")
       (else
        (begin (print-with-colors 'red 'default #f (print "Error"))
               (print ": unsupported platform ")
               (print-with-colors 'yellow 'default #f (print (sys:platform)))))))

;; load the dylib
(define libcpic2
  (sys:load-dylib (cdr *sys:precomp:current-load-dylib-info*)))

(bind-type timeval <i64,i64>) ;; <time_t,suseconds_t>

;; from pic2.h

(bind-lib libcpic2 dtimer [void,double*,timeval*,i32]*)
(bind-lib libcpic2 main [i32,i32,i8**]*)

;; from push2.h

(bind-lib libcpic2 ranorm [double]*)
(bind-lib libcpic2 randum [double]*)
(bind-lib libcpic2 cdistr2 [void,float*,float,float,float,float,i32,i32,i32,i32,i32,i32,i32]*)
(bind-lib libcpic2 cgpush2l [void,float*,float*,float,float,float*,i32,i32,i32,i32,i32,i32,i32]*)
(bind-lib libcpic2 cdgpush2l [void,double*,double*,double,double,double*,i32,i32,i32,i32,i32,i32,i32]*)
(bind-lib libcpic2 cgpost2l [void,float*,float*,float,i32,i32,i32,i32]*)
(bind-lib libcpic2 cdsortp2yl [void,float*,float*,i32*,i32,i32,i32]*)
(bind-lib libcpic2 ccguard2l [void,float*,i32,i32,i32,i32]*)
(bind-lib libcpic2 caguard2l [void,float*,i32,i32,i32,i32]*)
(bind-lib libcpic2 cpois22 [void,cpxf*,cpxf*,i32,cpxf*,float,float,float,float*,i32,i32,i32,i32,i32,i32]*)
(bind-lib libcpic2 cwfft2rinit [void,i32*,cpxf*,i32,i32,i32,i32]*)
(bind-lib libcpic2 cfft2rxx [void,cpxf*,i32,i32*,cpxf*,i32,i32,i32,i32,i32,i32,i32,i32]*)
(bind-lib libcpic2 cfft2rxy [void,cpxf*,i32,i32*,cpxf*,i32,i32,i32,i32,i32,i32,i32,i32]*)
(bind-lib libcpic2 cfft2r2x [void,cpxf*,i32,i32*,cpxf*,i32,i32,i32,i32,i32,i32,i32,i32]*)
(bind-lib libcpic2 cfft2r2y [void,cpxf*,i32,i32*,cpxf*,i32,i32,i32,i32,i32,i32,i32,i32]*)
(bind-lib libcpic2 cwfft2rx [void,cpxf*,i32,i32*,cpxf*,i32,i32,i32,i32,i32,i32]*)
(bind-lib libcpic2 cwfft2r2 [void,cpxf*,i32,i32*,cpxf*,i32,i32,i32,i32,i32,i32]*)

;; main

(bind-func run_main
  (lambda ()
    (main 0 null)))

;; (run_main)

;; some test functions

(bind-func xtmain 500000000
  (let ( ;; parameters
        (indx:i32 9)
        (indy:i32 9)
        (npx:i32 3072)
        (npy:i32 3072)
        (ndim:i32 2)
        (tend:float 10.)
        (dt:float .1)
        (qme:float -1.)
        (vtx:float 1.)
        (vty:float 1.)
        (vx0:float 0.)
        (vy0:float 0.)
        (ax:float .912871)
        (ay:float .912871)
        (idimp:i32 4)
        (ipbc:i32 1)
        (sortime:i32 50)
        (wke:float* (zalloc))
        (we:float* (zalloc))
        (wt:float 0.)
        ;; scalars for standard code
        (j:i32 0)
        (np:i32 (* npx npy))
        (nx:i32 (<< 1:i32 indx)) ;; only works for indx < 2^31
        (ny:i32 (<< 1:i32 indy)) ;; only works for indx < 2^31
        (nxh:i32 (/ nx 2))
        (nyh:i32 (/ ny 2))
        (nxe:i32 (+ nx 2))
        (nye:i32 (+ ny 1))
        (nxeh:i32 (/ nxe 2))
        (nxyh:i32 (/ (max nx ny) 2))
        (nxhy:i32 (max nxh ny))
        (ny1:i32 (+ ny 1))
        (ntime:i32 0)
        (nloop:i32 (convert (+ (/ tend dt) .0001)))
        (isign:i32 0)
        (qbme:float qme)
        (affp:float (/ (convert (* nx ny) float)
                       (convert np float)))
        ;; allocate arrays for standard code
        (part:float* (zalloc (* idimp np)))
        (part2:float* (zalloc (* idimp np)))
        (tpart:float* null)
        (qe:float* (zalloc (* nxe nye)))
        (fxye:float* (zalloc (* ndim nxe nye)))
        (ffc:cpxf* (zalloc (* nxh nyh)))
        (mixup:i32* (zalloc nxhy))
        (sct:cpxf* (zalloc nxyh))
        (npicy:i32* (zalloc ny1))
        ;; timing data
        (time:float 0.)
        (itime:timeval* (zalloc))
        (tdpost:float 0.)
        (tguard:float 0.)
        (tfft:float 0.)
        (tfield:float 0.)
        (tpush:float 0.)
        (tsort:float 0.)
        (dtime:double* (zalloc))
        )
    (lambda ()
      ;; nloop = number of time steps in simulation
      ;; ntime = current time step
      ;; prepare FFT tables
      (cwfft2rinit mixup sct indx indy nxhy nxyh)
      ;; calculate form factors
      (set! isign 0)
      (cpois22 (cast qe cpxf*)
               (cast fxye cpxf*)
               isign ffc ax ay affp we nx ny nxeh nye nxh nyh)
      ;; initialize electrons
      (cdistr2 part vtx vty vx0 vy0 npx npy idimp np nx ny ipbc)
      ;; main iteration loop
      (println "\nStart iteration:" nloop "loops\n")
      (dotimes (ntime nloop)
        ;; check the mixup array
        ;; deposit charge with standard procedure: updates qe
        (if (= (% ntime 10) 0)
            (println "ntime:" ntime))
        (dtimer dtime itime -1)
        (dotimes (j (* nxe nye))
          (pset! qe j 0.))
        (cgpost2l part qe qme np idimp nxe nye)
        (dtimer dtime itime 1)
        (set! time (convert (pref dtime 0)))
        (set! tdpost (+ tdpost time))
        ;; (println "tdpost:" tdpost)
        ;; add guard cells with standard procedure: updates qe
        (dtimer dtime itime -1)
        (caguard2l qe nx ny nxe nye)
        (dtimer dtime itime 1)
        (set! time (convert (pref dtime 0)))
        (set! tguard (+ tguard time))
        ;; (println "tguard:" tguard)
        ;; transform charge to fourier space with standard procedure:
        ;; updates qe
        (dtimer dtime itime -1)
        (set! isign -1)
        (cwfft2rx (cast qe cpxf*) isign mixup sct indx indy nxeh nye nxhy nxyh)
        (dtimer dtime itime 1)
        (set! time (convert (pref dtime 0)))
        (set! tfft (+ tfft time))
        ;; (println "tfft:" tfft)
        ;; calculate force/charge in fourier space with standard
        ;; procedure: updates fxye
        (dtimer dtime itime -1)
        (set! isign -1)
        (cpois22 (cast qe cpxf*)
                 (cast fxye cpxf*)
                 isign ffc ax ay affp we nx ny nxeh nye nxh nyh)
        (dtimer dtime itime 1)
        (set! time (convert (pref dtime 0)))
        (set! tfield (+ tfield time))
        ;; (println "tfield:" tfield)
        ;; transform force to real space with standard procedure: updates fxye 
        (dtimer dtime itime -1)
        (set! isign 1)
        (cwfft2r2 (cast fxye cpxf*) isign mixup sct indx indy nxeh nye nxhy nxyh)
        (dtimer dtime itime 1)
        (set! time (convert (pref dtime 0)))
        (set! tfft (+ tfft time))
        ;; (println "tfft:" tfft)
        ;; copy guard cells with standard procedure: updates fxye 
        (dtimer dtime itime -1)
        (ccguard2l fxye nx ny nxe nye)
        (dtimer dtime itime 1)
        (set! time (convert (pref dtime 0)))
        (set! tguard (+ tguard time))
        ;; (println "tguard:" tguard)
        ;; push particles with standard procedure: updates part, wke 
        (pset! wke 0 0.)
        (dtimer dtime itime -1)
        (cgpush2l part fxye qbme dt wke idimp np nx ny nxe nye ipbc)
        (dtimer dtime itime 1)
        (set! time (convert (pref dtime 0)))
        (set! tpush (+ tpush time))
        ;; (println "tpush:" tpush)
        ;; sort particles by cell for standard procedure 
        (if (> sortime 0)
            (if (= (% ntime sortime) 0)
                (begin
                  (dtimer dtime itime -1)
                  (cdsortp2yl part part2 npicy idimp np ny1)
                  ;; exchange pointers
                  (set! tpart part)
                  (set! part part2)
                  (set! part2 tpart)
                  (dtimer dtime itime 1)
                  (set! time (convert (pref dtime 0)))
                  (set! tsort (+ tsort time))
                  ;; (println "tsort:" tsort)
                  )))
        (if (= ntime 0)
            (let ((field_energy (pref we 0))
                  (kinetic_energy (pref wke 0))
                  (total_energy (+ field_energy kinetic_energy)))
              (println "\nInitial Energies:\n")
              (printf "field_energy:    %g\n" (convert field_energy double))
              (printf "kinetic_energy:  %g\n" (convert kinetic_energy double))
              (printf "total_energy:    %g\n" (convert total_energy double)))))
      ;; end main iteration loop
      ;; print results
      (println "ntime:" ntime)
      (let ((field_energy (pref we 0))
            (kinetic_energy (pref wke 0))
            (total_energy (+ field_energy kinetic_energy)))
        (println "\nFinal Energies:\n")
        (printf "field_energy:    %g\n" (convert field_energy double))
        (printf "kinetic_energy:  %g\n" (convert kinetic_energy double))
        (printf "total_energy:    %g\n\n" (convert total_energy double)))
      (println "deposit time =" tdpost)
      (println "guard time =" tguard)
      (println "solver time =" tfield)
      (println "fft time =" tfft)
      (println "push time =" tpush)
      (println "sort time =" tsort)
      (set! tfield (+ tfield tguard tfft))
      (println "total solver time =" tfield)
      (set! time (+ tdpost tpush tsort))
      (println "total particle time =" time)
      (set! wt (+ time tfield))
      (println "total time =" wt)
      (println)
      (set! wt (/ 1000000000. (convert (* nloop np))))
      (println "Push Time (nsec) =" (* tpush wt))
      (println "Deposit Time (nsec) =" (* tdpost wt))
      (println "Sort Time (nsec) =" (* tsort wt))
      (println "Total Particle Time (nsec) =" (* time wt) "\n")
      
      void)))

;; (xtmain)

