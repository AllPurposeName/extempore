;; to compile math lib:
;; (sys:load "libs/precompile-lib.xtm")
;; (sys:precomp:compile-xtm-file "libs/core/math.xtm" #t #t)

(sys:load "libs/core/math.xtm")

;; set up the current dylib name and path (for precompilation)
(sys:precomp:set-dylib-name-info
 'libcpic2
 (cond ((string=? (sys:platform) "OSX")
        "/Users/ben/Code/src/pic2/libcpic2.dylib")
       ((string=? (sys:platform) "Linux")
        "libcpic2.so")
       ((string=? (sys:platform) "Windows")
        "libcpic2.dll")
       (else
        (begin (print-with-colors 'red 'default #f (print "Error"))
               (print ": unsupported platform ")
               (print-with-colors 'yellow 'default #f (print (sys:platform)))))))

;; load the dylib
(define libcpic2
  (sys:load-dylib (cdr *sys:precomp:current-load-dylib-info*)))

(bind-type timeval <i64,i64>) ;; <time_t,suseconds_t>

;; from pic2.h

(bind-lib libcpic2 dtimer [void,double*,timeval*,i32]*)
(bind-lib libcpic2 main [i32,i32,i8**]*)

;; from push2.h

(bind-lib libcpic2 ranorm [double]*)
(bind-lib libcpic2 randum [double]*)
(bind-lib libcpic2 cdistr2 [void,float*,float,float,float,float,i32,i32,i32,i32,i32,i32,i32]*)
(bind-lib libcpic2 cgpush2l [void,float*,float*,float,float,float*,i32,i32,i32,i32,i32,i32,i32]*)
(bind-lib libcpic2 cdgpush2l [void,double*,double*,double,double,double*,i32,i32,i32,i32,i32,i32,i32]*)
(bind-lib libcpic2 cgpost2l [void,float*,float*,float,i32,i32,i32,i32]*)
(bind-lib libcpic2 cdsortp2yl [void,float*,float*,i32*,i32,i32,i32]*)
(bind-lib libcpic2 ccguard2l [void,float*,i32,i32,i32,i32]*)
(bind-lib libcpic2 caguard2l [void,float*,i32,i32,i32,i32]*)
(bind-lib libcpic2 cpois22 [void,cpxf*,cpxf*,i32,cpxf*,float,float,float,float*,i32,i32,i32,i32,i32,i32]*)
(bind-lib libcpic2 cwfft2rinit [void,i32*,cpxf*,i32,i32,i32,i32]*)
(bind-lib libcpic2 cfft2rxx [void,cpxf*,i32,i32*,cpxf*,i32,i32,i32,i32,i32,i32,i32,i32]*)
(bind-lib libcpic2 cfft2rxy [void,cpxf*,i32,i32*,cpxf*,i32,i32,i32,i32,i32,i32,i32,i32]*)
(bind-lib libcpic2 cfft2r2x [void,cpxf*,i32,i32*,cpxf*,i32,i32,i32,i32,i32,i32,i32,i32]*)
(bind-lib libcpic2 cfft2r2y [void,cpxf*,i32,i32*,cpxf*,i32,i32,i32,i32,i32,i32,i32,i32]*)
(bind-lib libcpic2 cwfft2rx [void,cpxf*,i32,i32*,cpxf*,i32,i32,i32,i32,i32,i32]*)
(bind-lib libcpic2 cwfft2r2 [void,cpxf*,i32,i32*,cpxf*,i32,i32,i32,i32,i32,i32]*)

;; main

(bind-func run_main
  (lambda ()
    (main 0 null)))

;; (run_main)

;; some test functions

(bind-func xtmain 500000000
  (let ( ;; parameters
        (indx:i32 9)
        (indy:i32 9)
        (npx:i32 3072)
        (npy:i32 3072)
        (ndim:i32 2)
        (tend:float 10.)
        (dt:float .1)
        (qme:float -1.)
        (vtx:float 1.)
        (vty:float 1.)
        (vx0:float 0.)
        (vy0:float 0.)
        (ax:float .912871)
        (ay:float .912871)
        (idimp:i32 4)
        (ipbc:i32 1)
        (sortime:i32 50)
        (wke:float* (zalloc))
        (we:float* (zalloc))
        (wt:float 0.)
        ;; scalars for standard code
        (j:i32 0)
        (np:i32 (* npx npy))
        (nx:i32 (<< 1:i32 indx)) ;; only works for indx < 2^31
        (ny:i32 (<< 1:i32 indy)) ;; only works for indx < 2^31
        (nxh:i32 (/ nx 2))
        (nyh:i32 (/ ny 2))
        (nxe:i32 (+ nx 2))
        (nye:i32 (+ ny 1))
        (nxeh:i32 (/ nxe 2))
        (nxyh:i32 (/ (max nx ny) 2))
        (nxhy:i32 (max nxh ny))
        (ny1:i32 (+ ny 1))
        (ntime:i32 0)
        (nloop:i32 (convert (+ (/ tend dt) .0001)))
        (isign:i32 0)
        (qbme:float qme)
        (affp:float (/ (convert (* nx ny) float)
                       (convert np float)))
        ;; allocate arrays for standard code
        (part:float* (zalloc (* idimp np)))
        (part2:float* (zalloc (* idimp np)))
        (tpart:float* null)
        (qe:float* (zalloc (* nxe nye)))
        (fxye:float* (zalloc (* ndim nxe nye)))
        (ffc:cpxf* (zalloc (* nxh nyh)))
        (mixup:i32* (zalloc nxhy))
        (sct:cpxf* (zalloc nxyh))
        (npicy:i32* (zalloc ny1))
        ;; timing data
        (time:float 0.)
        (itime:timeval* (zalloc))
        (tdpost:float 0.)
        (tguard:float 0.)
        (tfft:float 0.)
        (tfield:float 0.)
        (tpush:float 0.)
        (tsort:float 0.)
        (dtime:double* (zalloc))
        )
    (lambda ()
      ;; nloop = number of time steps in simulation
      ;; ntime = current time step
      ;; prepare FFT tables
      (cwfft2rinit mixup sct indx indy nxhy nxyh)
      ;; calculate form factors
      (set! isign 0)
      (cpois22 (cast qe cpxf*)
               (cast fxye cpxf*)
               isign ffc ax ay affp we nx ny nxeh nye nxh nyh)
      ;; initialize electrons
      (cdistr2 part vtx vty vx0 vy0 npx npy idimp np nx ny ipbc)
      ;; main iteration loop
      (println "\nStart iteration:" nloop "loops\n")
      (dotimes (ntime nloop)
        ;; check the mixup array
        ;; deposit charge with standard procedure: updates qe
        (if (= (% ntime 10) 0)
            (println "ntime:" ntime))
        (dtimer dtime itime -1)
        (dotimes (j (* nxe nye))
          (pset! qe j 0.))
        (cgpost2l part qe qme np idimp nxe nye)
        (dtimer dtime itime 1)
        (set! time (convert (pref dtime 0)))
        (set! tdpost (+ tdpost time))
        ;; (println "tdpost:" tdpost)
        ;; add guard cells with standard procedure: updates qe
        (dtimer dtime itime -1)
        (caguard2l qe nx ny nxe nye)
        (dtimer dtime itime 1)
        (set! time (convert (pref dtime 0)))
        (set! tguard (+ tguard time))
        ;; (println "tguard:" tguard)
        ;; transform charge to fourier space with standard procedure:
        ;; updates qe
        (dtimer dtime itime -1)
        (set! isign -1)
        (cwfft2rx (cast qe cpxf*) isign mixup sct indx indy nxeh nye nxhy nxyh)
        (dtimer dtime itime 1)
        (set! time (convert (pref dtime 0)))
        (set! tfft (+ tfft time))
        ;; (println "tfft:" tfft)
        ;; calculate force/charge in fourier space with standard
        ;; procedure: updates fxye
        (dtimer dtime itime -1)
        (set! isign -1)
        (cpois22 (cast qe cpxf*)
                 (cast fxye cpxf*)
                 isign ffc ax ay affp we nx ny nxeh nye nxh nyh)
        (dtimer dtime itime 1)
        (set! time (convert (pref dtime 0)))
        (set! tfield (+ tfield time))
        ;; (println "tfield:" tfield)
        ;; transform force to real space with standard procedure: updates fxye 
        (dtimer dtime itime -1)
        (set! isign 1)
        (cwfft2r2 (cast fxye cpxf*) isign mixup sct indx indy nxeh nye nxhy nxyh)
        (dtimer dtime itime 1)
        (set! time (convert (pref dtime 0)))
        (set! tfft (+ tfft time))
        ;; (println "tfft:" tfft)
        ;; copy guard cells with standard procedure: updates fxye 
        (dtimer dtime itime -1)
        (ccguard2l fxye nx ny nxe nye)
        (dtimer dtime itime 1)
        (set! time (convert (pref dtime 0)))
        (set! tguard (+ tguard time))
        ;; (println "tguard:" tguard)
        ;; push particles with standard procedure: updates part, wke 
        (pset! wke 0 0.)
        (dtimer dtime itime -1)
        (cgpush2l part fxye qbme dt wke idimp np nx ny nxe nye ipbc)
        (dtimer dtime itime 1)
        (set! time (convert (pref dtime 0)))
        (set! tpush (+ tpush time))
        ;; (println "tpush:" tpush)
        ;; sort particles by cell for standard procedure 
        (if (> sortime 0)
            (if (= (% ntime sortime) 0)
                (begin
                  (dtimer dtime itime -1)
                  (cdsortp2yl part part2 npicy idimp np ny1)
                  ;; exchange pointers
                  (set! tpart part)
                  (set! part part2)
                  (set! part2 tpart)
                  (dtimer dtime itime 1)
                  (set! time (convert (pref dtime 0)))
                  (set! tsort (+ tsort time))
                  ;; (println "tsort:" tsort)
                  )))
        (if (= ntime 0)
            (let ((field_energy (pref we 0))
                  (kinetic_energy (pref wke 0))
                  (total_energy (+ field_energy kinetic_energy)))
              (println "\nInitial Energies:\n")
              (printf "field_energy:    %g\n" (convert field_energy double))
              (printf "kinetic_energy:  %g\n" (convert kinetic_energy double))
              (printf "total_energy:    %g\n" (convert total_energy double)))))
      ;; end main iteration loop
      ;; print results
      (println "ntime:" ntime)
      (let ((field_energy (pref we 0))
            (kinetic_energy (pref wke 0))
            (total_energy (+ field_energy kinetic_energy)))
        (println "\nFinal Energies:\n")
        (printf "field_energy:    %g\n" (convert field_energy double))
        (printf "kinetic_energy:  %g\n" (convert kinetic_energy double))
        (printf "total_energy:    %g\n\n" (convert total_energy double)))
      (println "deposit time =" tdpost)
      (println "guard time =" tguard)
      (println "solver time =" tfield)
      (println "fft time =" tfft)
      (println "push time =" tpush)
      (println "sort time =" tsort)
      (set! tfield (+ tfield tguard tfft))
      (println "total solver time =" tfield)
      (set! time (+ tdpost tpush tsort))
      (println "total particle time =" time)
      (set! wt (+ time tfield))
      (println "total time =" wt)
      (println)
      (set! wt (/ 1000000000. (convert (* nloop np))))
      (println "Push Time (nsec) =" (* tpush wt))
      (println "Deposit Time (nsec) =" (* tdpost wt))
      (println "Sort Time (nsec) =" (* tsort wt))
      (println "Total Particle Time (nsec) =" (* time wt) "\n")
      
      void)))

;; (xtmain)

;; visualisation code


;; vert shader
(define particles-vert
"// VERTEX SHADER
// GLSL 1.2 compatible

//varying vec2 TexCoord;

attribute vec2 particle_vertex;
// attribute vec4 myColour;
attribute float particle_charge;
attribute vec2 particle_velocity;

void main() {
   gl_PointSize = 100.0;
   gl_FrontColor = vec4(1.0,1.0,1.0,1.0);
   gl_Position = gl_ProjectionMatrix * gl_ModelViewMatrix * vec4(particle_vertex.xy,0.0,1.0);
   //TexCoord = gl_MultiTexCoord0.st;
}")

(define particles-frag
"//  FRAGMENT SHADER
// #version 330

#version 120

#extension GL_ARB_texture_rectangle : disable

uniform sampler2D tex1;

//varying vec2 TexCoord;

void main() {
   gl_FragColor = texture2D(tex1,gl_PointCoord)*gl_Color;
   //gl_FragColor = gl_Color;
}")

(define width 1440.0)
(define height 900.0)
(bind-val width float 1440.0)
(bind-val height float 900.0)
(define fullscreen #t)

(define *gl-ctx* (gl:make-ctx ":0" fullscreen 0. 0. width height))

(bind-val texture1 i32 0)

(bind-func load-tex
  (lambda (tex_path id)
    (let ((t (gl_load_image tex_path id)))      
      (set! texture1 t)
      (printf "texture: %d\n" texture1)
      void)))

;; 0 meaning load texture into new id
(load-tex "assets/images/star.png" 0)

(bind-val particle_shader i32 0)

(bind-func update_shader_program
  (lambda (vert:i8* frag:i8*)
    (set! particle_shader (create_shader vert frag))))

(update_shader_program particles-vert particles-frag)

(bind-func update_particles
  (lambda (particles:float* nparticles:i32)
    (let ((dt 0.01))
      (doloop (i nparticles)
        ;; update x
        (pset! particles (* i 4) (+ (pref particles (* i 4))
                                    (* (pref particles (+ (* i 4) 2)) dt)))
        (pset! particles (+ (* i 4) 1) (+ (pref particles (+ (* i 4) 1))
                                          (* (pref particles (+ (* i 4) 3)) dt)))))))

;; draw system
(bind-func draw_particles
  (let ((nparticles 4)
        (particles:float* (zalloc (* nparticles 4)))
        (vertex_location:i32 -1)
        (velocity_location:i32 -1)
        (vbo (create_vbo (* nparticles (* nparticles 16))
                           (cast particles i8*)
                           GL_STREAM_DRAW)))
    (pfill! particles
            0. 0. .1 .1
            0. .1 0. .1
            0. .1 0. 0.
            .1 0. 0. .1)
    (lambda ()
      (let ((i 0)
            ;; (size 1)
            (texid texture1)
            ;; (data (tref psys 2))
            (cnt 0))
        (if (= vertex_location -1)
            (begin
              (set! vertex_location (glGetAttribLocation particle_shader "particle_vertex"))
              (set! velocity_location (glGetAttribLocation particle_shader "particle_velocity"))))
        ;; update the positions
        (update_particles particles nparticles)
        ;; gl setup
        (glEnable GL_BLEND)
        (glDisable GL_DEPTH_TEST)
        (glDepthMask GL_FALSE)
        (glBlendFunc GL_SRC_ALPHA GL_ONE)
        (glEnable GL_POINT_SPRITE)
        (glEnable GL_VERTEX_PROGRAM_POINT_SIZE)
        ;; shader program
        (glUseProgram particle_shader)
        ;; (printf "shader errors: %d\n" (glGetError))
        ;; vbo stuff
        (glBindBuffer GL_ARRAY_BUFFER (tref vbo 0))
        (glBufferSubData GL_ARRAY_BUFFER 0 (tref vbo 1) (tref vbo 2))
        (glEnableVertexAttribArray vertex_location)
        (glVertexAttribPointer vertex_location 2 GL_FLOAT GL_FALSE 16 null) ;(pref-ptr (cast null i8*) 0))
        ;; (glEnableVertexAttribArray my_colour)
        ;; (glVertexAttribPointer my_colour 4 GL_FLOAT GL_FALSE 16 (pref-ptr (cast null i8*) 8))
        ;; (glEnableVertexAttribArray my_size)
        ;; (glVertexAttribPointer my_size 1 GL_FLOAT GL_FALSE 16 (pref-ptr (cast null i8*) 24))
        (glEnableVertexAttribArray velocity_location)
        (glVertexAttribPointer velocity_location 2 GL_FLOAT GL_FALSE 16 (pref-ptr (cast null i8*) 8))
        ;; (printf "vbo errors: %s\n" (gluErrorString (glGetError)))
        ;; texture setup
        (glActiveTexture GL_TEXTURE0)
        (glDisable GL_TEXTURE_RECTANGLE_ARB)
        (glEnable GL_TEXTURE_2D)
        (glBindTexture GL_TEXTURE_2D texid)
        (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_WRAP_S GL_CLAMP_TO_EDGE)
        (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_WRAP_T GL_CLAMP_TO_EDGE)
        (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_MAG_FILTER GL_LINEAR)
        (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_MIN_FILTER GL_LINEAR)
        (glTexEnvi GL_POINT_SPRITE GL_COORD_REPLACE 1)
        (glUniform1i (glGetUniformLocation particle_shader "tex1") 0)
        ;; draw the points
        (glDrawArrays GL_POINTS 0 nparticles)
        ;; disable texture
        (glActiveTexture GL_TEXTURE0)
        (glBindTexture GL_TEXTURE_2D 0)
        (glDisable GL_TEXTURE_2D)
        ;; disable attribs
        (glDisableVertexAttribArray vertex_location)
        ;; (glDisableVertexAttribArray my_colour)
        ;; (glDisableVertexAttribArray my_size)
        (glDisableVertexAttribArray velocity_location)
        ;; unbind the buffer
        (glBindBuffer GL_ARRAY_BUFFER 0)
        (glDisable GL_VERTEX_PROGRAM_POINT_SIZE)
        (glDisable GL_POINT_SPRITE)
        ;; un-set the GL stuff
        (glDisable GL_BLEND)
        (glEnable GL_DEPTH_TEST)
        (glDepthMask GL_TRUE)
        ;; print errors (if there are any)
        (let ((glErr (glGetError)))
          (if (<>  glErr GL_NO_ERROR)
              (printf "final errors: %s\n" (gluErrorString glErr))))
        1))))

;; gl-code 	   
(bind-func gl_draw_frame
  (lambda (time:double)
    (glClearColor 0.0 0.0 0.0 1.0)
    (glClear (+ GL_DEPTH_BUFFER_BIT GL_COLOR_BUFFER_BIT))
    (glLoadIdentity)
    (draw_particles)
    void))

(define draw-loop
  (lambda (time delta-t)
    (gl_draw_frame time)
    (gl:swap-buffers *gl-ctx*)
    (callback (+ time (* *second* delta-t) 0.5)
              'draw-loop
              (+ time (* *second* delta-t)) 
              delta-t)))

(draw-loop (now) 1/30)
