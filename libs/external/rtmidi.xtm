;;; rtmidi.xtm -- MIDI support for Extempore

;; Author: Ben Swift
;; Keywords: extempore
;; Required dylibs: rtmidi

;;; Commentary:

;; The rtmidi library is a cross-platform MIDI library by Gary P.
;; Scavone.

;; Source and documentation for the rtmidi library is available at
;; http://music.mcgill.ca/~gary/rtmidi/

;; Because rtmidi is a C++ library (and Extempore can only bind C libs
;; at this stage), there is a project called CRtMidi which wraps
;; (part) of the rtmidi API in a C interface. This interface is then
;; bound dynamically in xtlang---that's what this file is for.

;; to compile:

;; 1. get the 'Extempore-ified' fork of RTMidi from
;;    https://github.com/benswift/rtmidi-c-api
;; 2. build and isntall the c-API-wrapped shared lib with ./make-cshlib

;;; Code:

(sys:load-preload-check 'librtmidi)
(define *xtmlib-librtmidi-loaded* #f)
(print "Loading librtmidi library...")

(define librtmidi
  (let ((platform (sys:platform)))
    (cond ((string=? platform "Linux") (sys:load-dylib "librtmidi.so"))
          ((string=? platform "Windows") (sys:load-dylib "librtmidi.dll"))
          ((string=? platform "OSX") (sys:load-dylib "librtmidi.dylib"))
          (else (print "Unknown platform: " platform)))))

(if (not librtmidi)
    (print-error "Could not load librtmidi dynamic library"))

(bind-val RTMIDI_NOERROR i32 0)
(bind-val RTMIDI_ERROR i32 1)

(define *midi-note-off* 8)              ;; key, velocity
(define *midi-note-on* 9)               ;; key, velocity
(define *midi-aftertouch* 10)            ;; key, touch
(define *midi-continuous-controller* 11) ;; controller, value
(define *midi-patch-change* 12)           ;;
(define *midi-channel-pressure* 13)      ;;
(define *midi-pitch-bend* 14)            ;; lsb (7 bits), msb (7 bits)

(bind-val MIDI_NOTE_OFF i8 *midi-note-off*)
(bind-val MIDI_NOTE_ON i8 *midi-note-on*)
(bind-val MIDI_AFTERTOUCH i8 *midi-aftertouch*)
(bind-val MIDI_CONTINUOUS_CONTROLLER i8 *midi-continuous-controller*)
(bind-val MIDI_PATCH_CHANGE i8 *midi-patch-change*)
(bind-val MIDI_CHANNEL_PRESSURE i8 *midi-channel-pressure*)
(bind-val MIDI_PITCH_BEND i8 *midi-pitch-bend*)

;; API selection enums

(bind-val UNSPECIFIED i32 0) ;; try to auto-detect the platform
(bind-val MACOSX_CORE i32 1)
(bind-val LINUX_ALSA  i32 2)
(bind-val UNIX_JACK   i32 3)
(bind-val WINDOWS_MM  i32 4)
(bind-val WINDOWS_KS  i32 5)
(bind-val RTMIDI_DUMMY i32 6)

(bind-type midi_in_device <i8*>)
(bind-type midi_out_device <i8*>)
(bind-alias midi_callback [i8*,double,i64,i8*]*)

;; midi input

(bind-lib librtmidi newMidiInDevice [i32,midi_in_device*,i32,i8*]*)
(bind-lib librtmidi deleteMidiInDevice [i32,midi_in_device*]*)

(bind-lib librtmidi getInCurrentApi [i64,midi_in_device*]*)
(bind-lib librtmidi getInPortCount [i64,midi_in_device*]*)
(bind-lib librtmidi getInPortName [i8*,midi_in_device*,i64]*)

(bind-lib librtmidi openInPort [i32,midi_in_device*,i64,i8*]*)
(bind-lib librtmidi openInVirtualPort [i32,midi_in_device*,i8*]*)
(bind-lib librtmidi closeInPort [i32,midi_in_device*]*)

(bind-lib librtmidi setCallback [i32,midi_in_device*,i8*]*)
(bind-lib librtmidi cancelCallback [i32,midi_in_device*]*)

;; midi output

(bind-lib librtmidi newMidiOutDevice [i32,midi_out_device*,i32,i8*]*)
(bind-lib librtmidi deleteMidiOutDevice [i32,midi_out_device*]*)

(bind-lib librtmidi getOutCurrentApi [i64,midi_out_device*]*)
(bind-lib librtmidi getOutPortCount [i64,midi_out_device*]*)
(bind-lib librtmidi getOutPortName [i8*,midi_out_device*,i64]*)

(bind-lib librtmidi openOutPort [i32,midi_out_device*,i64,i8*]*)
(bind-lib librtmidi openOutVirtualPort [i32,midi_out_device*,i8*]*)
(bind-lib librtmidi closeOutPort [i32,midi_out_device*]*)
(bind-lib librtmidi sendMessage [i32,midi_out_device*,i64,i8*]*)

;; poly'ing

;; (bind-poly newMidiDevice newMidiInDevice)
;; (bind-poly newMidiDevice newMidiOutDevice)
;; (bind-poly deleteMidiDevice deleteMidiInDevice)
;; (bind-poly deleteMidiDevice deleteMidiOutDevice)
;; (bind-poly getCurrentApi getInCurrentApi)
;; (bind-poly getCurrentApi getOutCurrentApi)
;; (bind-poly getPortCount getInPortCount)
;; (bind-poly getPortCount getOutPortCount)
;; (bind-poly getPortName getInPortName)
;; (bind-poly getPortName getOutPortName)
;; (bind-poly openPort openInPort)
;; (bind-poly openPort openOutPort)
;; (bind-poly openVirtualPort openInVirtualPort)
;; (bind-poly openVirtualPort openOutVirtualPort)
;; (bind-poly closePort closeInPort)
;; (bind-poly closePort closeOutPort)

;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; connection management ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define *midi-max-devices* 32)
(bind-val MIDI_MAX_DEVICES i64 *midi-max-devices*)
;; midi devices are stored in the global arrays
;; MIDI_{IN,OUT}DEVICE_ARRAY and accessed through their (integer)
;; index
(bind-val MIDI_INDEVICE_ARRAY midi_in_device** (* (sys:pointer-size) *midi-max-devices*))
(bind-val MIDI_OUTDEVICE_ARRAY midi_out_device** (* (sys:pointer-size) *midi-max-devices*))

;; (define MIDI_INDEVICE_ARRAY (sys:make-cptr (* (sys:pointer-size) *midi-max-devices*)))
;; (bind-scm MIDI_INDEVICE_ARRAY midi_in_device** MIDI_INDEVICE_ARRAY)

(bind-func midi_indevice_from_id
  (lambda (device_id)
    (let ((device (pref MIDI_INDEVICE_ARRAY device_id)))
      (if (null? device)
          (begin (printf "Error: no MIDI input device at id %lld\n" device_id)
                 null)
          device))))

(bind-func midi_outdevice_from_id
  (lambda (device_id)
    (let ((device (pref MIDI_OUTDEVICE_ARRAY device_id)))
      (if (null? device)
          (begin (printf "Error: no MIDI output device at id %lld\n" device_id)
                 null)
          device))))

(bind-func midi_next_available_indevice_id
  (lambda ()
    (let ((i 0)
          (available_id -1))
      (dotimes (i MIDI_MAX_DEVICES)
        (if (and (null? (pref MIDI_INDEVICE_ARRAY i))
                 (= available_id -1))
            (set! available_id i)))
      available_id)))

(bind-func midi_next_available_outdevice_id
  (lambda ()
    (let ((i 0)
          (available_id -1))
      (dotimes (i MIDI_MAX_DEVICES)
        (if (and (null? (pref MIDI_OUTDEVICE_ARRAY i))
                 (= available_id -1))
            (set! available_id i)))
      available_id)))

;; creating/destroying devices

(bind-func midi_new_indevice
  (lambda ()
    (let ((device:midi_in_device* (halloc))
          (device_id (midi_next_available_indevice_id)))
      (if (< device_id 0)
          (begin (printf "Error: no available MIDI device IDs\n")
                 -1)
          (begin (newMidiInDevice device UNSPECIFIED "Extempore Midi Input Device")
                 (pset! MIDI_INDEVICE_ARRAY device_id device)
                 device_id)))))

(bind-func midi_new_outdevice
  (lambda ()
    (let ((device:midi_out_device* (halloc))
          (device_id (midi_next_available_outdevice_id)))
      (if (< device_id 0)
          (begin (printf "Error: no available MIDI device IDs\n")
                 -1)
          (begin (newMidiOutDevice device UNSPECIFIED "Extempore Midi Output Device")
                 (pset! MIDI_OUTDEVICE_ARRAY device_id device)
                 device_id)))))

(bind-func midi_delete_indevice
  (lambda (device_id)
    (let ((device (midi_indevice_from_id device_id)))
      (if (not (null? device))
          (begin
            (deleteMidiInDevice device)
            (pset! MIDI_INDEVICE_ARRAY device_id null)
            (free device)))
      void)))

(bind-func midi_delete_outdevice
  (lambda (device_id)
    (let ((device (midi_outdevice_from_id device_id)))
      (if (not (null? device))
          (begin
            (deleteMidiOutDevice device)
            (pset! MIDI_OUTDEVICE_ARRAY device_id null)
            (free device)))
      void)))

;; opening/closing ports

(bind-func midi_open_inport
  (lambda (device_id port)
    (let ((device (midi_indevice_from_id device_id)))
      (if (not (null? device))
          (openInPort device port "Extempore Input Port"))
      void)))

(bind-func midi_open_virtual_inport
  (lambda (device_id)
    (let ((device (midi_indevice_from_id device_id)))
      (if (not (null? device))
          (openInVirtualPort device "Extempore Virtual Input Port"))
      void)))

(bind-func midi_open_outport
  (lambda (device_id port)
    (let ((device (midi_outdevice_from_id device_id)))
      (if (not (null? device))
          (openOutPort device port "Extempore Output Port"))
      void)))

(bind-func midi_open_virtual_outport
  (lambda (device_id)
    (let ((device (midi_outdevice_from_id device_id)))
      (if (not (null? device))
          (openOutVirtualPort device "Extempore Virtual Output Port"))
      void)))

(bind-func midi_close_inport
  (lambda (device_id)
    (let ((device (midi_indevice_from_id device_id)))
      (if (not (null? device))
          (closeInPort device))
      void)))

(bind-func midi_close_outport
  (lambda (device_id)
    (let ((device (midi_outdevice_from_id device_id)))
      (if (not (null? device))
          (closeOutPort device))
      void)))

(bind-func extempore_midi_callback
  (lambda (type:i64 chan:i64 a:i64 b:i64)
    (printf "MIDI recieved: type:%3lld  chan:%3lld  a:%3lld  b:%3lld\n" type chan a b)
    (printf "To handle this message, re-define \'extempore_midi_callback\'\n")))

(bind-func midi_message_parser
  (let ((type:i8 0) (chan:i8 0) (a:i8 0) (b:i8 0))
    (lambda (time:double len:i64 msg:i8*)
      (set! type (>> (pref msg 0) 4))
      (set! chan (& (pref msg 0) 15))
      (set! a (pref msg 1))
      (set! b (pref msg 2))
      (extempore_midi_callback (i8toi64 type) (i8toi64 chan) (i8toi64 a) (i8toi64 b))
      void)))

(bind-func midi_set_callback
  "Register a midi sink/source"
  (lambda (device_id callback_name:i8*)
    (let ((len (strlen callback_name))
          (callback_name_native:i8* (salloc (+ len 8)))
          (device (midi_indevice_from_id device_id)))
      (if (not (null? device))
          (begin (strncpy callback_name_native callback_name (+ 1 len))
                 (strncpy (pref-ptr callback_name_native len) "_native" 8)
                 (printf "\nregistering %s as callback function for MIDI source %lld\n\n" callback_name)
                 (setCallback device (llvm_get_function_ptr callback_name_native))))
      void)))

(bind-func midi_remove_callback
  "Register a midi sink/source"
  (lambda (device_id)
    (let ((device (midi_indevice_from_id device_id)))
      (if (not (null? device))
          (begin (printf "Removing midi callback.\n")
                 (cancelCallback device)))
      void)))

;;  query input/output ports

;; todo: rename these to sources/destinations
(bind-func midi_print_source_ports
  (lambda (device_id)
    (let ((device (pref MIDI_INDEVICE_ARRAY device_id)))
      (if (not (null? device))    
          (let ((num_ports (getInPortCount device))
                (i:i64 0))
            (printf "--------------\nSource device %lld\n--------------\nPorts:\n" device_id)
            (if (= num_ports 0)
                (begin (printf "No input ports.\n") void)
                (dotimes (i num_ports)
                  (printf "[%lld] %s\n" i (getInPortName device i))))
            (printf "\n")))
      void)))

(bind-func midi_print_destination_ports
  (lambda (device_id)
    (let ((device (pref MIDI_OUTDEVICE_ARRAY device_id)))
      (if (not (null? device))
          (let ((num_ports (getOutPortCount device))
                (i:i64 0))
            (printf "---------------\nDestination device %lld\n---------------\nPorts:\n" device_id)
            (if (= num_ports 0)
                (begin (printf "No ouput ports.\n") void)
                (dotimes (i num_ports)
                  (printf "[%lld] %s\n" i (getOutPortName device i))))
            (printf "\n")))
      void)))

;; (bind-poly midi_print_ports midi_print_isource_)
;; (bind-poly midi_print_ports midi_print_destination_ports)

(bind-func midi_print_sources
  (lambda ()
    (let ((i 0))
      (dotimes (i MIDI_MAX_DEVICES)
        (let ((device (pref MIDI_INDEVICE_ARRAY i)))
          (if (not (null? device))
              (midi_print_source_ports i))))
      void)))

(bind-func midi_print_destinations
  (lambda ()
    (let ((i 0))
      (dotimes (i MIDI_MAX_DEVICES)
        (let ((device (pref MIDI_OUTDEVICE_ARRAY i)))
          (if (not (null? device))
              (midi_print_destination_ports i))))
      void)))

;; default midi source/destination device indexes
;; source = midi_in_device, destination = midi_out_device
(define *extempore-midi-source* #f)
(define *extempore-midi-destination* #f)

(define midi-register-events
  (lambda ()
    (set! *extempore-midi-source* (midi_new_indevice))
    (midi_open_virtual_inport *extempore-midi-source*)
    (midi_set_callback *extempore-midi-source* "midi_message_parser")
    (set! *extempore-midi-destination* (midi_new_outdevice))
    (midi_open_virtual_outport *extempore-midi-destination*)
    (midi_print_destinations)))

(define midi-deregister-events
  (lambda ()
    (midi_delete_indevice *extempore-midi-source*)
    (set! *extempore-midi-source* #f)
    (midi_delete_outdevice *extempore-midi-destination*)
    (set! *extempore-midi-destination* #f)
    (print "Deregstered Extempore MIDI input/output devices.\n")))

;; send midi message

(bind-func midi_send_message
  (lambda (device_id type chan a b)
    (let ((device (pref MIDI_OUTDEVICE_ARRAY device_id)))
      (if (not (null? device))
          (let ((msg:i8* (salloc 3)))
            (pfill! msg (+ (<< type 4) chan) a b)
            (sendMessage device 3 msg)))
      void)))

;; test sending & recieving midi
;; (midi_send_message (midi_new_outdevice) *midi-note-on* 0 60 80 0)
;; (midi_send_message (midi_new_outdevice) *midi-note-off* 0 66 80 0)

(define midi-play-note
  (lambda (time device-id pitch velocity duration channel)
    (callback time 'midi_send_message device-id *midi-note-on* channel pitch velocity)
    (callback (+ time duration) 'midi_send_message device-id *midi-note-off* channel pitch velocity)))

;; a midi-specific play macro
(macro (mplay args)
  (if (symbol? (cadr args))
      `(midi-play-note (*metro* beat)
                       (real->integer ,(cadr args))
                       (real->integer ,(caddr args))
                       (real->integer ,(cadddr args))
                       (*metro* 'dur ,(car (cddddr args)))
                       0)
      `(midi-play-note (*metro* (+ beat ,(cadr args)))
                       (real->integer ,(caddr args))
                       (real->integer ,(cadddr args))
                       (real->integer ,(car (cddddr args)))
                       (*metro* 'dur ,(cadr (cddddr args)))
                       0)))

(define *xtmlib-librtmidi-loaded* #t)
(print "done.\n")
