;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  MATH Library
;;


;;;;;;;;;; MATRIX ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; matrix functions
;;
;; there are obviously faster options (such as linking to BLAS or
;; LAPACK or the like), but these ones are nice if you want to keep
;; everything in xtlang.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; 'pretty' print matrix (doubles)
(bind-func mprintd
  (lambda (m:double* r:i64 c:i64)
    (let ((i 0) (j 0))
      (dotimes (i r)
	(printf "[")
	(printf "% f" (pref m (* i c)))
	(dotimes (j (- c 1))
	  (printf ",% f" (pref m (+ 1 j (* i c)))))
	(printf "]\n")
	void))))

;; 'pretty' print matrix (floats)
(bind-func mprintf
  (lambda (m:float* r:i64 c:i64)
    (let ((i 0) (j 0))
      (dotimes (i r)
	(printf "[")
	(printf "% f" (ftod (pref m (* i c))))
	(dotimes (j (- c 1))
	  (printf ",% f" (ftod (pref m (+ 1 j (* i c))))))
	(printf "]\n")
	void))))

;; matrix multiplication (doubles)
(bind-func mmuld
  (lambda (ma:double* r1:i64 c1:i64 mb:double* r2:i64 c2:i64 mc:double*)
    (if (= c1 r2)
	(let ((r 0) (c 0) (k 0))
	  (dotimes (r r1)
	    (dotimes (c c2)
	      (pset! mc (+ c (* r c2)) 0.0)
	      (dotimes (k c1)
		(pset! mc (+ c (* r c2))
		       (+ (pref mc (+ c (* r c2)))
			  (* (pref ma (+ k (* r c1)))
			     (pref mb (+ (* k c2) c))))))))
	  mc)
	(begin (printf "bad matrix multiplication [%lld,%lld]*[%lld,%lld]\n"
		       r1 c1 r2 c2)
	       (cast null double*)))))

;; matrix multiplication (floats)
(bind-func mmulf
  (lambda (ma:float* r1:i64 c1:i64 mb:float* r2:i64 c2:i64 mc:float*)
    (if (= c1 r2)
	(let ((r 0) (c 0) (k 0))
	  (dotimes (r r1)
	    (dotimes (c c2)
	      (pset! mc (+ c (* r c2)) 0.0)
	      (dotimes (k c1)
		(pset! mc (+ c (* r c2))
		       (+ (pref mc (+ c (* r c2)))
			  (* (pref ma (+ k (* r c1)))
			     (pref mb (+ (* k c2) c))))))))
	  mc)
	(begin (printf "bad matrix multiplication [%lld,%lld]*[%lld,%lld]\n"
		       r1 c1 r2 c2)
	       (cast null float*)))))

;; matrix transposition (doubles)
(bind-func mtransd
  (lambda (ma:double* r1:i64 c1:i64 mb:double*)
    (let ((i 0) (j 0))
      (dotimes (i r1)
	(dotimes (j c1)
	  (pset! mb (+ (* j c1) i)
		 (pref ma (+ (* i c1) j)))))
      mb)))

;; matrix transposition (floats)
(bind-func mtransf
  (lambda (ma:float* r1:i64 c1:i64 mb:float*)
    (let ((i 0) (j 0))
      (dotimes (i r1)
	(dotimes (j c1)
	  (pset! mb (+ (* j c1) i)
		 (pref ma (+ (* i c1) j)))))
      mb)))

;; determinant (doubles)
;; k is for sqr matrix
(bind-func mdetrmd
  (lambda (ma:double* k:i64)
    (if (= k 1) (pref ma 0)
	(let ((det:double 0.0) (s:double 1.0)
	      (c 0) (i 0) (j 0) (m 0) (n 0)
	      (mb:double* (salloc (* k k))))
	  (dotimes (c k)
	    (set! m 0) (set! n 0)
	    (dotimes (i k)
	      (dotimes (j k)
		(pset! mb (+ (* i k) j) 0.0)
		(if (and (<> i 0) (<> j c))
		    (begin
		      (pset! mb (+ (* m (- k 1)) n)
			     (pref ma (+ (* i k) j)))
		      (if (< n (- k 2))
			  (set! n (+ n 1))
			  (begin
			    (set! n 0)
			    (set! m (+ m 1)))))
		    (begin 1))))
	    (set! det (+ det (* s (* (pref ma c)
				     (mdetrmd mb (- k 1))))))
	    (set! s (* -1.0 s)))
	  det))))

;; determinant (floats)
;; k is for sqr matrix
(bind-func mdetrmf
  (lambda (ma:float* k:i64)
    (if (= k 1) (pref ma 0)
	(let ((det:float 0.0) (s:float 1.0)
	      (c 0) (i 0) (j 0) (m 0) (n 0)
	      (mb:float* (salloc (* k k))))
	  (dotimes (c k)
	    (set! m 0) (set! n 0)
	    (dotimes (i k)
	      (dotimes (j k)
		(pset! mb (+ (* i k) j) 0.0)
		(if (and (<> i 0) (<> j c))
		    (begin
		      (pset! mb (+ (* m (- k 1)) n)
			     (pref ma (+ (* i k) j)))
		      (if (< n (- k 2))
			  (set! n (+ n 1))
			  (begin
			    (set! n 0)
			    (set! m (+ m 1)))))
		    (begin 1))))
	    (set! det (+ det (* s (* (pref ma c)
				     (mdetrmf mb (- k 1))))))
	    (set! s (* -1.0 s)))
	  det))))

;; invert matrix (doubles)
(bind-func minvd
  (lambda (ma:double* k:i64 inv:double*)
    (let ((mb:double* (salloc (* k k)))
	  (fac:double* (salloc (* k k)))
	  (d:double 0.0)
	  (i 0) (j 0) (m 0) (n 0) (q:i64 0) (p:i64 0))
      (dotimes (q k)
	(dotimes (p k)
	  (set! m 0)
	  (set! n 0)
	  (dotimes (i k)
	    (dotimes (j k)
	      (pset! mb (+ (* i k) j) 0.0)
	      (if (and (<> i q) (<> j p))
		  (begin
		    (pset! mb (+ (* m (- k 1)) n)
			   (pref ma (+ (* i k) j)))
		    (if (< n (- k 2))
			(set! n (+ n 1))
			(begin
			  (set! n 0)
			  (set! m (+ m 1)))))
		  (begin 1))))
	  (pset! fac (+ (* q k) p)
		 (* (pow -1.0 (i64tod (+ q p)))
		    (mdetrmd mb (- k 1))))))
      (dotimes (i k)
	(dotimes (j k)
	  (pset! mb (+ (* i k) j)
		 (pref fac (+ (* j k) i)))))
      (set! d (mdetrmd ma k))
      (dotimes (i k)
	(dotimes (j k)
	  (pset! inv (+ (* i k) j)
		 (/ (pref mb (+ (* i k) j)) d))))
      inv)))

;; invert matrix (floats)
(bind-func minvf
  (lambda (ma:float* k:i64 inv:float*)
    (let ((mb:float* (salloc (* k k)))
	  (fac:float* (salloc (* k k)))
	  (d:float 0.0)
	  (i 0) (j 0) (m 0) (n 0) (q:i64 0) (p:i64 0))
      (dotimes (q k)
	(dotimes (p k)
	  (set! m 0)
	  (set! n 0)
	  (dotimes (i k)
	    (dotimes (j k)
	      (pset! mb (+ (* i k) j) 0.0)
	      (if (and (<> i q) (<> j p))
		  (begin
		    (pset! mb (+ (* m (- k 1)) n)
			   (pref ma (+ (* i k) j)))
		    (if (< n (- k 2))
			(set! n (+ n 1))
			(begin
			  (set! n 0)
			  (set! m (+ m 1)))))
		  (begin 1))))
	  (pset! fac (+ (* q k) p)
		 (* (powf -1.0 (i64tof (+ q p)))
		    (mdetrmf mb (- k 1))))))

      (dotimes (i k)
	(dotimes (j k)
	  (pset! mb (+ (* i k) j)
		 (pref fac (+ (* j k) i)))))
      (set! d (mdetrmf ma k))
      (dotimes (i k)
	(dotimes (j k)
	  (pset! inv (+ (* i k) j)
		 (/ (pref mb (+ (* i k) j)) d))))
      inv)))

;; a unit test of sorts (doubles only)
(bind-func _matrix_test
  (lambda ()
    (let ((s:i64 4)
	  (ma:double* (salloc (* s s)))
	  (mb:double* (salloc (* s s)))
	  (inv:double* (salloc (* s s))))
      ;(pfill! ma 4. 1. 1. 2. 3. 1. 1. 1. 1.)
      (pfill! ma
	      4. 1. 1. 1.
	      2. 3. 1. 1.
	      1. 6. 5. 1.
	      2. 2. 3. 1.)
      (minvd ma s inv)
      (printf "\nmatrix a:      determinant:%f\n" (mdetrmd ma s))
      (mprintd ma s s)
      (printf "\ninverse of a:\n")
      (mprintd inv s s)
      (printf "\nmatrix multiplication a*inv(a):\n")
      (mmuld ma s s inv s s mb)
      (mprintd mb s s)
      (printf "\ntransposition of a:\n")
      (mtransd ma 4 4 mb)
      (mprintd mb s s)
      (printf "\n")
      void)))

;;;;;;;;;  FFT ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; You can get the source for kiss_fft from
;; http://sourceforge.net/projects/kissfft/
;;
;; The basic kiss_fft library only requires the file kiss_fft.c
;; You have to build this into a dyib yourself: on OSX this can be
;; done with:
;;
;; gcc kiss_fft.c -dynamiclib -I/usr/include/malloc -o kiss_fft.1.2.9.dylib -current_version 1.2.9
;;
;; Then, copy the dylib into somewhere on your lib path, e.g. /usr/local/lib
;;
;; After that, this should all work

(define-lib kiss_fft.1.2.9)

(if (not kiss_fft.1.2.9)
    (print-error "Could not load dynamic library"))

;; bind the required types and function signatures (see kiss_fft.h)

(bind-type kiss_fft_cpx <float,float>)
(bind-type kiss_fft_state <i32,i32,|64,i32|,|1,kiss_fft_cpx|>)
(bind-alias kiss_fft_cfg kiss_fft_state*)

(bind-lib kiss_fft.1.2.9 kiss_fft_alloc [kiss_fft_cfg,i32,i32,i8*,i64*]*)
(bind-lib kiss_fft.1.2.9 kiss_fft [i8*,kiss_fft_cfg,kiss_fft_cpx*,kiss_fft_cpx*]*)
(bind-lib kiss_fft.1.2.9 kiss_fft_stride [i8*,kiss_fft_cfg,kiss_fft_cpx*,kiss_fft_cpx*,i32]*)
(bind-lib kiss_fft.1.2.9 kiss_fft_cleanup [i8*,i8*]*)
(bind-lib kiss_fft.1.2.9 kiss_fft_next_fast_size [i32,i32]*)

;; some helpers for working with complex numbers in xtlang

(bind-type cpxd <double,double>)
(bind-type cpxf <float,float>)

(bind-func fill-complex-buffer-cpxf
  (lambda (re:float* im:float* com:cpxf* len:i64)
    (let ((i 0))
      (dotimes (i len)
	(tset! (pref-ptr com i) 0 (pref re i))
	(tset! (pref-ptr com i) 1 (pref im i))))
    void))

(bind-func fill-complex-buffer-cpxd
  (lambda (re:double* im:double* com:cpxd* len:i64)
    (let ((i 0))
      (dotimes (i len)
	(tset! (pref-ptr com i) 0 (pref re i))
	(tset! (pref-ptr com i) 1 (pref im i))))
    void))

(bind-poly fill-complex-buffer fill-complex-buffer-cpxf)
(bind-poly fill-complex-buffer fill-complex-buffer-cpxd)

(bind-func conjugate-cpxf
  (lambda (signal:cpxf* conj:cpxf* len:i64)
    (let ((i 0))
      (dotimes (i len)
	(tset! (pref-ptr conj i)
	       1
	       (* -1.0 (tref (pref-ptr signal i) 1))))
      void)))

(bind-func conjugate-cpxd
  (lambda (signal:cpxd* conj:cpxd* len:i64)
    (let ((i 0))
      (dotimes (i len)
	(tset! (pref-ptr conj i)
	       1
	       (* -1.0 (tref (pref-ptr signal i) 1))))
      void)))

(bind-poly conjugate-complex conjugate-cpxf)
(bind-poly conjugate-complex conjugate-cpxd)

(bind-func buffer-cart-to-pol-cpxf
  (lambda (cart:cpxf* pol:cpxf* len:i64)
    (let ((i 0))
      (dotimes (i len)
	(tset! (pref-ptr pol i)
	       0
	       (sqrtf (+ (powf (tref (pref-ptr cart i) 0) 2.0)
                         (powf (tref (pref-ptr cart i) 1) 2.0))))
	(tset! (pref-ptr pol i)
	       1
	       (atan2f (tref (pref-ptr cart i) 1)
                       (tref (pref-ptr cart i) 0)))))
    void))

(bind-func buffer-pol-to-cart-cpxf
  (lambda (pol:cpxf* cart:cpxf* len:i64)
    (let ((i 0))
      (dotimes (i len)
	(tset! (pref-ptr cart i)
	       0
	       (* (tref (pref-ptr pol i) 0)
		  (cosf (tref (pref-ptr pol i) 1))))
	(tset! (pref-ptr cart i)
	       1
	       (* (tref (pref-ptr pol i) 0)
		  (sinf (tref (pref-ptr pol i) 1))))))
    void))

(bind-func buffer-cart-to-pol-cpxd
  (lambda (cart:cpxd* pol:cpxd* len:i64)
    (let ((i 0))
      (dotimes (i len)
	(tset! (pref-ptr pol i)
	       0
	       (sqrt (+ (pow (tref (pref-ptr cart i) 0) 2.0)
			(pow (tref (pref-ptr cart i) 1) 2.0))))
	(tset! (pref-ptr pol i)
	       1
	       (atan2 (tref (pref-ptr cart i) 1)
		      (tref (pref-ptr cart i) 0)))))
    void))

(bind-func buffer-pol-to-cart-cpxd
  (lambda (pol:cpxd* cart:cpxd* len:i64)
    (let ((i 0))
      (dotimes (i len)
	(tset! (pref-ptr cart i)
	       0
	       (* (tref (pref-ptr pol i) 0)
		  (cos (tref (pref-ptr pol i) 1))))
	(tset! (pref-ptr cart i)
	       1
	       (* (tref (pref-ptr pol i) 0)
		  (sin (tref (pref-ptr pol i) 1))))))
    void))

(bind-poly buffer-cart-to-pol buffer-cart-to-pol-cpxf)
(bind-poly buffer-cart-to-pol buffer-cart-to-pol-cpxd)
(bind-poly buffer-pol-to-cart buffer-pol-to-cart-cpxf)
(bind-poly buffer-pol-to-cart buffer-pol-to-cart-cpxd)

(bind-func buffer-re-only-cpxf
  "get the (float) real components of the complex buffer"
  (lambda (in-cpxf:cpxf*
      out-float:float*
      len:i64)
    (let ((i 0))
      (dotimes (i len)
	(pset! out-float
	       i
	       (tref (pref-ptr in-cpxf i) 0))))
    void))

(bind-func buffer-im-only-cpxf
  "get the (float) imaginary components of the complex buffer"
  (lambda (in-cpxf:cpxf*
      out-float:float*
      len:i64)
    (let ((i 0))
      (dotimes (i len)
	(pset! out-float
	       i
	       (tref (pref-ptr in-cpxf i) 1))))
    void))

(bind-func buffer-re-only-cpxd
  "get the (double) real components of the complex buffer"
  (lambda (in-cpxd:cpxd*
      out-double:double*
      len:i64)
    (let ((i 0))
      (dotimes (i len)
	(pset! out-double
	       i
	       (tref (pref-ptr in-cpxd i) 0))))
    void))

(bind-func buffer-im-only-cpxd
  "get the (double) imaginary components of the complex buffer"
  (lambda (in-cpxd:cpxd*
      out-double:double*
      len:i64)
    (let ((i 0))
      (dotimes (i len)
	(pset! out-double
	       i
	       (tref (pref-ptr in-cpxd i) 1))))
    void))

(bind-poly buffer-re-only buffer-re-only-cpxf)
(bind-poly buffer-im-only buffer-re-only-cpxf)
(bind-poly buffer-re-only buffer-re-only-cpxd)
(bind-poly buffer-im-only buffer-re-only-cpxd)

(bind-func buffer-cpxd-to-cpxf
  (lambda (in-cpxd:cpxd*
      out-cpxf:cpxf*
      len:i64)
    (let ((i 0))
      (dotimes (i len)
        (tset! (pref-ptr out-cpxf i)
               0
               (dtof (tref (pref-ptr in-cpxd i) 0)))
        (tset! (pref-ptr out-cpxf i)
               1
               (dtof (tref (pref-ptr in-cpxd i) 1)))))
    void))

(bind-func buffer-cpxf-to-cpxd
  (lambda (in-cpxf:cpxf*
      out-cpxd:cpxd*
      len:i64)
    (let ((i 0))
      (dotimes (i len)
        (tset! (pref-ptr out-cpxd i)
               0
               (ftod (tref (pref-ptr in-cpxf i) 0)))
        (tset! (pref-ptr out-cpxd i)
               1
               (ftod (tref (pref-ptr in-cpxf i) 1)))))
    void))

;; perform the FFTs

(bind-func fft-cpxf
  "calculate the FFT of a real (float) input signal"
  (lambda (in:cpxf* out:cpxf* len:i64)
    (let ((fft-config:kiss_fft_cfg (kiss_fft_alloc
                                    (i64toi32 len)
                                    0 null null)))
      (kiss_fft fft-config
                (cast in kiss_fft_cpx*)
                (cast out kiss_fft_cpx*)))
    void))

(bind-func fft-cpxd
  "calculate the FFT of a real (double) input signal"
  (lambda (in:cpxd* out:cpxd* len:i64)
    (let ((inf:cpxf* (salloc len))
          (outf:cpxf* (salloc len)))
      (buffer-cpxd-to-cpxf in inf len)
      (fft-cpxf inf outf len)
      (buffer-cpxf-to-cpxd outf out len))
    void))

(bind-poly fft fft-cpxf)
(bind-poly fft fft-cpxd)

(bind-func inverse-fft-cpxf
  "calculate the inverse FFT of a real (float) input signal"
  (lambda (in:cpxf* out:cpxf* len:i64)
    (let ((fft-config:kiss_fft_cfg (kiss_fft_alloc
                                    (i64toi32 len)
                                    1 null null))
          (i 0))
      (kiss_fft fft-config
                (cast in kiss_fft_cpx*)
                (cast out kiss_fft_cpx*)))
    (dotimes (i len)
      (tset! (pref-ptr out i)
             0
             (/ (tref (pref-ptr out i) 0) (i64tof len)))
      (tset! (pref-ptr out i)
             1
             (/ (tref (pref-ptr out i) 1) (i64tof len))))
    void))

(bind-func inverse-fft-cpxd
  "calculate the inverse FFT of a real (double) input signal"
  (lambda (in:cpxd* out:cpxd* len:i64)
    (let ((inf:cpxf* (salloc len))
          (outf:cpxf* (salloc len)))
      (buffer-cpxd-to-cpxf in inf len)
      (inverse-fft-cpxf inf outf len)
      (buffer-cpxf-to-cpxd outf out len))
    void))

(bind-poly inverse-fft inverse-fft-cpxf)
(bind-poly inverse-fft inverse-fft-cpxd)
