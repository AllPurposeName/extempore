;;; audiobuffer.xtm -- dealing with audio files

;; Author: Ben Swift
;; Keywords: extempore
;; Required dylibs: libsndfile

;;; Commentary:

;;

;;; Code:

(sys:load "libs/aot-cache/audiobuffer.xtm" 'quiet)
(sys:load-preload-check 'audiobuffer)
(define *xtmlib-audiobuffer-loaded* #f)

(impc:aot:suppress-aot-do
 (sys:load "libs/core/std.xtm"))
(impc:aot:insert-forms
 (sys:load "libs/core/std.xtm" 'quiet))

(impc:aot:insert-header "xtmaudiobuffer")

;;;;;;;;;;;;;;;;;;;;;;
;; AudioBuffer type ;;
;;;;;;;;;;;;;;;;;;;;;;

;; 0 filepath
;; 1 playhead
;; 2 frames
;; 3 channels
;; 4 data
;; 5 samplerate
;; 6 loop start
;; 7 loop frames

(bind-type AudioBuffer <String*,i64,i64,i64,SAMPLE*,double,i64,i64>)

(bind-func AudioBuffer_a
  (lambda (frames chans)
    (let ((dat:SAMPLE* (alloc (* frames chans))))
      (AudioBuffer_z (String "") 0 frames chans dat (convert (llvm_samplerate)) 0 0))))

(bind-func AudioBuffer_b
  (lambda (frames chans samplerate)
    (let ((dat:SAMPLE* (alloc (* frames chans))))
      (AudioBuffer_z (String "") 0 frames chans dat samplerate 0 0))))

(bind-poly AudioBuffer AudioBuffer_a)
(bind-poly AudioBuffer AudioBuffer_b)

(bind-func AudioBuffer_print
  "specialised print function for AudioBuffer*"
  (lambda (ab:AudioBuffer*)
    (if (null? ab)
        (printf "<AudioBuffer 0x0>")
        (printf "<AudioBuffer %p
      filepath: %s
      playhead: %lld
        frames: %lld
      channels: %lld
          data: %p
    samplerate: %f
    loop_start: %lld
   loop_frames: %lld>"
                ab
                (tref (tref ab 0) 1)
                (tref ab 1)
                (tref ab 2)
                (tref ab 3)
                (tref ab 4)
                (tref ab 5)
                (tref ab 6)
                (tref ab 7)))
    void))

(bind-poly print AudioBuffer_print)

(bind-func AudioBuffer_toString
  "specialised toString function for AudioBuffer*"
  (lambda (ab:AudioBuffer*)
    (let ((str:i8* (salloc 1024)))
      (if (null? ab)
          (sprintf str "<AudioBuffer 0x0>")
          (sprintf str "<AudioBuffer %p
      filepath: %s
      playhead: %lld
        frames: %lld
      channels: %lld
          data: %p
    samplerate: %f
    loop_start: %lld
   loop_frames: %lld>"
                   ab
                   (tref ab 0)
                   (tref ab 1)
                   (tref ab 2)
                   (tref ab 3)
                   (tref ab 4)
                   (tref ab 5)
                   (tref ab 6)
                   (tref ab 7)))
      (Str str))))

(bind-poly toString AudioBuffer_toString)

;; getters/setters

(bind-func AudioBuffer_filepath
  (lambda (ab:AudioBuffer*)
    (tref ab 0)))

(bind-func AudioBuffer_set_filepath
  (lambda (ab:AudioBuffer* filepath)
    (tset! ab 0 filepath)))

(bind-func AudioBuffer_playhead
  (lambda (ab:AudioBuffer*)
    (tref ab 1)))

(bind-func AudioBuffer_set_playhead
  (lambda (ab:AudioBuffer* playhead)
    (tset! ab 1 playhead)))

(bind-func AudioBuffer_frames
  (lambda (ab:AudioBuffer*)
    (tref ab 2)))

(bind-func AudioBuffer_set_frames
  (lambda (ab:AudioBuffer* frames)
    (tset! ab 2 frames)))

(bind-func AudioBuffer_channels
  (lambda (ab:AudioBuffer*)
    (tref ab 3)))

(bind-func AudioBuffer_set_channels
  (lambda (ab:AudioBuffer* channels)
    (tset! ab 3 channels)))

(bind-func AudioBuffer_data
  (lambda (ab:AudioBuffer*)
    (tref ab 4)))

(bind-func AudioBuffer_set_data
  (lambda (ab:AudioBuffer* data)
    (tset! ab 4 data)))

(bind-func AudioBuffer_samplerate
  (lambda (ab:AudioBuffer*)
    (tref ab 5)))

(bind-func AudioBuffer_set_samplerate
  (lambda (ab:AudioBuffer* samplerate)
    (tset! ab 5 samplerate)))

(bind-func AudioBuffer_loop_start
  (lambda (ab:AudioBuffer*)
    (tref ab 6)))

(bind-func AudioBuffer_set_loop_start
  (lambda (ab:AudioBuffer* loop_start)
    (tset! ab 6 loop_start)))

(bind-func AudioBuffer_loop_frames
  (lambda (ab:AudioBuffer*)
    (tref ab 7)))

(bind-func AudioBuffer_set_loop_frames
  (lambda (ab:AudioBuffer* loop_frames)
    (tset! ab 7 loop_frames)))

(bind-func AudioBuffer_num_samples
  "get the total number of samples (* frames channels) from an Audiobuffer"
  (lambda (ab:AudioBuffer*)
    (* (AudioBuffer_frames ab)
       (AudioBuffer_channels ab))))

(bind-func AudioBuffer_seek
  (lambda (ab:AudioBuffer* seek_to)
    (if (< seek_to 0)
        (begin
          (println "AudioBuffer seek value must be > 0")
          #f)
        (let ((len (AudioBuffer_frames ab)))
          (AudioBuffer_set_playhead ab (if (< seek_to len) seek_to len))
          #t))))

;; "peek" doesn't advance the playhead, "read" does

(bind-func AudioBuffer_peek
  (lambda (ab:AudioBuffer* chan)
    (let ((ph (AudioBuffer_playhead ab)))
      (if (< ph (AudioBuffer_frames ab))
          (pref (AudioBuffer_data ab)
                (+ (* ph (AudioBuffer_channels ab)) chan))
          0.0))))

(bind-func AudioBuffer_peek_looped
  (lambda (ab:AudioBuffer* chan)
    (let ((ph (AudioBuffer_playhead ab)))
      (pref (AudioBuffer_data ab)
            (+ (* (% ph (AudioBuffer_frames ab)) (AudioBuffer_channels ab)) chan)))))

(bind-func AudioBuffer_read_a
  (lambda (ab:AudioBuffer* chan)
    (let ((ph (AudioBuffer_playhead ab)))
      (if (< ph (AudioBuffer_frames ab))
          (begin
            (if (= chan 0) (AudioBuffer_set_playhead ab (+ ph 1)))
            (pref (AudioBuffer_data ab)
                  (+ (* ph (AudioBuffer_channels ab)) chan)))
          0.0))))

(bind-func AudioBuffer_read_b
  (lambda (ab:AudioBuffer* frame chan)
    (if (< frame (AudioBuffer_frames ab))
        (begin
          (if (= chan 0) (AudioBuffer_set_playhead ab frame))
          (pref (AudioBuffer_data ab)
                (+ (* frame (AudioBuffer_channels ab)) chan)))
        0.0)))

(bind-poly AudioBuffer_read AudioBuffer_read_a)
(bind-poly AudioBuffer_read AudioBuffer_read_b)

(bind-func AudioBuffer_read_looped_a
  (lambda (ab:AudioBuffer* chan)
    (let ((ph (AudioBuffer_playhead ab)))
      (if (= chan 0)
          (AudioBuffer_set_playhead ab (% (+ ph 1) (AudioBuffer_frames ab))))
      (pref (AudioBuffer_data ab)
            (+ (* ph (AudioBuffer_channels ab)) chan)))))

(bind-func AudioBuffer_read_looped_b
  (lambda (ab:AudioBuffer* frame chan)
    (if (= chan 0)
        (AudioBuffer_set_playhead ab (% frame (AudioBuffer_frames ab))))
    (if (> frame (AudioBuffer_frames ab))
        0.0
        (pref (AudioBuffer_data ab)
              (+ (* frame (AudioBuffer_channels ab)) chan)))))

(bind-poly AudioBuffer_read_looped AudioBuffer_read_looped_a)
(bind-poly AudioBuffer_read_looped AudioBuffer_read_looped_b)

(bind-func AudioBuffer_ptr
  "returns a pointer into the buffer"
  (lambda (ab:AudioBuffer* frame chan)
    (pref-ptr (AudioBuffer_data ab)
              (+ (* frame (AudioBuffer_channels ab)) chan))))

;;;;;;;;;;;;;;;;;;;;;;;;;
;; reading audio files ;;
;;;;;;;;;;;;;;;;;;;;;;;;;

;; A native xtlang wave and aiff file readers - currently only works
;; for *reading* uncompressed aiff and wave files. If you need to read
;; compressed audio files, or write audio files, use
;; libs/external/libsndfile.xtm

;; helper functions for bit twiddling

;; AIFFs are big-endian, so need some helper functions for
;; byte-swapping

(bind-func swapi16
  (lambda (x:i16)
    (bor (>> x 8)
         (<< x 8))))

(bind-func swapi32
  (lambda (x:i32)
    (bor (bor (& (>> x 24) #xff)           ;; move byte 3 to byte 0
              (& (<< x 8) #xff0000))       ;; move byte 1 to byte 2
         (bor (& (>> x 8) #xff00)          ;; move byte 2 to byte 1
              (& (<< x 24) #xff000000))))) ;; byte 0 to byte 3

(bind-func swap_bytes_inplace
  ;; super dangerous - use only if you know what you're doing
  (lambda (buf:i8* nbytes)
    (let ((tmp 0)
          (i 0))
      (dotimes (i (/ nbytes 2))
        (set! tmp (pref buf i))
        (pset! buf i (pref buf (- nbytes 1 i)))
        (pset! buf (- nbytes 1 i) tmp)))))

(bind-func audiofile_16bit_to_sample_le
  (let ((range (i64tod (<< 2 15))))
    (lambda (src:i16* dest:SAMPLE* nsamp)
      (doloop (i nsamp)
        (pset! dest i (dtof (/ (convert (pref src i)) range)))))))

(bind-func audiofile_16bit_to_sample_be
  (let ((range (i64tod (<< 2 15))))
    (lambda (src:i16* dest:SAMPLE* nsamp)
      (doloop (i nsamp)
        (pset! dest i (dtof (/ (convert (swapi16 (pref src i))) range)))))))

;;;;;;;;;;;;;;;;
;; WAVE files ;;
;;;;;;;;;;;;;;;;

(bind-type WaveFormat <|4,i8|,i32,|4,i8|,|4,i8|,i32,i16,i16,i32,i32,i16,i16,|4,i8|,i32>)

;; accessor functions
(bind-func waveformat_type
  (lambda (wf:WaveFormat*)
    (i16toi64 (tref wf 5))))

(bind-func waveformat_nchan
  (lambda (wf:WaveFormat*)
    (i16toi64 (tref wf 6))))

(bind-func waveformat_samplerate
  (lambda (wf:WaveFormat*)
    (i32tod (tref wf 7))))

(bind-func waveformat_bitdepth
  (lambda (wf:WaveFormat*)
    (i16toi64 (tref wf 10))))

(bind-func waveformat_datasize
  (lambda (wf:WaveFormat*)
    (i32toi64 (tref wf 12))))

(bind-func waveformat_nframes
  (lambda (wf:WaveFormat*)
    (/ (* 8 (waveformat_datasize wf))
       (* (waveformat_nchan wf)
          (waveformat_bitdepth wf)))))

(bind-func waveformat_check
  (lambda (wf:WaveFormat*)
    (and (= (strncmp (aref-ptr (tref-ptr wf 0) 0) "RIFF" 4) 0)
         (= (strncmp (aref-ptr (tref-ptr wf 2) 0) "WAVE" 4) 0))))

(bind-func waveformat_print
  "specialised print function for WaveFormat*"
  (lambda (wf:WaveFormat*)
    (if (null? wf)
        (printf "<WaveFormat 0x0>")
        (printf "<WaveFormat
    filesize: %d
    filetype: %.4s
      format: %s
       nchan: %d
  samplerate: %f
    bitdepth: %d
     nframes: %d
>"
                (tref wf 1)
                (cast (tref-ptr wf 2) i8*)
                (let ((type (waveformat_type wf)))
                  (cond ((= type 0) "Unknown")
                        ((= type 1) "PCM (uncompressed)")
                        ((= type 2) "Microsoft ADPCM")
                        ((= type 6) "ITU G.711 a-law")
                        ((= type 7) "ITU G.711 mu-law")
                        ((= type 17) "IMA ADPCM")
                        ((= type 20) "ITU G.723 ADPCM (Yamaha)")
                        ((= type 49) "GSM 6.10")
                        ((= type 64) "ITU G.721 ADPCM")
                        ((= type 80) "MPEG")
                        (else "Unknown")))
                (waveformat_nchan wf)
                (waveformat_samplerate wf)
                (waveformat_bitdepth wf)
                (waveformat_nframes wf)))
    void))

(bind-poly print waveformat_print)

(bind-func waveformat_toString
  "specialised toString function for WaveFormat*"
  (lambda (wf:WaveFormat*)
    (let ((str:i8* (salloc 256)))
      (if (null? wf)
          (sprintf str "<WaveFormat 0x0>")
          (sprintf str
                   "<WaveFormat
    filesize: %d
    filetype: %.4s
      format: %s
       nchan: %d
  samplerate: %f
    bitdepth: %d
     nframes: %d
>"
                   (tref wf 1)
                   (cast (tref-ptr wf 2) i8*)
                   (let ((type (waveformat_type wf)))
                     (cond ((= type 0) "Unknown")
                           ((= type 1) "PCM (uncompressed)")
                           ((= type 2) "Microsoft ADPCM")
                           ((= type 6) "ITU G.711 a-law")
                           ((= type 7) "ITU G.711 mu-law")
                           ((= type 17) "IMA ADPCM")
                           ((= type 20) "ITU G.723 ADPCM (Yamaha)")
                           ((= type 49) "GSM 6.10")
                           ((= type 64) "ITU G.721 ADPCM")
                           ((= type 80) "MPEG")
                           (else "Unknown")))
                   (waveformat_nchan wf)
                   (waveformat_samplerate wf)
                   (waveformat_bitdepth wf)
                   (waveformat_nframes wf)))
      (Str str))))

(bind-poly toString waveformat_toString)

(bind-func audiofile_wave_read_samples
  (lambda (filepath dest:SAMPLE*)
    (let ((filedata (sys_slurp_file filepath))
          (wfsize 44) ;; sizeof WaveFormat
          (wf:WaveFormat* (cast filedata WaveFormat*)))
      (if (null? filedata)
          (begin (println "wavefile error: could not open file")
                 (free filedata)
                 #f)
          (cond ((not (waveformat_check wf))
                 (println "wavefile error: there was a problem with the chunk IDs")
                 (free filedata)
                 #f)
                ((<> (waveformat_bitdepth wf) 16)
                 (println "wavefile error: the native xtlang wave file reader currently only supports 16-bit audio\nFor more format options, use libs/external/sndfile.xtm")
                 (free filedata)
                 #f)
                (else
                 (let ((dsize (waveformat_datasize wf))
                       (nchan (waveformat_nchan wf))
                       (bitdepth (waveformat_bitdepth wf))
                       (samplerate (waveformat_samplerate wf))
                       (nframes (waveformat_nframes wf)))
                   ;; read data into memory
                   (audiofile_16bit_to_sample_le (cast (pref-ptr filedata wfsize) i16*) dest (* nchan nframes))
                   (free filedata)
                   #t)))))))

(bind-func AudioBuffer_from_wave
  (lambda (filepath)
    (let ((filedata (sys_slurp_file filepath))
          (wfsize 44) ;; sizeof WaveFormat
          (wf:WaveFormat* (cast filedata WaveFormat*)))
      (if (null? filedata)
          (begin (println "wavefile error: could not open file")
                 (free filedata)
                 null)
          (cond ((not (waveformat_check wf))
                 (println "wavefile error: there was a problem with the chunk IDs")
                 (free filedata)
                 null)
                ((<> (waveformat_bitdepth wf) 16)
                 (println "wavefile error: the native xtlang wave file reader currently only supports 16-bit audio\nFor more format options, use libs/external/sndfile.xtm")
                 (free filedata)
                 null)
                (else
                 (let ((dsize (waveformat_datasize wf))
                       (nchan (waveformat_nchan wf))
                       (bitdepth (waveformat_bitdepth wf))
                       (samplerate (waveformat_samplerate wf))
                       (nframes (waveformat_nframes wf))
                       (ab (AudioBuffer nframes nchan samplerate)))
                   (AudioBuffer_set_filepath ab (Str filepath))
                   ;; read data into memory
                   (audiofile_16bit_to_sample_le (cast (pref-ptr filedata wfsize) i16*) (AudioBuffer_data ab) (* nchan nframes))
                   (free filedata)
                   ab)))))))

;;;;;;;;;;
;; AIFF ;;
;;;;;;;;;;

(bind-type AiffChunk <|4,i8|,i32>)

(bind-func aiffheader_chunksize
  (lambda (hdr:AiffChunk*)
    ;; AIFFs use big-endian, so need to swap the bytes
    (swapi32 (tref hdr 1))))

(bind-func aiffheader_check_ID
  "check the chunk & form IDs are valid"
  (lambda (hdr:AiffChunk* id:i8*)
    (= (strncmp (aref-ptr (tref-ptr hdr 0) 0) id 4) 0)))

(bind-func aiffheader_print
  "specialised print function for AiffChunk*"
  (lambda (hdr:AiffChunk*)
    (if (null? hdr)
        (printf "<AiffChunk 0x0>")
        (printf "<AiffChunk chunk ID: %.4s  chunk size: %d>"
                (aref-ptr (tref-ptr hdr 0) 0)
                (aiffheader_chunksize hdr)))
    void))

(bind-poly print aiffheader_print)

(bind-func aiffheader_toString
  "specialised toString function for AiffChunk*"
  (lambda (hdr:AiffChunk*)
    (let ((str:i8* (salloc 256)))
      (if (null? hdr)
          (sprintf str "<AiffChunk 0x0>")
          (sprintf str
                   "<AiffChunk chunk ID: %.4s  chunk size: %d>"
                   (aref-ptr (tref-ptr hdr 0) 0)
                   (aiffheader_chunksize hdr)))
      (Str str))))

(bind-poly toString aiffheader_toString)

;; currently, this will crash out if the AIFF sub-chunks are bad (it
;; doesn't know where the end of the file). It will gracefully handle
;; non AIFF files, though. Only corrupted ones would be a problem
(bind-func audiofile_aiff_read_samples
  (lambda (filepath dest:SAMPLE*)
    (let ((filedata (sys_slurp_file filepath))
          (hdr:AiffChunk* (salloc))
          (hdrsize 8) ;; sizeof AiffChunk
          (find_chunk (lambda (fileptr:i8* id)
                        ;; check that it's a valid AIFF file
                        (if (not (aiffheader_check_ID (cast fileptr AiffChunk*) "FORM"))
                            null
                            (begin
                              (set! fileptr (pref-ptr fileptr (+ hdrsize 4)))
                              (while (not (aiffheader_check_ID (cast fileptr AiffChunk*) id))
                                (set! fileptr
                                      (pref-ptr fileptr
                                                (+ hdrsize
                                                   (convert
                                                    (aiffheader_chunksize (cast fileptr AiffChunk*))
                                                    i64)))))
                              fileptr)))))
      (if (null? filedata)
          (begin (println "aiff file error: could not open file")
                 #f)
          (let ((common (find_chunk filedata "COMM"))
                (sounddata (find_chunk filedata "SSND")))
            (if (or (null? common) (null? sounddata))
                (begin
                  (println "aiff file error: there was a problem with the chunk IDs")
                  (free filedata)
                  #f)
                ;; pull the data out of the common chunk
                (let ((nchan (i16toi64 (swapi16 (pref (cast (pref-ptr common hdrsize) i16*) 0))))
                      (nframes (i32toi64 (swapi32 (pref (cast (pref-ptr common (+ hdrsize 2)) i32*) 0))))
                      (bitdepth (i16toi64 (swapi16 (pref (cast (pref-ptr common (+ hdrsize 6)) i16*) 0)))))
                  (if (<> bitdepth 16)
                      (begin
                        (println "aiff file error: the native xtlang wave file reader currently only supports 16-bit audio\nFor more format options, use libs/external/sndfile.xtm")
                        (free filedata)
                        #f)
                      (begin
                        (audiofile_16bit_to_sample_be (cast (pref-ptr sounddata (+ hdrsize 8)) i16*) dest (* nchan nframes))
                        ;; (free filedata) ;; why does this cause a crash?
                        #t)))))))))

(bind-func AudioBuffer_from_aiff
  (lambda (filepath)
    (let ((filedata (sys_slurp_file filepath))
          (hdr:AiffChunk* (salloc))
          (hdrsize 8) ;; sizeof AiffChunk
          (find_chunk (lambda (fileptr:i8* id)
                        ;; check that it's a valid AIFF file
                        (if (not (aiffheader_check_ID (cast fileptr AiffChunk*) "FORM"))
                            null
                            (begin
                              (set! fileptr (pref-ptr fileptr (+ hdrsize 4)))
                              (while (not (aiffheader_check_ID (cast fileptr AiffChunk*) id))
                                (set! fileptr
                                      (pref-ptr fileptr
                                                (+ hdrsize
                                                   (convert
                                                    (aiffheader_chunksize (cast fileptr AiffChunk*))
                                                    i64)))))
                              fileptr)))))
      (if (null? filedata)
          (begin (println "aiff file error: could not open file")
                 null)
          (let ((common (find_chunk filedata "COMM"))
                (sounddata (find_chunk filedata "SSND")))
            (if (or (null? common) (null? sounddata))
                (begin
                  (println "aiff file error: there was a problem with the chunk IDs")
                  (free filedata)
                  null)
                ;; pull the data out of the common chunk
                (let ((nchan (i16toi64 (swapi16 (pref (cast (pref-ptr common hdrsize) i16*) 0))))
                      (nframes (i32toi64 (swapi32 (pref (cast (pref-ptr common (+ hdrsize 2)) i32*) 0))))
                      (bitdepth (i16toi64 (swapi16 (pref (cast (pref-ptr common (+ hdrsize 6)) i16*) 0))))
                      (samplerate (begin
                                    (swap_bytes_inplace (pref-ptr common (+ hdrsize 8)) 10)
                                    (fp80ptrtod (pref-ptr common (+ hdrsize 8)))))
                      (ab (AudioBuffer nframes nchan samplerate)))
                  (AudioBuffer_set_filepath ab (Str filepath))
                  (if (<> bitdepth 16)
                      (begin
                        (println "aiff file error: the native xtlang wave file reader currently only supports 16-bit audio\nFor more format options, use libs/external/sndfile.xtm")
                        (free filedata)
                        null)
                      (begin
                        (audiofile_16bit_to_sample_be (cast (pref-ptr sounddata (+ hdrsize 8)) i16*) (AudioBuffer_data ab) (* nchan nframes))
                        ;; (free filedata) ;; why does this cause a crash?
                        ab)))))))))

;; works for both aiff and wave files

(bind-func audiofile_read_samples
  (lambda (filepath dest:SAMPLE*)
    (cond ((rmatch "\\.wave?$" filepath)
           (audiofile_wave_read_samples filepath dest))
          ((rmatch "\\.aiff?$" filepath)
           (audiofile_aiff_read_samples filepath dest))
          (else
           (println "native xtlang audiofile reader only works for uncompressed aiff and wave files")
           #f))))

(bind-func AudioBuffer_from_file
  (lambda (filepath)
    (cond ((rmatch "\\.wave?$" filepath)
           (AudioBuffer_from_wave filepath))
          ((rmatch "\\.aiff?$" filepath)
           (AudioBuffer_from_aiff filepath))
          (else
           (println "native xtlang audiofile reader only works for uncompressed aiff and wave files")
           null))))

(bind-poly AudioBuffer AudioBuffer_from_file)

(impc:aot:insert-footer "xtmaudiobuffer")
(define *xtmlib-audiobuffer-loaded* #t)
