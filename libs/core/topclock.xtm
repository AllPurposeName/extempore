;;; topclock.xtm -- distributed OSC clock (core)

;; Author: Andrew Sorensen
;; Keywords: extempore

;;; Commentary:

;;; Code:

;; lib-loading config

;; This is designed for simplicity so the following holds

;; * work with IPADDRESS so no name resolving required
;; * with single double precision time (epoch of NTP)
;; * registration to avoid UDP broadcasting (disabled by many
;; switches)
;; * direct host->host (make grid higher level concern)
;; * everyone sends *offset* clock times (not system)

(sys:load "libs/core/instruments.xtm")
(sys:load "libs/external/libc.xtm")

;; pairs <address,rate>
(define *topclock-registered-address* '())
;; ip client (assume wireless interface "en0" not "eth0")
(define *iplocal* (sys:interface-address "en0"))
;; topclock port
(define *topclock-port* 5555)
;; epoch adjustments for NTP Jan 1st 1900
(define *Epoch-1900-1970* 2208988800.0)

(define 1900->1970
  (lambda (time)
    (- time *Epoch-1900-1970*)))

(define 1970->1900
  (lambda (time)
    (+ time *Epoch-1900-1970*)))

;; OSC reciever (for both client and server)
(define topclock-receive
  (let ((oldbpm 0.0))
    (lambda (timestamp address . args)
      (cond ((string=? address "/topclock/sync/request")
             (io:osc:send (now) (cons (car args) *topclock-port*) "/topclock/sync/response"
                          (cadr args) (1970->1900 (clock:clock))))
            ((string=? address "/topclock/sync/response")
             (let* ((t1 (1900->1970 (car args)))
                    (t2 (1900->1970 (cadr args))) ;; t2 
                    (t3 (1900->1970 (cadr args))) ;; and t3 the same
                    (t4 (clock:clock))
                    (msg-delay (- t4 t1))
                    (offset (/ (+ (- t2 t1) (- t3 t4)) 2.0)))
               (if (< msg-delay .1) (clock:adjust-offset offset))))
            ((string=? address "/topclock/register")
             (let ((mark (*metro* 'get-mark))
                   (tempo (*metro* 'get-tempo)))
               (println 'registering 'client (car args) 'at 'rate (cadr args))
               (set! *topclock-registered-address*
                     (cons (cons (car args) (cadr args))
                           *topclock-registered-address*))))
            ((string=? address "/topclock/stream")
             (let ((time (1900->1970 (car args)))
                   (bpm (cadr args))
                   (beat (caddr args))
                   (num (cadddr args))
                   (denom (car (cddddr args))))
               ;; don't worry about metre (num/denom) for testing               
               (if (<> bpm oldbpm)
                   (begin (set! oldbpm bpm)
                          (println '*metro* bpm (clock->samples time) beat (* 1. (*metro* 'get-beat 1/32)))
                          (*metro* 'set-tempo bpm (clock->samples time) beat)))))
            ((string=? address "/topclock/bpm/request")
             (let ((mark (*metro* 'get-mark))
                   (tempo (*metro* 'get-tempo)))
               (io:osc:send (now) (cons (car args) *topclock-port*) "/topclock/bpm/reply"
                            tempo (1970->1900 (samples->clock (car mark))) (cdr mark))))
            ((string=? address "/topclock/bpm/reply")
             (let ((bpm (car args))
                   (time (1900->1970 (cadr args)))
                   (beat (caddr args)))
               (println 'tempo: bpm 'time: time 'beat: beat)
               (*metro* 'set-tempo bpm (clock->samples time) beat)))
            ((string=? address "/topclock/bpm/update")
             (let ((time (1900->1970 (car args)))
                   (bpm (cadr args))
                   (beat (caddr args)))
               (println 'Update! bpm)
               (set! oldbpm bpm)
               (*metro* 'set-tempo bpm (clock->samples time) beat)))
            ((string=? address "/topclock/bpm/new")
             (let ((time (car args)) ;;(1900->1970 (car args)))
                   (bpm (cadr args))
                   (beat (caddr args)))
               (if (>= beat (*metro* 'get-beat 1/32))
                   (for-each (lambda (c)
                               (println 'c: c)
                               (io:osc:send (now) (cons (car c) *topclock-port*) "/topclock/bpm/update"
                                            time bpm beat))
                             *topclock-registered-address*))))
            (else (println 'bad 'osc 'message: address))))))

;; start topclock osc receiver (both client and server)
(io:osc:start-server *topclock-port* "topclock-receive")
;; use doubles for OSC real nums:
(io:osc:set-real-64bit? #t)

;; sends OSC message /topclock/sync/request
;; of type <string,double>
;; 'string' is ipaddress string (client must convert hostname to IP)
;; 'double' is the system time in seconds (UTC with epoch of Jan 1 1900 (i.e. NTP))
(define topclock-sync
  (lambda (server)
    (io:osc:send (now) (cons server *topclock-port*) "/topclock/sync/request"
                 *iplocal* (1970->1900 (clock:clock)))))


;; sends OSC message /topclock/register
;; of type <string,double>
;; 'string' is ipaddress string (client must convert hostname to IP)
;; 'double' is the 'stream' rate which is in beats at current BPM (0.125 for 8th notes as example)
(define topclock-register
  (lambda (server rate)
    (io:osc:send (now) (cons server *topclock-port*) "/topclock/register"
                 *iplocal* rate)))


;; sends OSC message /topclock/bpm
;; of type <double,double>
;; 'double' is time (UTC epoch 1900)
;; 'bpm' beats per minute
(define topclock-bpm
  (lambda (server time bpm beat)
    (io:osc:send (now) (cons server *topclock-port*) "/topclock/bpm/new"
                 (1970->1900 (samples->clock time)) bpm beat)))

;; query server for current bpm
(define topclock-query-bpm
  (lambda (server)
    (io:osc:send (now) (cons server *topclock-port*) "/topclock/bpm/request"
                 *iplocal*)))

(define topclock-sync-regular
  (lambda (server)
    (topclock-sync server) 
    (callback (+ (now) 10000) 'topclock-sync-regular server)))

;; server proc streams to all registered ip addresses
;; at whatever specified rate (in beats) the client provided
(define topclock-streamer
  (lambda (beat dur)
    (for-each (lambda (client)
                (if (and (> (cdr client) 0)
                         (modulo beat (cdr client)))
                    (io:osc:send (now) (cons (car client) *topclock-port*) "/topclock/stream"
                                 (1970->1900 (samples->clock (*metro* beat)))
                                 (*metro* 'get-tempo)
                                 (rational->real beat)
                                 0 0))) ;; don't worry about num and denum for tests              
              *topclock-registered-address*)
    (callback (*metro* (+ beat (* .5 dur))) 'topclock-streamer
              (+ beat dur) dur)))

;; connect to topclock server
(define topclock-start-streamer
  (lambda (server rate)
    (topclock-streamer (*metro* 'get-beat 4) rate)))

(define topclock-start
  (lambda (server)
    (topclock-sync-regular server)
    (topclock-register server 0) ;; rate of 0 means don't stream anything!
    ;; let sync happen before bpm
    (callback (+ (now) 10000) 'topclock-query-bpm server)
    ;; let bpm happen before streamer start
    (callback (+ (now) 20000) 'topclock-start-streamer server 1/32)
    (println 'topclock-started)))

(topclock-start "10.0.1.8")

(bind-func dsp:DSP 1000000
  (let ((t 0.0))
    (lambda (in time chan dat)
      (if (= t 0.0) (set! t time))
      (if (< chan 1.5)
          (+ (fmsynth in time chan dat)
             0.0)
          0.0))))

(dsp:set! dsp)

(fmsynth_fx.wet .05)
(fmsynth_fx.dfb .05)

(define test
  (lambda (beat dur)
    (if (and (= (modulo beat 4) 0)
             (> (random) .8))
        (topclock-bpm "10.0.1.8" (*metro* beat) (random 90 180) beat))
    (if (= (modulo beat 4) 0)        
        (play fmsynth 67 80 .1)
        (play fmsynth 60 80 .1))
    (callback (*metro* (+ beat (* .5 dur))) 'test (+ beat dur) dur)))

(define teststart
  (lambda ()    
    (test (*metro* 'get-beat 4) 1)))

(callback (+ (now) 500000) 'teststart)
