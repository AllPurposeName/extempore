;; math.xtm -- extempore math library

;; Author: Andrew Sorensen, Ben Swift
;; Keywords: extempore

;;; Commentary:

;; This file contains math routines written in xtlang.  If you're
;; concerned about raw performance at all costs, it may be better to
;; dynamically link to BLAS or something like that.  However, because
;; everything is dynamically rebindable, there are also lots of
;; opportunities to do cool things with this library.

;; This file contains xtlang functions (and the odd data type) for
;; dealing with:
;; - vectors
;; - matrices
;; - complex numbers
;; - windowing

;;; Code:

;; lib-loading config

(sys:load "libs/aot-cache/math.xtm" 'quiet)
(sys:load-preload-check 'math)
(define *xtmlib-math-loaded* #f)

(impc:aot:suppress-aot-do
 (sys:load "libs/core/std.xtm"))
(impc:aot:insert-forms (sys:load "libs/core/std.xtm" 'quiet))

(impc:aot:insert-header "xtmmath")

;;;;;;;;;;;;;;;; default sort!

(bind-func _qsortd
  (lambda (dat:double* left right)
    (if (< left right)
        (let ((tmp 0.0)
              (_swap (lambdas (x y)
                              (set! tmp (pref dat x))
                              (pset! dat x (pref dat y))
                              (pset! dat y tmp)))
              (pivot (pref dat right))
              (index left)
              (i 0))
          (dotimes (i left (- right left))
            (if (or (< (pref dat i) pivot)
                    (= (pref dat i) pivot))
                (begin (_swap i index)
                       (set! index (+ index 1)))))
          (_swap right index)
          (_qsortd dat left (- index 1))
          (_qsortd dat (+ index 1) right))
        void)))

(bind-func _qsortf
  (lambda (dat:float* left right)
    (if (< left right)
        (let ((tmp 0.0)
              (_swap (lambdas (x y)
                              (set! tmp (pref dat x))
                              (pset! dat x (pref dat y))
                              (pset! dat y tmp)))
              (pivot (pref dat right))
              (index left)
              (i 0))
          (dotimes (i left (- right left))
            (if (or (< (pref dat i) pivot)
                    (= (pref dat i) pivot))
                (begin (_swap i index)
                       (set! index (+ index 1)))))
          (_swap right index)
          (_qsortf dat left (- index 1))
          (_qsortf dat (+ index 1) right))
        void)))

(bind-func _qsorti64
  (lambda (dat:i64* left right)
    (if (< left right)
        (let ((tmp 0)
              (_swap (lambdas (x y)
                              (set! tmp (pref dat x))
                              (pset! dat x (pref dat y))
                              (pset! dat y tmp)))
              (pivot (pref dat right))
              (index left)
              (i 0))
          (dotimes (i left (- right left))
            (if (or (< (pref dat i) pivot)
                    (= (pref dat i) pivot))
                (begin (_swap i index)
                       (set! index (+ index 1)))))
          (_swap right index)
          (_qsorti64 dat left (- index 1))
          (_qsorti64 dat (+ index 1) right))
        void)))

(bind-func _qsorti32
  (lambda (dat:i32* left right)
    (if (< left right)
        (let ((tmp 0)
              (_swap (lambdas (x y)
                              (set! tmp (pref dat x))
                              (pset! dat x (pref dat y))
                              (pset! dat y tmp)))
              (pivot (pref dat right))
              (index left)
              (i 0))
          (dotimes (i left (- right left))
            (if (or (< (pref dat i) pivot)
                    (= (pref dat i) pivot))
                (begin (_swap i index)
                       (set! index (+ index 1)))))
          (_swap right index)
          (_qsorti32 dat left (- index 1))
          (_qsorti32 dat (+ index 1) right))
        void)))

(bind-func _qsorti16
  (lambda (dat:i16* left right)
    (if (< left right)
        (let ((tmp 0)
              (_swap (lambdas (x y)
                              (set! tmp (pref dat x))
                              (pset! dat x (pref dat y))
                              (pset! dat y tmp)))
              (pivot (pref dat right))
              (index left)
              (i 0))
          (dotimes (i left (- right left))
            (if (or (< (pref dat i) pivot)
                    (= (pref dat i) pivot))
                (begin (_swap i index)
                       (set! index (+ index 1)))))
          (_swap right index)
          (_qsorti16 dat left (- index 1))
          (_qsorti16 dat (+ index 1) right))
        void)))

(bind-func _qsorti8
  (lambda (dat:i8* left right)
    (if (< left right)
        (let ((tmp 0)
              (_swap (lambdas (x y)
                              (set! tmp (pref dat x))
                              (pset! dat x (pref dat y))
                              (pset! dat y tmp)))
              (pivot (pref dat right))
              (index left)
              (i 0))
          (dotimes (i left (- right left))
            (if (or (< (pref dat i) pivot)
                    (= (pref dat i) pivot))
                (begin (_swap i index)
                       (set! index (+ index 1)))))
          (_swap right index)
          (_qsorti8 dat left (- index 1))
          (_qsorti8 dat (+ index 1) right))
        void)))

;; this generic _qsort works but is SUPER slow!
(bind-func _qsort:[void,!a,i64,i64]*
  (lambda (dat left right)
    (if (< left right)
        (let ((tmp (convert 0))
              (_swap (lambdas (x y)
                              (set! tmp (pref dat x))
                              (pset! dat x (pref dat y))
                              (pset! dat y tmp)))
              (pivot (pref dat right))
              (index left)
              (i 0))
          (dotimes (i left (- right left))
            (if (or (< (pref dat i) pivot)
                    (= (pref dat i) pivot))
                (begin (_swap i index)
                       (set! index (+ index 1)))))
          (_swap right index)
          (_qsort dat left (- index 1))
          (_qsort dat (+ index 1) right))
        void)))

(bind-func sortd
  (lambda (arr:double* lgth)
    (_qsortd arr 0 (- lgth 1))
    arr))

(bind-func sortf
  (lambda (arr:float* lgth)
    (_qsortf arr 0 (- lgth 1))
    arr))

(bind-func sorti64
  (lambda (arr:i64* lgth)
    (_qsorti64 arr 0 (- lgth 1))
    arr))

(bind-func sorti32
  (lambda (arr:i32* lgth)
    (_qsorti32 arr 0 (- lgth 1))
    arr))

(bind-func sorti16
  (lambda (arr:i16* lgth)
    (_qsorti16 arr 0 (- lgth 1))
    arr))

(bind-func sorti8
  (lambda (arr:i8* lgth)
    (_qsorti8 arr 0 (- lgth 1))
    arr))

(bind-poly sort sortd)
(bind-poly sort sortf)
(bind-poly sort sorti64)
(bind-poly sort sorti32)
(bind-poly sort sorti16)
(bind-poly sort sorti8)

;;;;;;;;;;;;;;;; sum, mean, median, mode
;; need to extend these to ints

(bind-func sumi32
  (lambda (buf:i32* lgth:i64)
    (if (= (& lgth 3) 0) ;; i.e. mod 4
        (let ((vbuf:/4,i32/* (cast buf))
              (tot:/4,i32/* (alloc))
              (j 0))
          (dotimes (j (/ lgth 4))
            (pset! tot 0 (+ (pref-ptr vbuf j) tot)))
          (+ (vref tot 0) (vref tot 1) (vref tot 2) (vref tot 3)))
        (let ((tot 0) (i 0))
          (dotimes (i lgth)
            (set! tot (+ tot (pref buf i))))
          tot))))

(bind-func sumi64
  (lambda (buf:i64* lgth:i64)
    (if (= (& lgth 1) 0) ;; i.e. mod 2
        (let ((vbuf:/2,i64/* (cast buf))
              (tot:/2,i64/* (alloc))
              (j 0))
          (dotimes (j (/ lgth 2))
            (pset! tot 0 (+ (pref-ptr vbuf j) tot)))
          (+ (vref tot 0) (vref tot 1)))
        (let ((tot 0) (i 0))
          (dotimes (i lgth)
            (set! tot (+ tot (pref buf i))))
          tot))))

(bind-func sumf
  (lambda (buf:float* lgth:i64)
    (if (= (& lgth 3) 0) ;; i.e. mod 4
        (let ((vbuf:/4,float/* (cast buf))
              (tot:/4,float/* (alloc))
              (j 0))
          (dotimes (j (/ lgth 4))
            (pset! tot 0 (+ (pref-ptr vbuf j) tot)))
          (+ (vref tot 0) (vref tot 1) (vref tot 2) (vref tot 3)))
        (let ((tot 0.0) (i 0))
          (dotimes (i lgth)
            (set! tot (+ tot (pref buf i))))
          tot))))

(bind-func sumd
  (lambda (buf:double* lgth:i64)
    (if (= (& lgth 1) 0) ;; i.e. mod 2
        (let ((vbuf:/2,double/* (cast buf))
              (tot:/2,double/* (alloc))
              (j 0))
          (dotimes (j (/ lgth 2))
            (pset! tot 0 (+ (pref-ptr vbuf j) tot)))
          (+ (vref tot 0) (vref tot 1)))
        (let ((tot 0.0) (i 0))
          (dotimes (i lgth)
            (set! tot (+ tot (pref buf i))))
          tot))))

(bind-poly sum sumi32)
(bind-poly sum sumi64)
(bind-poly sum sumf)
(bind-poly sum sumd)

;; even for ints, you probably want a floating-point answer for the
;; mean - these ones return doubles to minimize the chance of
;; precision error

(bind-func meani32
  (lambda (buf:i32* lgth:i64)
    (if (= (& lgth 3) 0) ;; i.e. mod 4
        (let ((vbuf:/4,i32/* (cast buf))
              (tot:/4,i32/* (alloc))
              (j 0))
          (dotimes (j (/ lgth 4))
            (pset! tot 0 (+ (pref-ptr vbuf j) tot)))
          (/ (i32tod (+ (vref tot 0) (vref tot 1)
                        (vref tot 2) (vref tot 3)))
             (i64tod lgth)))
        (let ((tot 0) (i 0))
          (dotimes (i lgth)
            (set! tot (+ tot (pref buf i))))
          (/ (i32tod tot) (i64tod lgth))))))

(bind-func meani64
  (lambda (buf:i64* lgth:i64)
    (if (= (& lgth 1) 0) ;; i.e. mod 2
        (let ((vbuf:/2,i64/* (cast buf))
              (tot:/2,i64/* (alloc))
              (j 0))
          (dotimes (j (/ lgth 4))
            (pset! tot 0 (+ (pref-ptr vbuf j) tot)))
          (/ (i64tod (+ (vref tot 0) (vref tot 1)))
             (i64tod lgth)))
        (let ((tot 0) (i 0))
          (dotimes (i lgth)
            (set! tot (+ tot (pref buf i))))
          (/ (i64tod tot) (i64tod lgth))))))

(bind-func meanf
  (lambda (buf:float* lgth:i64)
    (if (= (& lgth 3) 0) ;; i.e. mod 4
        (let ((vbuf:/4,float/* (cast buf))
              (tot:/4,float/* (alloc))
              (j 0))
          (dotimes (j (/ lgth 4))
            (pset! tot 0 (+ (pref-ptr vbuf j) tot)))
          (/ (+ (vref tot 0) (vref tot 1)
                (vref tot 2) (vref tot 3))
             (i64tof lgth)))
        (let ((tot 0.0) (i 0))
          (dotimes (i lgth)
            (set! tot (+ tot (pref buf i))))
          (/ tot (i64tof lgth))))))

(bind-func meand
  (lambda (buf:double* lgth:i64)
    (if (= (& lgth 1) 0) ;; i.e. mod 2
        (let ((vbuf:/2,double/* (cast buf))
              (tot:/2,double/* (alloc))
              (j 0))
          (dotimes (j (/ lgth 4))
            (pset! tot 0 (+ (pref-ptr vbuf j) tot)))
          (/ (+ (vref tot 0) (vref tot 1))
             (i64tod lgth)))
        (let ((tot 0.0) (i 0))
          (dotimes (i lgth)
            (set! tot (+ tot (pref buf i))))
          (/ tot (i64tod lgth))))))

(bind-poly mean meani32)
(bind-poly mean meani64)
(bind-poly mean meand)
(bind-poly mean meanf)

(bind-func mediand
  (lambda (x:double* lgth:i64)
    (let ((h (sort x lgth))
          (idx (dtoi64 (ceil (/ (i64tod lgth) 2.0)))))
      (if (evenp lgth)
          (/ (+ (pref h idx) (pref h (- idx 1))) 2.0)
          (pref h idx)))))

(bind-func medianf
  (lambda (x:float* lgth:i64)
    (let ((h (sort x lgth))
          (idx (dtoi64 (ceil (/ (i64tod lgth) 2.0)))))
      (if (evenp lgth)
          (/ (+ (pref h idx) (pref h (- idx 1))) 2.0)
          (pref h idx)))))

(bind-poly median mediand)
(bind-poly median medianf)

;; naive mode needs to be replaced!
(bind-func moded
  (lambda (x:double* lgth:i64)
    (let ((h (sort x lgth))
          (p NaN) (l 0) (largest 0) (j:double 0.0) (i 0))
      (dotimes (i lgth)
        (if (= p (pref x i))
            (set! l (+ l 1)) ;; increment l
            (set! l 0))
        (set! p (pref x i))
        (if (> l largest)
            (begin
              (set! largest l)
              (set! j p))))
      j)))

(bind-func modef
  (lambda (x:float* lgth:i64)
    (let ((h (sort x lgth))
          (p NaNf) (l 0) (largest 0) (j:float 0.0) (i 0))
      (dotimes (i lgth)
        (if (= p (pref x i))
            (set! l (+ l 1)) ;; increment l
            (set! l 0))
        (set! p (pref x i))
        (if (> l largest)
            (begin
              (set! largest l)
              (set! j p))))
      j)))

(bind-poly mode modef)
(bind-poly mode moded)

(bind-func minf_sort
  (lambda (x:float* lgth:i64)
    (let ((h (sort x lgth)))
      (pref h 0))))

(bind-func mind_sort
  (lambda (x:double* lgth:i64)
    (let ((h (sort x lgth)))
      (pref h 0))))


(bind-func minf
  (lambda (x:float* lgth:i64)
    (let ((min_val (pref x 0))
          (i 0))
      (dotimes (i lgth)
        (if (< (pref x i) min_val)
            (set! min_val (pref x i))))
      min_val)))

(bind-func mind
  (lambda (x:double* lgth:i64)
    (let ((min_val (pref x 0))
          (i 0))
      (dotimes (i lgth)
        (if (< (pref x i) min_val)
            (set! min_val (pref x i))))
      min_val)))

(bind-func min2f
  (lambda (x:float y:float)
    (if (< x y) x y)))

(bind-func min2d
  (lambda (x:double y:double)
    (if (< x y) x y)))

(bind-func min2i32
  (lambda (x:i32 y:i32)
    (if (< x y) x y)))

(bind-func min2i64
  (lambda (x:i64 y:i64)
    (if (< x y) x y)))

(bind-poly min_sort minf_sort)
(bind-poly min_sort mind_sort)

;; min is now a macro in runtime/scheme.xtm
;; (bind-poly min minf)
;; (bind-poly min mind)
;; (bind-poly min min2f)
;; (bind-poly min min2d)
;; (bind-poly min min2i32)
;; (bind-poly min min2i64)

(bind-func maxf_sort
  (lambda (x:float* lgth:i64)
    (let ((h (sort x lgth)))
      (pref h (- lgth 1)))))

(bind-func maxd_sort
  (lambda (x:double* lgth:i64)
    (let ((h (sort x lgth)))
      (pref h (- lgth 1)))))

(bind-func maxf
  (lambda (x:float* lgth:i64)
    (let ((max_val (pref x 0))
          (i 0))
      (dotimes (i lgth)
        (if (> (pref x i) max_val)
            (set! max_val (pref x i))))
      max_val)))

(bind-func maxd
  (lambda (x:double* lgth:i64)
    (let ((max_val (pref x 0))
          (i 0))
      (dotimes (i lgth)
        (if (> (pref x i) max_val)
            (set! max_val (pref x i))))
      max_val)))

(bind-func max2f
  (lambda (x:float y:float)
    (if (> x y) x y)))

(bind-func max2d
  (lambda (x:double y:double)
    (if (> x y) x y)))

(bind-func max2i32
  (lambda (x:i32 y:i32)
    (if (> x y) x y)))

(bind-func max2i64
  (lambda (x:i64 y:i64)
    (if (> x y) x y)))

(bind-poly max_sort maxf_sort)
(bind-poly max_sort maxd_sort)

;; min is now a macro in runtime/scheme.xtm
;; (bind-poly max maxf)
;; (bind-poly max maxd)
;; (bind-poly max max2f)
;; (bind-poly max max2d)
;; (bind-poly max max2i32)
;; (bind-poly max max2i64)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; random numbers
;;

;; gaussian random number X ~ N(0,1)
;; algorithm by Marsaglia http://c-faq.com/lib/gaussian.html

(bind-func randnd
  (let ((phase 0))
    (lambda ()
      (let ((u1:double (random))
            (u2:double (random))
            (v1 (- (* 2.0 u1) 1.0))
            (v2 (- (* 2.0 u2) 1.0))
            (s (+ (* v1 v1) (* v2 v2))))
        (if (= phase 0)
            (if (or (> s 1.0) (= s 0.0) (= s 1.0))
                (randnd)
                (* v1 (sqrt (/ (* -2.0 (log s)) s))))
            (begin (set! phase (- 1 phase))
                   (* v2 (sqrt (/ (* -2.0 (log s)) s)))))))))

(bind-func randnf
  (let ((phase 0))
    (lambda ()
      (let ((u1:float (random))
            (u2:float (random))
            (v1 (- (* 2.0 u1) 1.0))
            (v2 (- (* 2.0 u2) 1.0))
            (s (+ (* v1 v1) (* v2 v2))))
        (if (= phase 0)
            (if (or (> s 1.0) (= s 0.0) (= s 1.0))
                (randnf)
                (* v1 (sqrt (/ (* -2.0 (log s)) s))))
            (begin (set! phase (- 1 phase))
                   (* v2 (sqrt (/ (* -2.0 (log s)) s)))))))))

(bind-poly gaussr randnd)
(bind-poly gaussr randnf)

;;;;;;;;;; VECTOR ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; some basic vector functions
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(bind-func vprintd
  (lambda (v:double* lgth:i64)
    (let ((i 0))
      (printf "[")
      (printf " %f" (pref v 0))
      (dotimes (i (- lgth 1))
        (printf " %f" (pref v (+ i 1))))
      (printf " ]")
      void)))

(bind-func vprintf
  (lambda (v:float* lgth:i64)
    (let ((i 0))
      (printf "[")
      (printf " %f" (ftod (pref v 0)))
      (dotimes (i (- lgth 1))
        (printf " %f" (ftod (pref v (+ i 1)))))
      (printf " ]")
      void)))

(bind-poly vprint vprintd)
(bind-poly vprint vprintf)

(bind-func vnormd
  (lambda (v:double* lgth:i64 n:double*)
    (let ((mag 0.0)
          (i 0))
      (dotimes (i lgth)
        (set! mag (+ mag (* (pref v i) (pref v i)))))
      (set! mag (sqrt mag))
      (dotimes (i lgth)
        (pset! n i (/ (pref v i) mag)))
      void)))

(bind-func vnormf
  (lambda (v:float* lgth:i64 n:float*)
    (let ((mag 0.0)
          (i 0))
      (dotimes (i lgth)
        (set! mag (+ mag (* (pref v i) (pref v i)))))
      (set! mag (sqrt mag))
      (dotimes (i lgth)
        (pset! n i (/ (pref v i) mag)))
      void)))

(bind-poly vnorm vnormd)
(bind-poly vnorm vnormf)


(bind-func vdotd
  (let ((i 0))
    (lambda (v1:double* v2:double* lgth:i64)
      (let ((res 0.0))
        (dotimes (i lgth)
          (set! res (+ res (* (pref v1 i) (pref v2 i)))))
        res))))

(bind-func vdotf
  (let ((i 0))
    (lambda (v1:float* v2:float* lgth:i64)
      (let ((res 0.0))
        (dotimes (i lgth)
          (set! res (+ res (* (pref v1 i) (pref v2 i)))))
        res))))

(bind-poly vdot vdotd)
(bind-poly vdot vdotf)

;; for 3d only SO NO LGTH
(bind-func vcrossd
  (let ((i 0))
    (lambda (v1:double* v2:double* v3:double*)
      (pfill! v3
              (- (* (pref v1 1) (pref v2 2))
                 (* (pref v2 1) (pref v1 2)))
              (- (* (pref v2 0) (pref v1 2))
                 (* (pref v1 0) (pref v2 2)))
              (- (* (pref v1 0) (pref v2 1))
                 (* (pref v2 0) (pref v1 1))))
      void)))


;; for 3d only SO NO LGTH
(bind-func vcrossf
  (let ((i 0))
    (lambda (v1:float* v2:float* v3:float*)
      (pfill! v3
              (- (* (pref v1 1) (pref v2 2))
                 (* (pref v2 1) (pref v1 2)))
              (- (* (pref v2 0) (pref v1 2))
                 (* (pref v1 0) (pref v2 2)))
              (- (* (pref v1 0) (pref v2 1))
                 (* (pref v2 0) (pref v1 1))))
      void)))

(bind-poly vcross vcrossd)
(bind-poly vcross vcrossf)

(bind-func vsmuld
  (lambda (s:double v1:double* lgth:i64 v2:double*)
    (let ((i 0))
      (dotimes (i lgth)
        (pset! v2 i (* s (pref v1 i))))
      void)))

(bind-func vsmulf
  (lambda (s:float v1:float* lgth:i64 v2:float*)
    (let ((i 0))
      (dotimes (i lgth)
        (pset! v2 i (* s (pref v1 i))))
      void)))

(bind-poly vsmul vsmuld)
(bind-poly vsmul vsmulf)

(bind-func vsdivd
  (lambda (s:double v1:double* lgth:i64 v2:double*)
    (let ((i 0))
      (dotimes (i lgth)
        (pset! v2 i (/ (pref v1 i) s)))
      void)))

(bind-func vsdivf
  (lambda (s:float v1:float* lgth:i64 v2:float*)
    (let ((i 0))
      (dotimes (i lgth)
        (pset! v2 i (/ (pref v1 i) s)))
      void)))

(bind-poly vsdiv vsdivd)
(bind-poly vsdiv vsdivf)

(bind-func vsumd
  (let ((i 0))
    (lambda (v1:double* v2:double* lgth:i64 v3:double*)
      (dotimes (i lgth)
        (pset! v3 i (+ (pref v1 i) (pref v2 i))))
      void)))

(bind-func vsumf
  (let ((i 0))
    (lambda (v1:float* v2:float* lgth:i64 v3:float*)
      (dotimes (i lgth)
        (pset! v3 i (+ (pref v1 i) (pref v2 i))))
      void)))

(bind-poly vsum vsumd)
(bind-poly vsum vsumf)

(bind-func vsubd
  (let ((i 0))
    (lambda (v1:double* v2:double* lgth:i64 v3:double*)
      (dotimes (i lgth)
        (pset! v3 i (- (pref v1 i) (pref v2 i))))
      void)))

(bind-func vsubf
  (let ((i 0))
    (lambda (v1:float* v2:float* lgth:i64 v3:float*)
      (dotimes (i lgth)
        (pset! v3 i (- (pref v1 i) (pref v2 i))))
      void)))

(bind-poly vsub vsubd)
(bind-poly vsub vsubf)

(bind-func vmuld  
  (let ((i 0))
    (lambda (v1:double* v2:double* lgth:i64 v3:double*)
      (dotimes (i lgth)
        (pset! v3 i (* (pref v1 i) (pref v2 i))))
      void)))

(bind-func vmulf
  (let ((i 0))
    (lambda (v1:float* v2:float* lgth:i64 v3:float*)
      (dotimes (i lgth)
        (pset! v3 i (* (pref v1 i) (pref v2 i))))
      void)))

(bind-poly vmul vmuld)
(bind-poly vmul vmulf)

(bind-func vmagd
  (lambda (v:double* lgth:i64)
    (let ((mag 0.0)
          (i 0))
      (dotimes (i lgth)
        (set! mag (+ mag (* (pref v i) (pref v i)))))
      (sqrt mag))))

(bind-func vmagf
  (lambda (v:float* lgth:i64)
    (let ((mag 0.0)
          (i 0))
      (dotimes (i lgth)
        (set! mag (+ mag (* (pref v i) (pref v i)))))
      (sqrt mag))))


(bind-poly vmag vmagd)
(bind-poly vmag vmagf)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Quaternions
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; angle in rads
;; v is for axis vector (3d)
;; quat is a user supplied 4d vector (x,y,z,w)
(bind-func vaquatd
  (lambda (angle:double v:double* quat:double*)
    (let ((m (vmagd v 3))
          (s (/ (sin (* 0.5 angle)) m)))
      (pfill! quat
              (* (pref v 0) s) (* (pref v 1) s) (* (pref v 2) s)
              (cos (* 0.5 angle)))
      void)))

;; angle in rads
;; v is for axis vector (3d)
;; quat is a user supplied 4d vector (x,y,z,w)
(bind-func vaquatf
  (lambda (angle:float v:float* quat:float*)
    (let ((m (vmagf v 3))
          (s (/ (sin (* 0.5 angle)) m)))
      (pfill! quat
              (* (pref v 0) s) (* (pref v 1) s) (* (pref v 2) s)
              (cos (* 0.5 angle)))
      void)))

(bind-poly vaquat vaquatd)
(bind-poly vaquat vaquatf)


;;;;;;;;;; MATRIX ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; matrix functions
;;
;; there are obviously faster options (such as linking to BLAS or
;; LAPACK or the like), but these ones are nice if you want to keep
;; everything in xtlang.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; helper functions for calculating row/column major indices - you
;; probably don't want to use these in hot loops (it is a function
;; call, after all) but if performance isn't an issue they can be
;; handy to have around. and you can always turn them into macros

(bind-func colmaj_idx_2
  (lambda (x:i64 y ydim)
    (+ (* x ydim) y)))

(bind-func colmaj_idx_3
  (lambda (x:i64 y z ydim zdim)
    (+ (* x ydim zdim) (* y zdim) z)))

(bind-poly colmaj_idx colmaj_idx_2)
(bind-poly colmaj_idx colmaj_idx_3)

(bind-func rowmaj_idx_2
  (lambda (x:i64 y xdim)
    (+ x (* y xdim))))

(bind-func rowmaj_idx_3
  (lambda (x:i64 y z xdim ydim)
    (+ x (* y xdim) (* z xdim ydim))))

(bind-poly rowmaj_idx rowmaj_idx_2)
(bind-poly rowmaj_idx rowmaj_idx_3)

;; 'pretty' print matrix (doubles)
(bind-func mprintd
  (lambda (m:double* r:i64 c:i64 col_major:i1)
    (let ((i 0) (j 0)
          ;; helper closure for calculating offset
          (idx (if col_major
                   (lambdas (x2:i64 y2:i64)
                            (+ (* x2 r) y2))
                   (lambdas (x1:i64 y1:i64)
                            (+ x1 (* y1 c))))))
      (printf "[")
      (dotimes (j r)
        (printf "[")
        (dotimes (i c)
          (printf " %f" (pref m (idx i j))))
        (printf " ]"))
      (printf "]")
      void)))
      

;; 'pretty' print matrix (floats)
(bind-func mprintf
  (lambda (m:float* r:i64 c:i64 col_major:i1)
    (let ((i 0) (j 0)
          ;; helper closure for calculating offset
          (idx (if col_major
                   (lambdas (x2:i64 y2:i64)
                            (+ (* x2 r) y2))
                   (lambdas (x1:i64 y1:i64)
                            (+ x1 (* y1 c))))))
      (printf "[")
      (dotimes (j r)
        (printf "[")
        (dotimes (i c)
          (printf " %f" (ftod (pref m (idx i j)))))
        (printf " ]"))
      (printf "]")
      void)))

;; 'pretty' print matrix (i64)
(bind-func mprinti64
  (lambda (m:i64* r:i64 c:i64 col_major:i1)
    (let ((i 0) (j 0)
          ;; helper closure for calculating offset
          (idx (if col_major
                   (lambdas (x2:i64 y2:i64)
                            (+ (* x2 r) y2))
                   (lambdas (x1:i64 y1:i64)
                            (+ x1 (* y1 c))))))
      (printf "[")
      (dotimes (j r)
        (printf "[")
        (dotimes (i c)
          (printf "% lld" (pref m (idx i j))))
        (printf " ]"))
      (printf "]")
      void)))

;; 'pretty' print matrix (i32)
(bind-func mprinti32
  (lambda (m:i32* r:i64 c:i64 col_major:i1)
    (let ((i 0) (j 0)
          ;; helper closure for calculating offset
          (idx (if col_major
                   (lambdas (x2:i64 y2:i64)
                            (+ (* x2 r) y2))
                   (lambdas (x1:i64 y1:i64)
                            (+ x1 (* y1 c))))))
      (printf "[")
      (dotimes (j r)
        (printf "[")
        (dotimes (i c)
          (printf " %d" (pref m (idx i j))))
        (printf " ]"))
      (printf "]")
      void)))


(bind-poly mprint mprintd)
(bind-poly mprint mprintf)
(bind-poly mprint mprinti64)
(bind-poly mprint mprinti32)

;; matrix multiplication (doubles)
(bind-func mmuld
  (lambda (ma:double* r1:i64 c1:i64 mb:double* r2:i64 c2:i64 mc:double*)
    (if (= c1 r2)
        (let ((r 0) (c 0) (k 0))
          (dotimes (r r1)
            (dotimes (c c2)
              (pset! mc (+ c (* r c2)) 0.0)
              (dotimes (k c1)
                (pset! mc (+ c (* r c2))
                       (+ (pref mc (+ c (* r c2)))
                          (* (pref ma (+ k (* r c1)))
                             (pref mb (+ (* k c2) c))))))))
          mc)
        (begin (printf "bad matrix multiplication [%lld,%lld]*[%lld,%lld]\n"
                       r1 c1 r2 c2)
               (cast null double*)))))

;; matrix multiplication (floats)
(bind-func mmulf
  (lambda (ma:float* r1:i64 c1:i64 mb:float* r2:i64 c2:i64 mc:float*)
    (if (= c1 r2)
        (let ((r 0) (c 0) (k 0))
          (dotimes (r r1)
            (dotimes (c c2)
              (pset! mc (+ c (* r c2)) 0.0)
              (dotimes (k c1)
                (pset! mc (+ c (* r c2))
                       (+ (pref mc (+ c (* r c2)))
                          (* (pref ma (+ k (* r c1)))
                             (pref mb (+ (* k c2) c))))))))
          mc)
        (begin (printf "bad matrix multiplication [%lld,%lld]*[%lld,%lld]\n"
                       r1 c1 r2 c2)
               (cast null float*)))))

;; matrix multiplication (i64)
(bind-func mmuli64
  (lambda (ma:i64* r1:i64 c1:i64 mb:i64* r2:i64 c2:i64 mc:i64*)
    (if (= c1 r2)
        (let ((r 0) (c 0) (k 0))
          (dotimes (r r1)
            (dotimes (c c2)
              (pset! mc (+ c (* r c2)) 0)
              (dotimes (k c1)
                (pset! mc (+ c (* r c2))
                       (+ (pref mc (+ c (* r c2)))
                          (* (pref ma (+ k (* r c1)))
                             (pref mb (+ (* k c2) c))))))))
          mc)
        (begin (printf "bad matrix multiplication [%lld,%lld]*[%lld,%lld]\n"
                       r1 c1 r2 c2)
               (cast null i64*)))))

;; matrix multiplication (i32)
(bind-func mmuli32
  (lambda (ma:i32* r1:i64 c1:i64 mb:i32* r2:i64 c2:i64 mc:i32*)
    (if (= c1 r2)
        (let ((r 0) (c 0) (k 0))
          (dotimes (r r1)
            (dotimes (c c2)
              (pset! mc (+ c (* r c2)) 0)
              (dotimes (k c1)
                (pset! mc (+ c (* r c2))
                       (+ (pref mc (+ c (* r c2)))
                          (* (pref ma (+ k (* r c1)))
                             (pref mb (+ (* k c2) c))))))))
          mc)
        (begin (printf "bad matrix multiplication [%lld,%lld]*[%lld,%lld]\n"
                       r1 c1 r2 c2)
               (cast null i32*)))))


;; optimized 4x4 matrix only!!!
;; NEED TO ALSO DO integers and doubles!!
(bind-func mmul4f
  (lambda (ma:float* mb:float* mc:float*)
    (let ((row1:/4,float/* (cast (pref-ptr mb 0)))
          (row2:/4,float/* (cast (pref-ptr mb 4)))
          (row3:/4,float/* (cast (pref-ptr mb 8)))
          (row4:/4,float/* (cast (pref-ptr mb 12)))
          (out:/4,float/* (cast mc))
          (tmp:/4,float/* null) (i 0))
      (dotimes (i 4)
        (set! tmp (cast (pref-ptr ma (* 4 i))))
        (let ((a (vshuffle tmp null 0 0 0 0))
              (b (vshuffle tmp null 1 1 1 1))
              (c (vshuffle tmp null 2 2 2 2))
              (d (vshuffle tmp null 3 3 3 3)))
          (pset! out i
                 (+ (+ (* a row1)
                       (* b row2))
                    (+ (* c row3)
                       (* d row4))))))
      mc)))


(bind-poly mmul mmuld)
(bind-poly mmul mmulf)
(bind-poly mmul mmuli64)
(bind-poly mmul mmuli32)
(bind-poly mmul4 mmul4f)

;; matrix transposition (doubles)
(bind-func mtransd
  (lambda (ma:double* r1:i64 c1:i64 mb:double*)
    (let ((i 0) (j 0))
      (dotimes (i r1)
        (dotimes (j c1)
          (pset! mb (+ (* j c1) i)
                 (pref ma (+ (* i c1) j)))))
      mb)))

;; matrix transposition (floats)
(bind-func mtransf
  (lambda (ma:float* r1:i64 c1:i64 mb:float*)
    (let ((i 0) (j 0))
      (dotimes (i r1)
        (dotimes (j c1)
          (pset! mb (+ (* j c1) i)
                 (pref ma (+ (* i c1) j)))))
      mb)))

(bind-poly mtrans mtransd)
(bind-poly mtrans mtransf)

;; determinant (doubles)
;; k is for sqr matrix
(bind-func mdetrmd
  (lambda (ma:double* k:i64)
    (if (= k 1) (pref ma 0)
        (let ((det:double 0.0) (s:double 1.0)
              (c 0) (i 0) (j 0) (m 0) (n 0)
              (mb:double* (salloc (* k k))))
          (dotimes (c k)
            (set! m 0) (set! n 0)
            (dotimes (i k)
              (dotimes (j k)
                (pset! mb (+ (* i k) j) 0.0)
                (if (and (<> i 0) (<> j c))
                    (begin
                      (pset! mb (+ (* m (- k 1)) n)
                             (pref ma (+ (* i k) j)))
                      (if (< n (- k 2))
                          (set! n (+ n 1))
                          (begin
                            (set! n 0)
                            (set! m (+ m 1)))))
                    (begin 1))))
            (set! det (+ det (* s (* (pref ma c)
                                     (mdetrmd mb (- k 1))))))
            (set! s (* -1.0 s)))
          det))))

;; determinant (floats)
;; k is for sqr matrix
(bind-func mdetrmf
  (lambda (ma:float* k:i64)
    (if (= k 1) (pref ma 0)
        (let ((det:float 0.0) (s:float 1.0)
              (c 0) (i 0) (j 0) (m 0) (n 0)
              (mb:float* (salloc (* k k))))
          (dotimes (c k)
            (set! m 0) (set! n 0)
            (dotimes (i k)
              (dotimes (j k)
                (pset! mb (+ (* i k) j) 0.0)
                (if (and (<> i 0) (<> j c))
                    (begin
                      (pset! mb (+ (* m (- k 1)) n)
                             (pref ma (+ (* i k) j)))
                      (if (< n (- k 2))
                          (set! n (+ n 1))
                          (begin
                            (set! n 0)
                            (set! m (+ m 1)))))
                    (begin 1))))
            (set! det (+ det (* s (* (pref ma c)
                                     (mdetrmf mb (- k 1))))))
            (set! s (* -1.0 s)))
          det))))

(bind-poly mdetrm mdetrmd)
(bind-poly mdetrm mdetrmf)

;; invert matrix (doubles)
(bind-func minvd
  (lambda (ma:double* k:i64 inv:double*)
    (let ((mb:double* (salloc (* k k)))
          (fac:double* (salloc (* k k)))
          (d:double 0.0)
          (i 0) (j 0) (m 0) (n 0) (q:i64 0) (p:i64 0))
      (dotimes (q k)
        (dotimes (p k)
          (set! m 0)
          (set! n 0)
          (dotimes (i k)
            (dotimes (j k)
              (pset! mb (+ (* i k) j) 0.0)
              (if (and (<> i q) (<> j p))
                  (begin
                    (pset! mb (+ (* m (- k 1)) n)
                           (pref ma (+ (* i k) j)))
                    (if (< n (- k 2))
                        (set! n (+ n 1))
                        (begin
                          (set! n 0)
                          (set! m (+ m 1)))))
                  (begin 1))))
          (pset! fac (+ (* q k) p)
                 (* (pow -1.0 (i64tod (+ q p)))
                    (mdetrmd mb (- k 1))))))
      (dotimes (i k)
        (dotimes (j k)
          (pset! mb (+ (* i k) j)
                 (pref fac (+ (* j k) i)))))
      (set! d (mdetrmd ma k))
      (dotimes (i k)
        (dotimes (j k)
          (pset! inv (+ (* i k) j)
                 (/ (pref mb (+ (* i k) j)) d))))
      void)))

;; invert matrix (floats)
(bind-func minvf
  (lambda (ma:float* k:i64 inv:float*)
    (let ((mb:float* (salloc (* k k)))
          (fac:float* (salloc (* k k)))
          (d:float 0.0)
          (i 0) (j 0) (m 0) (n 0) (q:i64 0) (p:i64 0))
      (dotimes (q k)
        (dotimes (p k)
          (set! m 0)
          (set! n 0)
          (dotimes (i k)
            (dotimes (j k)
              (pset! mb (+ (* i k) j) 0.0)
              (if (and (<> i q) (<> j p))
                  (begin
                    (pset! mb (+ (* m (- k 1)) n)
                           (pref ma (+ (* i k) j)))
                    (if (< n (- k 2))
                        (set! n (+ n 1))
                        (begin
                          (set! n 0)
                          (set! m (+ m 1)))))
                  (begin 1))))
          (pset! fac (+ (* q k) p)
                 (* (pow (dtof -1.0) (i64tof (+ q p)))
                    (mdetrmf mb (- k 1))))))

      (dotimes (i k)
        (dotimes (j k)
          (pset! mb (+ (* i k) j)
                 (pref fac (+ (* j k) i)))))
      (set! d (mdetrmf ma k))
      (dotimes (i k)
        (dotimes (j k)
          (pset! inv (+ (* i k) j)
                 (/ (pref mb (+ (* i k) j)) d))))
      void)))

;; poly to minv
(bind-poly minv minvd)
(bind-poly minv minvf)

(bind-func mcopyf
  (lambda (m1:float* row col m2:float*)
    (memcpy (cast m2 i8*) (cast m1 i8*) (* row col 4))
    void))

(bind-func mcopyd
  (lambda (m1:double* row col m2:double*)
    (memcpy (cast m2 i8*) (cast m1 i8*) (* row col 8))
    void))

(bind-poly mcopy mcopyf)
(bind-poly mcopy mcopyd)

;; some helpful matrix builders
;;
;; axis is the unit vector
;; around which you want to rotate
;;
;; column major!
;;
;; mat is a pointer to memory to
;; store the 4x4 matrix in
(bind-func rot_matrix_about_axis_d
  (lambda (theta:double axis:double* mat:double*)
    (let ((x (pref axis 0))
          (y (pref axis 1))
          (z (pref axis 2))
          (cost (cos theta))
          (sint (sin theta))
          (mcost (- 1.0 cost)))
      (pset! mat 0 (+ cost (* (* x x) mcost)))
      (pset! mat 1 (+ (* (* y x) mcost) (* z sint)))
      (pset! mat 2 (- (* (* z x) mcost) (* y sint)))
      (pset! mat 3 0.0)
      (pset! mat 4 (- (* (* x y) mcost) (* z sint)))
      (pset! mat 5 (+ cost (* (* y y) mcost)))
      (pset! mat 6 (+ (* (* z y) mcost) (* x sint)))
      (pset! mat 7 0.0)      
      (pset! mat 8 (+ (* (* x z) mcost) (* y sint)))
      (pset! mat 9 (- (* (* y z) mcost) (* x sint)))
      (pset! mat 10 (+ cost (* (* z z) mcost)))
      (pset! mat 11 0.0)
      (pset! mat 12 0.0)
      (pset! mat 13 0.0)
      (pset! mat 14 0.0)
      (pset! mat 15 1.0)      
      mat)))

;; some helpful matrix builders
;;
;; axis is the unit vector
;; around which you want to rotate
;;
;; column major!
;;
;; mat is a pointer to memory to
;; store the 4x4 matrix in
(bind-func rot_matrix_about_axis_f
  (lambda (theta:float axis:float* mat:float*)
    (let ((x (pref axis 0))
          (y (pref axis 1))
          (z (pref axis 2))
          (cost (cos theta))
          (sint (sin theta))
          (mcost (- 1.0 cost)))
      (pset! mat 0 (+ cost (* (* x x) mcost)))
      (pset! mat 1 (+ (* (* y x) mcost) (* z sint)))
      (pset! mat 2 (- (* (* z x) mcost) (* y sint)))
      (pset! mat 3 0.0)
      (pset! mat 4 (- (* (* x y) mcost) (* z sint)))
      (pset! mat 5 (+ cost (* (* y y) mcost)))
      (pset! mat 6 (+ (* (* z y) mcost) (* x sint)))
      (pset! mat 7 0.0)      
      (pset! mat 8 (+ (* (* x z) mcost) (* y sint)))
      (pset! mat 9 (- (* (* y z) mcost) (* x sint)))
      (pset! mat 10 (+ cost (* (* z z) mcost)))
      (pset! mat 11 0.0)
      (pset! mat 12 0.0)
      (pset! mat 13 0.0)
      (pset! mat 14 0.0)
      (pset! mat 15 1.0)
      mat)))

(bind-poly rot_matrix_about_axis rot_matrix_about_axis_d)
(bind-poly rot_matrix_about_axis rot_matrix_about_axis_f)


;;;;;;;;;; RATIONAL NUMBERS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; xtlang's rational number types and helper functions
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(bind-type Rational <i64,i64>)

(bind-func Rat
  (lambda (a b)
    (if (< b 0)
        (begin (set! a (* -1 a))
               (set! b (* -1 b))))
    (let ((r:Rational* (salloc)))
      (tset! r 0 a)
      (tset! r 1 b)
      (pref r 0))))

(bind-func Rational_greatest_common_divisor
  (lambda (m:i64 n:i64)
    (if (and (= m 0) (= n 0))
        -1
        (let ((r 0))
          (if (< m 0) (set! m (* m -1)))
          (if (< n 0) (set! n (* n -1)))
          (while (not (= n 0))
            (set! r (% m n))
            (set! m n)
            (set! n r))
          m))))

(bind-func Rational_reduce
  (lambda (a:Rational)
    (let ((gcd (Rational_greatest_common_divisor (tref a 0)
                                            (tref a 1))))
      (Rat (/ (tref a 0) gcd)
           (/ (tref a 1) gcd)))))

(bind-func Rational_print
  (lambda (x:Rational)
    (let ((reduced (Rational_reduce x)))
      (printf "%lld/%lld" (tref reduced 0) (tref reduced 1))) void))

(bind-poly print Rational_print)

;; conversion

(bind-func rtod
  (lambda (a:Rational)
    (/ (i64tod (tref a 0)) (i64tod (tref a 1)))))

(bind-func rtof
  (lambda (a:Rational)
    (/ (i64tof (tref a 0)) (i64tof (tref a 1)))))

(bind-func rtoi64
  (lambda (a:Rational)
    (dtoi64 (rtod a))))

(bind-func rtoi32
  (lambda (a:Rational)
    (dtoi32 (rtod a))))

(bind-func rtoi16
  (lambda (a:Rational)
    (dtoi16 (rtod a))))

(bind-func rtoi8
  (lambda (a:Rational)
    (dtoi8 (rtod a))))

(bind-func rtoi1
  (lambda (a:Rational)
    (dtoi1 (rtod a))))

;; multiplication

(bind-func Rational_mul_rat_rat
  (lambda (a:Rational b:Rational)
    (Rational_reduce
     (Rat (* (tref a 0) (tref b 0))
          (* (tref a 1) (tref b 1))))))

(bind-func Rational_mul_rat_i64
  (lambda (a:Rational b:i64)
    (Rat (* (tref a 0) b) (* (tref a 1) 1))))

(bind-func Rational_mul_i64_rat
  (lambda (b:i64 a:Rational)
    (Rat (* (tref a 0) b) (* (tref a 1) 1))))

(bind-func Rational_mul_rat_i32
  (lambda (a:Rational b:i32)
    (Rat (* (tref a 0) (i32toi64 b)) (* (tref a 1) 1))))

(bind-func Rational_mul_i32_rat
  (lambda (b:i32 a:Rational)
    (Rat (* (tref a 0) (i32toi64 b)) (* (tref a 1) 1))))

(bind-func Rational_mul_rat_i8
  (lambda (a:Rational b:i8)
    (Rat (* (tref a 0) (i8toi64 b)) (* (tref a 1) 1))))

(bind-func Rational_mul_i8_rat
  (lambda (b:i8 a:Rational)
    (Rat (* (tref a 0) (i8toi64 b)) (* (tref a 1) 1))))

(bind-func Rational_mul_rat_i1
  (lambda (a:Rational b:i1)
    (Rat (* (tref a 0) (i1toi64 b)) (* (tref a 1) 1))))

(bind-func Rational_mul_i1_rat
  (lambda (b:i1 a:Rational)
    (Rat (* (tref a 0) (i1toi64 b)) (* (tref a 1) 1))))

(bind-func Rational_mul_rat_d
  (lambda (a:Rational b:double)
    (* b (/ (convert (tref a 0) double) (convert (tref a 1) double)))))

(bind-func Rational_mul_d_rat
  (lambda (b:double a:Rational)
    (* b (/ (convert (tref a 0) double) (convert (tref a 1) double)))))

(bind-func Rational_mul_rat_f
  (lambda (a:Rational b:float)
    (* b (/ (convert (tref a 0) float) (convert (tref a 1) float)))))

(bind-func Rational_mul_f_rat
  (lambda (b:float a:Rational)
    (* b (/ (convert (tref a 0) float) (convert (tref a 1) float)))))

(bind-poly xtm_multiplication Rational_mul_rat_rat)
(bind-poly xtm_multiplication Rational_mul_rat_i64)
(bind-poly xtm_multiplication Rational_mul_i64_rat)
(bind-poly xtm_multiplication Rational_mul_rat_i32)
(bind-poly xtm_multiplication Rational_mul_i32_rat)
(bind-poly xtm_multiplication Rational_mul_rat_i8)
(bind-poly xtm_multiplication Rational_mul_i8_rat)
(bind-poly xtm_multiplication Rational_mul_rat_i1)
(bind-poly xtm_multiplication Rational_mul_i1_rat)
(bind-poly xtm_multiplication Rational_mul_rat_d)
(bind-poly xtm_multiplication Rational_mul_d_rat)
(bind-poly xtm_multiplication Rational_mul_rat_f)
(bind-poly xtm_multiplication Rational_mul_f_rat)

(bind-func Rational_div_rat_rat
  (lambda (a:Rational b:Rational)
    (Rational_reduce
     (Rat (* (tref a 0) (tref b 1))
          (* (tref a 1) (tref b 0))))))

(bind-func Rational_div_rat_i64
  (lambda (a:Rational b:i64)
    (Rat (* (tref a 0) b) (* (tref a 1) 1))))

(bind-func Rational_div_i64_rat
  (lambda (a:i64 b:Rational)
    (Rat (* (tref b 1) a) (* (tref b 0) 1))))

(bind-func Rational_div_rat_i32
  (lambda (a:Rational b:i32)
    (Rat (* (tref a 0) (i32toi64 b)) (* (tref a 1) 1))))

(bind-func Rational_div_i32_rat
  (lambda (a:i32 b:Rational)
    (Rat (* (tref b 1) (i32toi64 a)) (* (tref b 0) 1))))

(bind-func Rational_div_rat_i8
  (lambda (a:Rational b:i8)
    (Rat (* (tref a 0) (i8toi64 b)) (* (tref a 1) 1))))

(bind-func Rational_div_i8_rat
  (lambda (a:i8 b:Rational)
    (Rat (* (tref b 1) (i8toi64 a)) (* (tref b 0) 1))))

(bind-func Rational_div_rat_i1
  (lambda (a:Rational b:i1)
    (Rat (* (tref a 0) (i1toi64 b)) (* (tref a 1) 1))))

(bind-func Rational_div_i1_rat
  (lambda (a:i1 b:Rational)
    (Rat (* (tref b 1) (i1toi64 a)) (* (tref b 0) 1))))

(bind-func Rational_div_rat_d
  (lambda (a:Rational b:double)
    (/ (/ (convert (tref a 0) double) (convert (tref a 1) double)) b)))

(bind-func Rational_div_d_rat
  (lambda (b:double a:Rational)
    (/ (/ (convert (tref a 0) double) (convert (tref a 1) double)) b)))

(bind-func Rational_div_rat_f
  (lambda (a:Rational b:float)
    (/ (/ (convert (tref a 0) float) (convert (tref a 1) float)) b)))

(bind-func Rational_div_f_rat
  (lambda (b:float a:Rational)
    (/ (/ (convert (tref a 0) float) (convert (tref a 1) float)) b)))

(bind-poly xtm_division Rational_div_rat_rat)
(bind-poly xtm_division Rational_div_rat_i64)
(bind-poly xtm_division Rational_div_i64_rat)
(bind-poly xtm_division Rational_div_rat_i32)
(bind-poly xtm_division Rational_div_i32_rat)
(bind-poly xtm_division Rational_div_rat_i8)
(bind-poly xtm_division Rational_div_i8_rat)
(bind-poly xtm_division Rational_div_rat_i1)
(bind-poly xtm_division Rational_div_i1_rat)
(bind-poly xtm_division Rational_div_rat_d)
(bind-poly xtm_division Rational_div_d_rat)
(bind-poly xtm_division Rational_div_rat_f)
(bind-poly xtm_division Rational_div_f_rat)

;; Rational addition

(bind-func Rational_add_rat_rat
  (lambda (a:Rational b:Rational)
    (let ((denom_a (tref a 1))
          (denom_b (tref b 1)))
      (Rational_reduce
       (Rat (+ (* (tref a 0) denom_b) (* (tref b 0) denom_a))
            (* denom_a denom_b))))))

(bind-func Rational_add_rat_i64
  (lambda (a:Rational b:i64)
    (Rat (+ (tref a 0) (* (tref a 1) b)) (tref a 1))))

(bind-func Rational_add_i64_rat
  (lambda (b:i64 a:Rational)
    (Rat (+ (tref a 0) (* (tref a 1) b)) (tref a 1))))

(bind-func Rational_add_rat_i32
  (lambda (a:Rational b:i32)
    (Rat (+ (tref a 0) (* (tref a 1) (i32toi64 b))) (tref a 1))))

(bind-func Rational_add_i32_rat
  (lambda (b:i32 a:Rational)
    (Rat (+ (tref a 0) (* (tref a 1) (i32toi64 b))) (tref a 1))))

(bind-func Rational_add_rat_i8
  (lambda (a:Rational b:i8)
    (Rat (+ (tref a 0) (* (tref a 1) (i8toi64 b))) (tref a 1))))

(bind-func Rational_add_i8_rat
  (lambda (b:i8 a:Rational)
    (Rat (+ (tref a 0) (* (tref a 1) (i8toi64 b))) (tref a 1))))

(bind-func Rational_add_rat_i1
  (lambda (a:Rational b:i1)
    (Rat (+ (tref a 0) (* (tref a 1) (i1toi64 b))) (tref a 1))))

(bind-func Rational_add_i1_rat
  (lambda (b:i1 a:Rational)
    (Rat (+ (tref a 0) (* (tref a 1) (i1toi64 b))) (tref a 1))))

(bind-func Rational_add_rat_d
  (lambda (a:Rational b:double)
    (+ (/ (convert (tref a 0) double) (convert (tref a 1) double)) b)))

(bind-func Rational_add_d_rat
  (lambda (b:double a:Rational)
    (+ (/ (convert (tref a 0) double) (convert (tref a 1) double)) b)))

(bind-func Rational_add_rat_f
  (lambda (a:Rational b:float)
    (+ (/ (convert (tref a 0) float) (convert (tref a 1) float)) b)))

(bind-func Rational_add_f_rat
  (lambda (b:float a:Rational)
    (+ (/ (convert (tref a 0) float) (convert (tref a 1) float)) b)))

(bind-poly xtm_addition Rational_add_rat_rat)
(bind-poly xtm_addition Rational_add_rat_i64)
(bind-poly xtm_addition Rational_add_i64_rat)
(bind-poly xtm_addition Rational_add_rat_i32)
(bind-poly xtm_addition Rational_add_i32_rat)
(bind-poly xtm_addition Rational_add_rat_i8)
(bind-poly xtm_addition Rational_add_i8_rat)
(bind-poly xtm_addition Rational_add_rat_i1)
(bind-poly xtm_addition Rational_add_i1_rat)
(bind-poly xtm_addition Rational_add_rat_d)
(bind-poly xtm_addition Rational_add_d_rat)
(bind-poly xtm_addition Rational_add_rat_f)
(bind-poly xtm_addition Rational_add_f_rat)

;; Rational subtraction

(bind-func Rational_subtract_rat_rat
  (lambda (a:Rational b:Rational)
    (let ((denom_a (tref a 1))
          (denom_b (tref b 1)))
      (Rational_reduce
       (Rat (- (* (tref a 0) denom_b) (* (tref b 0) denom_a))
            (* denom_a denom_b))))))

(bind-func Rational_subtract_rat_i64
  (lambda (a:Rational b:i64)
    (Rat (- (tref a 0) (* (tref a 1) b)) (tref a 1))))

(bind-func Rational_subtract_i64_rat
  (lambda (b:i64 a:Rational)
    (Rat (- (tref a 0) (* (tref a 1) b)) (tref a 1))))

(bind-func Rational_subtract_rat_i32
  (lambda (a:Rational b:i32)
    (Rat (- (tref a 0) (* (tref a 1) (i32toi64 b))) (tref a 1))))

(bind-func Rational_subtract_i32_rat
  (lambda (b:i32 a:Rational)
    (Rat (- (tref a 0) (* (tref a 1) (i32toi64 b))) (tref a 1))))

(bind-func Rational_subtract_rat_i8
  (lambda (a:Rational b:i8)
    (Rat (- (tref a 0) (* (tref a 1) (i8toi64 b))) (tref a 1))))

(bind-func Rational_subtract_i8_rat
  (lambda (b:i8 a:Rational)
    (Rat (- (tref a 0) (* (tref a 1) (i8toi64 b))) (tref a 1))))

(bind-func Rational_subtract_rat_i1
  (lambda (a:Rational b:i1)
    (Rat (- (tref a 0) (* (tref a 1) (i1toi64 b))) (tref a 1))))

(bind-func Rational_subtract_i1_rat
  (lambda (b:i1 a:Rational)
    (Rat (- (tref a 0) (* (tref a 1) (i1toi64 b))) (tref a 1))))

(bind-func Rational_subtract_rat_d
  (lambda (a:Rational b:double)
    (- (/ (convert (tref a 0) double) (convert (tref a 1) double)) b)))

(bind-func Rational_subtract_d_rat
  (lambda (b:double a:Rational)
    (- (/ (convert (tref a 0) double) (convert (tref a 1) double)) b)))

(bind-func Rational_subtract_rat_f
  (lambda (a:Rational b:float)
    (- (/ (convert (tref a 0) float) (convert (tref a 1) float)) b)))

(bind-func Rational_subtract_f_rat
  (lambda (b:float a:Rational)
    (- (/ (convert (tref a 0) float) (convert (tref a 1) float)) b)))

(bind-poly xtm_subtraction Rational_subtract_rat_rat)
(bind-poly xtm_subtraction Rational_subtract_rat_i64)
(bind-poly xtm_subtraction Rational_subtract_i64_rat)
(bind-poly xtm_subtraction Rational_subtract_rat_i32)
(bind-poly xtm_subtraction Rational_subtract_i32_rat)
(bind-poly xtm_subtraction Rational_subtract_rat_i8)
(bind-poly xtm_subtraction Rational_subtract_i8_rat)
(bind-poly xtm_subtraction Rational_subtract_rat_i1)
(bind-poly xtm_subtraction Rational_subtract_i1_rat)
(bind-poly xtm_subtraction Rational_subtract_rat_d)
(bind-poly xtm_subtraction Rational_subtract_d_rat)
(bind-poly xtm_subtraction Rational_subtract_rat_f)
(bind-poly xtm_subtraction Rational_subtract_f_rat)

;; Rational equality

(bind-func Rational_equal_rat_rat
  (lambda (a:Rational b:Rational)
    (let ((reduced_a (Rational_reduce a))
          (reduced_b (Rational_reduce b)))
      (and (= (tref reduced_a 0)
              (tref reduced_b 0))
           (= (tref reduced_a 1)
              (tref reduced_b 1))))))

(bind-func Rational_equal_rat_i64
  (lambda (a:Rational b:i64)
    (Rational_equal_rat_rat a (Rat b 1))))

(bind-func Rational_equal_i64_rat
  (lambda (b:i64 a:Rational)
    (Rational_equal_rat_rat (Rat b 1) a)))

(bind-func Rational_equal_rat_i32
  (lambda (a:Rational b:i32)
    (Rational_equal_rat_rat a (Rat (i32toi64 b) 1))))

(bind-func Rational_equal_i32_rat
  (lambda (b:i32 a:Rational)
    (Rational_equal_rat_rat (Rat (i32toi64 b) 1) a)))

(bind-func Rational_equal_rat_i8
  (lambda (a:Rational b:i8)
    (Rational_equal_rat_rat a (Rat (i8toi64 b) 1))))

(bind-func Rational_equal_i8_rat
  (lambda (b:i8 a:Rational)
    (Rational_equal_rat_rat (Rat (i8toi64 b) 1) a)))

(bind-func Rational_equal_rat_i1
  (lambda (a:Rational b:i1)
    (Rational_equal_rat_rat a (Rat (i1toi64 b) 1))))

(bind-func Rational_equal_i1_rat
  (lambda (b:i1 a:Rational)
    (Rational_equal_rat_rat (Rat (i1toi64 b) 1) a)))

(bind-poly xtm_equal Rational_equal_rat_rat)
(bind-poly xtm_equal Rational_equal_rat_i64)
(bind-poly xtm_equal Rational_equal_i64_rat)
(bind-poly xtm_equal Rational_equal_rat_i32)
(bind-poly xtm_equal Rational_equal_i32_rat)
(bind-poly xtm_equal Rational_equal_rat_i8)
(bind-poly xtm_equal Rational_equal_i8_rat)
(bind-poly xtm_equal Rational_equal_rat_i1)
(bind-poly xtm_equal Rational_equal_i1_rat)

;; Rational inequality

(bind-func Rational_notequal_rat_rat
  (lambda (a:Rational b:Rational)
    (let ((reduced_a (Rational_reduce a))
          (reduced_b (Rational_reduce b)))
      (or (<> (tref reduced_a 0)
              (tref reduced_b 0))
          (<> (tref reduced_a 1)
              (tref reduced_b 1))))))

(bind-func Rational_notequal_rat_i64
  (lambda (a:Rational b:i64)
    (Rational_notequal_rat_rat a (Rat b 1))))

(bind-func Rational_notequal_i64_rat
  (lambda (b:i64 a:Rational)
    (Rational_notequal_rat_rat (Rat b 1) a)))

(bind-func Rational_notequal_rat_i32
  (lambda (a:Rational b:i32)
    (Rational_notequal_rat_rat a (Rat (i32toi64 b) 1))))

(bind-func Rational_notequal_i32_rat
  (lambda (b:i32 a:Rational)
    (Rational_notequal_rat_rat (Rat (i32toi64 b) 1) a)))

(bind-func Rational_notequal_rat_i8
  (lambda (a:Rational b:i8)
    (Rational_notequal_rat_rat a (Rat (i8toi64 b) 1))))

(bind-func Rational_notequal_i8_rat
  (lambda (b:i8 a:Rational)
    (Rational_notequal_rat_rat (Rat (i8toi64 b) 1) a)))

(bind-func Rational_notequal_rat_i1
  (lambda (a:Rational b:i1)
    (Rational_notequal_rat_rat a (Rat (i1toi64 b) 1))))

(bind-func Rational_notequal_i1_rat
  (lambda (b:i1 a:Rational)
    (Rational_notequal_rat_rat (Rat (i1toi64 b) 1) a)))

(bind-poly xtm_notequal Rational_notequal_rat_rat)
(bind-poly xtm_notequal Rational_notequal_rat_i64)
(bind-poly xtm_notequal Rational_notequal_i64_rat)
(bind-poly xtm_notequal Rational_notequal_rat_i32)
(bind-poly xtm_notequal Rational_notequal_i32_rat)
(bind-poly xtm_notequal Rational_notequal_rat_i8)
(bind-poly xtm_notequal Rational_notequal_i8_rat)
(bind-poly xtm_notequal Rational_notequal_rat_i1)
(bind-poly xtm_notequal Rational_notequal_i1_rat)

;; Rational lessthan

(bind-func Rational_lessthan_rat_rat
  (lambda (a:Rational b:Rational)
    (< (* (tref a 0) (tref b 1))
       (* (tref b 0) (tref a 1)))))

(bind-func Rational_lessthan_rat_i64
  (lambda (a:Rational b:i64)
    (< (tref a 0) (* b (tref a 1)))))

(bind-func Rational_lessthan_i64_rat
  (lambda (b:i64 a:Rational)
    (< (tref a 0) (* b (tref a 1)))))

(bind-func Rational_lessthan_rat_i32
  (lambda (a:Rational b:i32)
    (< (tref a 0) (* (i32toi64 b) (tref a 1)))))

(bind-func Rational_lessthan_i32_rat
  (lambda (b:i32 a:Rational)
    (< (tref a 0) (* (i32toi64 b) (tref a 1)))))

(bind-func Rational_lessthan_rat_i8
  (lambda (a:Rational b:i8)
    (< (tref a 0) (* (i8toi64 b) (tref a 1)))))

(bind-func Rational_lessthan_i8_rat
  (lambda (b:i8 a:Rational)
    (< (tref a 0) (* (i8toi64 b) (tref a 1)))))

(bind-func Rational_lessthan_rat_i1
  (lambda (a:Rational b:i1)
    (< (tref a 0) (* (i1toi64 b) (tref a 1)))))

(bind-func Rational_lessthan_i1_rat
  (lambda (b:i1 a:Rational)
    (< (tref a 0) (* (i1toi64 b) (tref a 1)))))

(bind-poly xtm_lessthan Rational_lessthan_rat_rat)
(bind-poly xtm_lessthan Rational_lessthan_rat_i64)
(bind-poly xtm_lessthan Rational_lessthan_i64_rat)
(bind-poly xtm_lessthan Rational_lessthan_rat_i32)
(bind-poly xtm_lessthan Rational_lessthan_i32_rat)
(bind-poly xtm_lessthan Rational_lessthan_rat_i8)
(bind-poly xtm_lessthan Rational_lessthan_i8_rat)
(bind-poly xtm_lessthan Rational_lessthan_rat_i1)
(bind-poly xtm_lessthan Rational_lessthan_i1_rat)

;; Rational greaterthan

(bind-func Rational_greaterthan_rat_rat
  (lambda (a:Rational b:Rational)
    (> (* (tref a 0) (tref b 1))
       (* (tref b 0) (tref a 1)))))

(bind-func Rational_greaterthan_rat_i64
  (lambda (a:Rational b:i64)
    (> (tref a 0) (* b (tref a 1)))))

(bind-func Rational_greaterthan_i64_rat
  (lambda (b:i64 a:Rational)
    (> (tref a 0) (* b (tref a 1)))))

(bind-func Rational_greaterthan_rat_i32
  (lambda (a:Rational b:i32)
    (> (tref a 0) (* (i32toi64 b) (tref a 1)))))

(bind-func Rational_greaterthan_i32_rat
  (lambda (b:i32 a:Rational)
    (> (tref a 0) (* (i32toi64 b) (tref a 1)))))

(bind-func Rational_greaterthan_rat_i8
  (lambda (a:Rational b:i8)
    (> (tref a 0) (* (i8toi64 b) (tref a 1)))))

(bind-func Rational_greaterthan_i8_rat
  (lambda (b:i8 a:Rational)
    (> (tref a 0) (* (i8toi64 b) (tref a 1)))))

(bind-func Rational_greaterthan_rat_i1
  (lambda (a:Rational b:i1)
    (> (tref a 0) (* (i1toi64 b) (tref a 1)))))

(bind-func Rational_greaterthan_i1_rat
  (lambda (b:i1 a:Rational)
    (> (tref a 0) (* (i1toi64 b) (tref a 1)))))

(bind-poly xtm_greaterthan Rational_greaterthan_rat_rat)
(bind-poly xtm_greaterthan Rational_greaterthan_rat_i64)
(bind-poly xtm_greaterthan Rational_greaterthan_i64_rat)
(bind-poly xtm_greaterthan Rational_greaterthan_rat_i32)
(bind-poly xtm_greaterthan Rational_greaterthan_i32_rat)
(bind-poly xtm_greaterthan Rational_greaterthan_rat_i8)
(bind-poly xtm_greaterthan Rational_greaterthan_i8_rat)
(bind-poly xtm_greaterthan Rational_greaterthan_rat_i1)
(bind-poly xtm_greaterthan Rational_greaterthan_i1_rat)

(bind-func Rational_modulo_rat_rat
  (lambda (a:Rational b:Rational)
    (let ((c (/ a b))
          (n (Rat (% (tref c 0) (tref c 1)) (tref c 1))))
      (* b n))))

(bind-func Rational_modulo_rat_i64
  (lambda (a:Rational b:i64)
    (Rational_modulo_rat_rat a (Rat b 1))))

(bind-func Rational_modulo_i64_rat
  (lambda (a:i64 b:Rational)
    (Rational_modulo_rat_rat (Rat a 1) b)))

(bind-func Rational_modulo_rat_i32
  (lambda (a:Rational b:i32)
    (Rational_modulo_rat_rat a (Rat (i32toi64 b) 1))))

(bind-func Rational_modulo_i32_rat
  (lambda (a:i32 b:Rational)
    (Rational_modulo_rat_rat (Rat (i32toi64 a) 1) b)))

(bind-func Rational_modulo_rat_i8
  (lambda (a:Rational b:i8)
    (Rational_modulo_rat_rat a (Rat (i8toi64 b) 1))))

(bind-func Rational_modulo_i8_rat
  (lambda (a:i8 b:Rational)
    (Rational_modulo_rat_rat (Rat (i8toi64 a) 1) b)))

(bind-poly xtm_modulo Rational_modulo_rat_rat)
(bind-poly xtm_modulo Rational_modulo_rat_i64)
(bind-poly xtm_modulo Rational_modulo_i64_rat)
(bind-poly xtm_modulo Rational_modulo_rat_i32)
(bind-poly xtm_modulo Rational_modulo_i32_rat)
(bind-poly xtm_modulo Rational_modulo_rat_i8)
(bind-poly xtm_modulo Rational_modulo_i8_rat)

;;;;;;;;;; COMPLEX NUMBERS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; xtlang's complex number types and helper functions
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Complexd (double versions)

(bind-type Complexd <double,double>)

(bind-func Cpxd
  (lambda (re im)
    (let ((c:Complexd* (salloc)))
      (tset! c 0 re)
      (tset! c 1 im)
      (pref c 0))))

(bind-func Complexd_print
  "specialised print function for Complexd"
  (lambda (c:Complexd)
    (printf "%.2f%+.2fi"
            (tref c 0)
            (tref c 1))
    void))

(bind-func Complexd_ptr_print
  "specialised print function for Complexd*"
  (lambda (c:Complexd*)
    (if (null? c)
        (printf "<Complexd 0x0>")
        (printf "%.2f%+.2fi"
                (tref c 0)
                (tref c 1)))
    void))

(bind-func Complexd_toString
  "specialised toString function for Complexd"
  (lambda (c:Complexd)
    (let ((str:i8* (salloc 256)))
      (sprintf str "%.2f%+.2fi"
               (tref c 0)
               (tref c 1))
      (Str str))))

(bind-func Complexd_ptr_toString
  "specialised toString function for Complexd"
  (lambda (c:Complexd*)
    (let ((str:i8* (salloc 256)))
      (if (null? c)
          (sprintf str "<Complexd 0x0>")
          (sprintf str "%.2f%+.2fi"
                   (tref c 0)
                   (tref c 1)))
      (Str str))))

(bind-poly print Complexd_ptr_print)
(bind-poly print Complexd_print)
(bind-poly toString Complexd_ptr_toString)
(bind-poly toString Complexd_toString)

(bind-func Complexd_addition_cpx_cpx
  (lambda (a:Complexd b:Complexd)
    (Cpxd (+ (tref a 0) (tref b 0))
          (+ (tref a 1) (tref b 1)))))

(bind-func Complexd_addition_cpx_re
  (lambda (a:Complexd b:double)
    (Cpxd (+ (tref a 0) b)
          (tref a 1))))

(bind-func Complexd_addition_re_cpx
  (lambda (b:double a:Complexd)
    (Cpxd (+ (tref a 0) b)
          (tref a 1))))

(bind-func Complexd_addition_bybuf
  (lambda (a:Complexd* b:Complexd* c:Complexd* lgth)
    (let ((i 0))
      (dotimes (i lgth)
        (tset! (pref-ptr c i) 0
               (+ (tref (pref-ptr a i) 0)
                  (tref (pref-ptr b i) 0)))
        (tset! (pref-ptr c i) 1
               (+ (tref (pref-ptr a i) 1)
                  (tref (pref-ptr b i) 1))))
      void)))

(bind-poly xtm_addition Complexd_addition_cpx_cpx)
(bind-poly xtm_addition Complexd_addition_cpx_re)
(bind-poly xtm_addition Complexd_addition_re_cpx)
(bind-poly xtm_addition Complexd_addition_bybuf)

(bind-func Complexd_subtraction_cpx_cpx
  (lambda (a:Complexd b:Complexd)
    (Cpxd (- (tref a 0) (tref b 0))
          (- (tref a 1) (tref b 1)))))

(bind-func Complexd_subtraction_cpx_re
  (lambda (a:Complexd b:double)
    (Cpxd (- (tref a 0) b)
          (tref a 1))))

(bind-func Complexd_subtraction_re_cpx
  (lambda (b:double a:Complexd)
    (Cpxd (- (tref a 0) b)
          (tref a 1))))

(bind-func Complexd_subtraction_bybuf
  (lambda (a:Complexd* b:Complexd* c:Complexd* lgth)
    (let ((i 0))
      (dotimes (i lgth)
        (tset! (pref-ptr c i) 0
               (- (tref (pref-ptr a i) 0)
                  (tref (pref-ptr b i) 0)))
        (tset! (pref-ptr c i) 1
               (- (tref (pref-ptr a i) 1)
                  (tref (pref-ptr b i) 1))))
      void)))

(bind-poly xtm_subtraction Complexd_subtraction_cpx_cpx)
(bind-poly xtm_subtraction Complexd_subtraction_cpx_re)
(bind-poly xtm_subtraction Complexd_subtraction_re_cpx)
(bind-poly xtm_subtraction Complexd_subtraction_bybuf)

(bind-func Complexd_multiplication_cpx_cpx
  (lambda (a:Complexd b:Complexd)
    (Cpxd (- (* (tref a 0) (tref b 0))
             (* (tref a 1) (tref b 1)))             
          (+ (* (tref a 0) (tref b 1))
             (* (tref a 1) (tref b 0))))))

(bind-func Complexd_multiplication_cpx_re
  (lambda (a:Complexd b:double)
    (Cpxd (- (* (tref a 0) b)
             (tref a 1))             
          (+ (tref a 0)
             (* (tref a 1) b)))))

(bind-func Complexd_multiplication_re_cpx
  (lambda (b:double a:Complexd)
    (Cpxd (- (* (tref a 0) b)
             (tref a 1))             
          (+ (tref a 0)
             (* (tref a 1) b)))))

(bind-func Complexd_multiplication_bybuf
  (lambda (a:Complexd* b:Complexd* c:Complexd* lgth)
    (let ((i 0))
      (dotimes (i lgth)
        (tset! (pref-ptr c i) 0
               (- (* (tref (pref-ptr a i) 0)
                     (tref (pref-ptr b i) 0))
                  (* (tref (pref-ptr a i) 1)
                     (tref (pref-ptr b i) 1))))
        (tset! (pref-ptr c i) 1
               (+ (* (tref (pref-ptr a i) 0)
                     (tref (pref-ptr b i) 1))
                  (* (tref (pref-ptr a i) 1)
                     (tref (pref-ptr b i) 0)))))
      void)))

(bind-poly xtm_multiplication Complexd_multiplication_cpx_cpx)
(bind-poly xtm_multiplication Complexd_multiplication_cpx_re)
(bind-poly xtm_multiplication Complexd_multiplication_re_cpx)
(bind-poly xtm_multiplication Complexd_multiplication_bybuf)

(bind-func Complexd_division_cpx_cpx
  (lambda (a:Complexd b:Complexd)
    (let ((i (+ (* (tref a 0) (tref b 0))
                (* (tref a 1) (tref b 1))))
          (j (+ (* (tref b 0) (tref b 0))
                (* (tref b 1) (tref b 1))))
          (k (- (* (tref a 1) (tref b 0))
                (* (tref a 0) (tref b 1)))))
      (Cpxd (/ i j)
            (/ k j)))))

(bind-func Complexd_division_cpx_re
  (lambda (a:Complexd b:double)
    (let ((i (+ (* (tref a 0) b)
                (tref a 1)))
          (j (* b b))
          (k (- (* (tref a 1) b)
                (tref a 0) )))
      (Cpxd (/ i j)
            (/ k j)))))

(bind-func Complexd_division_re_cpx
  (lambda (b:double a:Complexd)
    (let ((i (+ (* (tref a 0) b)
                (tref a 1)))
          (j (* b b))
          (k (- (* (tref a 1) b)
                (tref a 0) )))
      (Cpxd (/ i j)
            (/ k j)))))

(bind-func Complexd_division_bybuf
  (lambda (a:Complexd* b:Complexd* c:Complexd* lgth)
    (let ((i 0) (j 0.0) (k 0.0) (l 0.0))
      (dotimes (i lgth)
        (set! j (+ (* (tref (pref-ptr a i) 0)
                      (tref (pref-ptr b i) 0))
                   (* (tref (pref-ptr a i) 1)
                      (tref (pref-ptr b i) 1))))
        (set! k (+ (* (tref (pref-ptr b i) 0)
                      (tref (pref-ptr b i) 0))
                   (* (tref (pref-ptr b i) 1)
                      (tref (pref-ptr b i) 1))))
        (set! l (- (* (tref (pref-ptr a i) 1)
                      (tref (pref-ptr b i) 0))
                   (* (tref (pref-ptr a i) 0)
                      (tref (pref-ptr b i) 1))))
        (tset! (pref-ptr c i) 0 (/ j k))
        (tset! (pref-ptr c i) 1 (/ l k)))
      void)))

(bind-poly xtm_division Complexd_division_cpx_cpx)
(bind-poly xtm_division Complexd_division_cpx_re)
(bind-poly xtm_division Complexd_division_re_cpx)
(bind-poly xtm_division Complexd_division_bybuf)

(bind-func Complexd_magnitude
  (lambda (a:Complexd)
    (sqrt (+ (* (tref a 0) (tref a 0))
             (* (tref a 1) (tref a 1))))))         

(bind-func Complexd_phase
  (lambda (a:Complexd)
    (atan (/ (tref a 1) (tref a 0)))))

(bind-func Complexd_conj
  (lambda (a:Complexd)
    (Cpxd (tref a 0)
          (* -1.0 (tref a 0)))))

(bind-poly Complex_mag Complexd_magnitude)
(bind-poly Complex_phase Complexd_phase)
(bind-poly Complex_conj Complexd_conj)

(bind-func Complexd_cart_to_pol
  (lambda (a:Complexd)
    (Cpxd (sqrt (+ (* (tref a 0) (tref a 0))
                   (* (tref a 1) (tref a 1))))
          (atan (/ (tref a 1) (tref a 0))))))

(bind-func Complexd_cart_to_pol_bybuf
  "transform a whole buffer cart->pol in-place"
  (lambda (a:Complexd* n:i64)
    (doloop (i n)
      (tset! (pref-ptr a i) 0
             (sqrt (+ (* (tref a 0) (tref a 0))
                      (* (tref a 1) (tref a 1)))))
      (tset! (pref-ptr a i) 1
             (atan (/ (tref a 1) (tref a 0)))))
    void))

(bind-poly Complex_cart_to_pol Complexd_cart_to_pol)
(bind-poly Complex_cart_to_pol Complexd_cart_to_pol_bybuf)

(bind-func Complexd_pol_to_cart
  (lambda (a:Complexd)
    (Cpxd (* (tref a 0) (cos (tref a 1)))
          (* (tref a 0) (sin (tref a 1))))))

(bind-func Complexd_pol_to_cart_bybuf
  "transform a whole buffer pol->cart in-place"
  (lambda (a:Complexd* n:i64)
    (doloop (i n)
      (tset! (pref-ptr a i) 0
             (* (tref a 0) (cos (tref a 1))))
      (tset! (pref-ptr a i) 1
             (* (tref a 0) (sin (tref a 1)))))
    void))

(bind-poly pol_to_cart Complexd_pol_to_cart)
(bind-poly pol_to_cart Complexd_pol_to_cart_bybuf)

;; Complexf (float versions)

(bind-type Complexf <float,float>)

(bind-func Cpxf
  (lambda (re im)
    (let ((c:Complexf* (salloc)))
      (tset! c 0 re)
      (tset! c 1 im)
      (pref c 0))))

(bind-func Complexf_print
  "specialised print function for Complexf"
  (lambda (c:Complexf)
    (printf "%.2f%+.2fi"
            (ftod (tref c 0))
            (ftod (tref c 1)))
    void))

(bind-func Complexf_ptr_print
  "specialised print function for Complexf*"
  (lambda (c:Complexf*)
    (if (null? c)
        (printf "<Complexf 0x0>")
        (printf "%.2f%+.2fi"
            (ftod (tref c 0))
            (ftod (tref c 1))))
    void))

(bind-func Complexf_toString
  "specialised toString function for Complexf"
  (lambda (c:Complexf)
    (let ((str:i8* (salloc 256)))
      (sprintf str "%.2f%+.2fi"
               (ftod (tref c 0))
               (ftod (tref c 1)))
      (Str str))))

(bind-func Complexf_ptr_toString
  "specialised toString function for Complexf"
  (lambda (c:Complexf*)
    (let ((str:i8* (salloc 256)))
      (if (null? c)
          (sprintf str "<Complexf 0x0>")
          (sprintf str "%.2f%+.2fi"
                   (ftod (tref c 0))
                   (ftod (tref c 1))))
      (Str str))))

(bind-poly print Complexf_ptr_print)
(bind-poly print Complexf_print)
(bind-poly toString Complexf_ptr_toString)
(bind-poly toString Complexf_toString)

(bind-func Complexf_addition_cpx_cpx
  (lambda (a:Complexf b:Complexf)
    (Cpxf (+ (tref a 0) (tref b 0))
          (+ (tref a 1) (tref b 1)))))

(bind-func Complexf_addition_cpx_re
  (lambda (a:Complexf b:float)
    (Cpxf (+ (tref a 0) b)
          (tref a 1))))

(bind-func Complexf_addition_re_cpx
  (lambda (b:float a:Complexf)
    (Cpxf (+ (tref a 0) b)
          (tref a 1))))

(bind-func Complexf_addition_bybuf
  (lambda (a:Complexf* b:Complexf* c:Complexf* lgth:i64)
    (if (evenp lgth)
        (let ((aa:/4,float/* (cast a))
              (bb:/4,float/* (cast b))
              (cc:/4,float/* (cast c))
              (k 0))
          (dotimes (k (/ lgth 2))
            (pset! cc k (+ (pref-ptr aa k) (pref-ptr bb k)))
            void))
        (let ((i 0))
          (dotimes (i lgth)
            (tset! (pref-ptr c i) 0
                   (+ (tref (pref-ptr a i) 0)
                      (tref (pref-ptr b i) 0)))
            (tset! (pref-ptr c i) 1
                   (+ (tref (pref-ptr a i) 1)
                      (tref (pref-ptr b i) 1))))
          void))))

(bind-poly xtm_addition Complexf_addition_cpx_cpx)
(bind-poly xtm_addition Complexf_addition_cpx_re)
(bind-poly xtm_addition Complexf_addition_re_cpx)
(bind-poly xtm_addition Complexf_addition_bybuf)

(bind-func Complexf_subtraction_cpx_cpx
  (lambda (a:Complexf b:Complexf)
    (Cpxf (- (tref a 0) (tref b 0))
          (- (tref a 1) (tref b 1)))))

(bind-func Complexf_subtraction_cpx_re
  (lambda (a:Complexf b:float)
    (Cpxf (- (tref a 0) b)
          (tref a 1))))

(bind-func Complexf_subtraction_re_cpx
  (lambda (b:float a:Complexf)
    (Cpxf (- (tref a 0) b)
          (tref a 1))))

(bind-func Complexf_subtraction_bybuf
  (lambda (a:Complexf* b:Complexf* c:Complexf* lgth:i64)
    (if (evenp lgth)
        (let ((aa:/4,float/* (cast a))
              (bb:/4,float/* (cast b))
              (cc:/4,float/* (cast c))
              (k 0))
          (dotimes (k (/ lgth 2))
            (pset! cc k (- (pref-ptr aa k) (pref-ptr bb k)))
            void))
        (let ((i 0))
          (dotimes (i lgth)
            (tset! (pref-ptr c i) 0
                   (- (tref (pref-ptr a i) 0)
                      (tref (pref-ptr b i) 0)))
            (tset! (pref-ptr c i) 1
                   (- (tref (pref-ptr a i) 1)
                      (tref (pref-ptr b i) 1))))
          void))))

(bind-poly xtm_subtraction Complexf_subtraction_cpx_cpx)
(bind-poly xtm_subtraction Complexf_subtraction_cpx_re)
(bind-poly xtm_subtraction Complexf_subtraction_re_cpx)
(bind-poly xtm_subtraction Complexf_subtraction_bybuf)

(bind-func Complexf_multiplication_cpx_cpx
  (lambda (a:Complexf b:Complexf)
    (Cpxf (- (* (tref a 0) (tref b 0))
             (* (tref a 1) (tref b 1)))             
          (+ (* (tref a 0) (tref b 1))
             (* (tref a 1) (tref b 0))))))

(bind-func Complexf_multiplication_cpx_re
  (lambda (a:Complexf b:float)
    (Cpxf (- (* (tref a 0) b)
             (tref a 1))             
          (+ (tref a 0)
             (* (tref a 1) b)))))

(bind-func Complexf_multiplication_re_cpx
  (lambda (b:float a:Complexf)
    (Cpxf (- (* (tref a 0) b)
             (tref a 1))             
          (+ (tref a 0)
             (* (tref a 1) b)))))

(bind-func Complexf_multiplication_bybuf
  (let ((dd:/4,float/* (alloc)))
    (vfill! dd -1.0 1.0 -1.0 1.0)
    (lambda (a:Complexf* b:Complexf* c:Complexf* lgth:i64)
      (if (evenp lgth)
          (let ((j 0)
                (aa:/4,float/* (cast a))
                (bb:/4,float/* (cast b))
                (cc:/4,float/* (cast c)))
            (dotimes (j (/ lgth 2))
              (pset! cc j
                     (+ (* (vshuffle (pref-ptr aa j) null 0 0 2 2)
                           (vshuffle (pref-ptr bb j) null 0 1 2 3))
                        (* (* (vshuffle (pref-ptr aa j) null 1 1 3 3)
                              (vshuffle (pref-ptr bb j) null 1 0 3 2))
                           dd))))
            void)
          (let ((i 0))
            (dotimes (i lgth)
              (tset! (pref-ptr c i) 0
                     (- (* (tref (pref-ptr a i) 0)
                           (tref (pref-ptr b i) 0))
                        (* (tref (pref-ptr a i) 1)
                           (tref (pref-ptr b i) 1))))
              (tset! (pref-ptr c i) 1
                     (+ (* (tref (pref-ptr a i) 0)
                           (tref (pref-ptr b i) 1))
                        (* (tref (pref-ptr a i) 1)
                           (tref (pref-ptr b i) 0)))))
            void)))))

(bind-poly xtm_multiplication Complexf_multiplication_cpx_cpx)
(bind-poly xtm_multiplication Complexf_multiplication_cpx_re)
(bind-poly xtm_multiplication Complexf_multiplication_re_cpx)
(bind-poly xtm_multiplication Complexf_multiplication_bybuf)

(bind-func Complexf_division_cpx_cpx
  (lambda (a:Complexf b:Complexf)
    (let ((i (+ (* (tref a 0) (tref b 0))
                (* (tref a 1) (tref b 1))))
          (j (+ (* (tref b 0) (tref b 0))
                (* (tref b 1) (tref b 1))))
          (k (- (* (tref a 1) (tref b 0))
                (* (tref a 0) (tref b 1)))))
      (Cpxf (/ i j)
            (/ k j)))))

(bind-func Complexf_division_cpx_re
  (lambda (a:Complexf b:float)
    (let ((i (+ (* (tref a 0) b)
                (tref a 1)))
          (j (* b b))
          (k (- (* (tref a 1) b)
                (tref a 0) )))
      (Cpxf (/ i j)
            (/ k j)))))

(bind-func Complexf_division_re_cpx
  (lambda (b:float a:Complexf)
    (let ((i (+ (* (tref a 0) b)
                (tref a 1)))
          (j (* b b))
          (k (- (* (tref a 1) b)
                (tref a 0) )))
      (Cpxf (/ i j)
            (/ k j)))))

(bind-func Complexf_division_bybuf
  (lambda (a:Complexf* b:Complexf* c:Complexf* lgth)
    (let ((i 0) (j 0.0) (k 0.0) (l 0.0))
      (dotimes (i lgth)
        (set! j (+ (* (tref (pref-ptr a i) 0)
                      (tref (pref-ptr b i) 0))
                   (* (tref (pref-ptr a i) 1)
                      (tref (pref-ptr b i) 1))))
        (set! k (+ (* (tref (pref-ptr b i) 0)
                      (tref (pref-ptr b i) 0))
                   (* (tref (pref-ptr b i) 1)
                      (tref (pref-ptr b i) 1))))
        (set! l (- (* (tref (pref-ptr a i) 1)
                      (tref (pref-ptr b i) 0))
                   (* (tref (pref-ptr a i) 0)
                      (tref (pref-ptr b i) 1))))
        (tset! (pref-ptr c i) 0 (/ j k))
        (tset! (pref-ptr c i) 1 (/ l k)))
      void)))

(bind-poly xtm_division Complexf_division_cpx_cpx)
(bind-poly xtm_division Complexf_division_cpx_re)
(bind-poly xtm_division Complexf_division_re_cpx)
(bind-poly xtm_division Complexf_division_bybuf)

(bind-func Complexf_magnitude
  (lambda (a:Complexf)
    (sqrt (+ (* (tref a 0) (tref a 0))
             (* (tref a 1) (tref a 1))))))         

(bind-func Complexf_phase
  (lambda (a:Complexf)
    (atan (/ (tref a 1) (tref a 0)))))

(bind-func Complexf_conj
  (lambda (a:Complexf)
    (Cpxf (tref a 0)
          (* -1.0 (tref a 0)))))

(bind-poly Complex_mag Complexf_magnitude)
(bind-poly Complex_phase Complexf_phase)
(bind-poly Complex_conj Complexf_conj)

(bind-func Complexf_cart_to_pol
  (lambda (a:Complexf)
    (Cpxf (sqrt (+ (* (tref a 0) (tref a 0))
                   (* (tref a 1) (tref a 1))))
          (atan (/ (tref a 1) (tref a 0))))))

(bind-func Complexf_cart_to_pol_bybuf
  "transform a whole buffer cart->pol in-place"
  (lambda (a:Complexf* n:i64)
    (doloop (i n)
      (tset! (pref-ptr a i) 0
             (sqrt (+ (* (tref a 0) (tref a 0))
                      (* (tref a 1) (tref a 1)))))
      (tset! (pref-ptr a i) 1
             (atan (/ (tref a 1) (tref a 0)))))
    void))

(bind-poly Complexf_cart_to_pol Complexf_cart_to_pol)
(bind-poly Complexf_cart_to_pol Complexf_cart_to_pol_bybuf)

(bind-func Complexf_pol_to_cart
  (lambda (a:Complexf)
    (Cpxf (* (tref a 0) (cos (tref a 1)))
          (* (tref a 0) (sin (tref a 1))))))

(bind-func Complexf_pol_to_cart_bybuf
  "transform a whole buffer pol->cart in-place"
  (lambda (a:Complexf* n:i64)
    (doloop (i n)
      (tset! (pref-ptr a i) 0
             (* (tref a 0) (cos (tref a 1))))
      (tset! (pref-ptr a i) 1
             (* (tref a 0) (sin (tref a 1)))))
    void))

(bind-poly Complexf_pol_to_cart Complexf_pol_to_cart)
(bind-poly Complexf_pol_to_cart Complexf_pol_to_cart_bybuf)

;; "bufferize" whole buffers of real & complex values (take two real
;; buffers with real & imaginary components, fill buffer of Complex
;; values)

(bind-func Complexf_bufferize_re_im
  (lambda (re:float* im:float* com:Complexf* len:i64)
    (let ((i 0))
      (dotimes (i len)
        (tset! (pref-ptr com i) 0 (pref re i))
        (tset! (pref-ptr com i) 1 (pref im i))))
    void))

(bind-func Complexf_bufferize_reonly
  (lambda (re:float* com:Complexf* len:i64)
    (let ((i 0))
      (dotimes (i len)
        (tset! (pref-ptr com i) 0 (pref re i))
        (tset! (pref-ptr com i) 1 0.0)))
    void))

(bind-func Complexd_bufferize_re_im
  (lambda (re:double* im:double* com:Complexd* len:i64)
    (let ((i 0))
      (dotimes (i len)
        (tset! (pref-ptr com i) 0 (pref re i))
        (tset! (pref-ptr com i) 1 (pref im i))))
    void))

(bind-func Complexd_bufferize_reonly
  (lambda (re:double* com:Complexd* len:i64)
    (let ((i 0))
      (dotimes (i len)
        (tset! (pref-ptr com i) 0 (pref re i))
        (tset! (pref-ptr com i) 1 0.0)))
    void))

(bind-poly Complex_bufferize Complexf_bufferize_re_im)
(bind-poly Complex_bufferize Complexd_bufferize_re_im)
(bind-poly Complex_bufferize Complexf_bufferize_reonly)
(bind-poly Complex_bufferize Complexd_bufferize_reonly)

;; do the opposite (take buffer of Complex, fill two real buffers with
;; real & imaginary components)

(bind-func Complexf_unbufferize_re_im
  (lambda (com:Complexf* re:float* im:float* len:i64)
    (let ((i 0))
      (dotimes (i len)
        (pset! re i (tref (pref-ptr com i) 0)) 
        (pset! im i (tref (pref-ptr com i) 1))))
    void))

(bind-func Complexf_unbufferize_reonly
  (lambda (com:Complexf* re:float* len:i64)
    (let ((i 0))
      (dotimes (i len)
        (pset! re i (tref (pref-ptr com i) 0)) ))
    void))

(bind-func Complexd_unbufferize_re_im
  (lambda (com:Complexd* re:double* im:double* len:i64)
    (let ((i 0))
      (dotimes (i len)
        (pset! re i (tref (pref-ptr com i) 0))
        (pset! im i (tref (pref-ptr com i) 1))))
    void))

(bind-func Complexd_unbufferize_reonly
  (lambda (com:Complexd* re:double* len:i64)
    (let ((i 0))
      (dotimes (i len)
        (pset! re i (tref (pref-ptr com i) 0)) ))
    void))

(bind-poly Complex_unbufferize Complexf_unbufferize_re_im)
(bind-poly Complex_unbufferize Complexd_unbufferize_re_im)
(bind-poly Complex_unbufferize Complexf_unbufferize_reonly)
(bind-poly Complex_unbufferize Complexd_unbufferize_reonly)

;;;;;;;;;; DFT/IDFT for teaching purposes ;;;;;;;;;;;;;;;;

;; real in -> complex out
(bind-func dft
  (lambda (in:double* out:Complexd* lgth)
    (let ((n:i64 0) (k:i64 0) (tmp 0.0) (cpx:Complexd* null) (N (i64tod lgth)))
      (memset (cast out i8*) 0 (convert (* lgth 16)))
      (dotimes (k lgth)
        (set! cpx (pref-ptr out k))
        (dotimes (n lgth)
          (set! tmp (* (i64tod (* k n)) (/ TWOPI N)))
          (tset! cpx 0
                 (+ (tref cpx 0)
                    (* (pref in n) (cos tmp))))
          (tset! cpx 1
                 (- (tref cpx 1)
                    (* (pref in n) (sin tmp))))))
      void)))

;; complex in -> real out
(bind-func idft
  (lambda (in:Complexd* out:double* lgth)
    (let ((n:i64 0) (k:i64 0) (tmp 0.0) (cpx:Complexd* null) (N (i64tod lgth)))
      (dotimes (n lgth)
        (pset! out n 0.0)
        (dotimes (k lgth)
          (set! cpx (pref-ptr in k))
          (set! tmp (* (i64tod (* k n)) (/ TWOPI N)))
          (pset! out n
                 (+ (pref out n)
                    (- (* (tref cpx 0) (cos tmp))
                       (* (tref cpx 1) (sin tmp))))))
        ;; scale
        (pset! out n (/ (pref out n) N)))
      void)))

;;;;;;;;;; WINDOWING ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(bind-func window_hanning_d
  (let ((i:i64 0))
    (lambda (window_buffer:double* window_length)
      (dotimes (i window_length)
        (pset! window_buffer i
               (* (pref window_buffer i)
                  (- 0.5 (* 0.5 (cos (/ (* TWOPI (i64tod i))
                                        (i64tod (- window_length 1)))))))))
      void)))

(bind-func window_hanning_f
  (let ((i:i64 0))
    (lambda (window_buffer:float* window_length)
      (dotimes (i window_length)
        (pset! window_buffer i
               (* (pref window_buffer i)
                  (- 0.5 (* 0.5 (cos (/ (* TWOPIf (i64tof i))
                                        (i64tof (- window_length 1)))))))))
      void)))

(bind-poly window_hanning window_hanning_d)
(bind-poly window_hanning window_hanning_f)

;; where t is time between [0.0 - 1.0]
(bind-func hanning
  (lambda (t)
    (- 0.5 (* 0.5
              (cos (* TWOPI t))))))

(bind-func window_hamming_d
  (let ((i:i64 0))
    (lambda (window_buffer:double* window_length)
      (dotimes (i window_length)
        (pset! window_buffer i
               (* (pref window_buffer i)
                  (- 0.54 (* 0.46 (cos (/ (* TWOPI (i64tod i))
                                          (i64tod (- window_length 1)))))))))
      void)))

(bind-func window_hamming_f
  (let ((i:i64 0))
    (lambda (window_buffer:float* window_length)
      (dotimes (i window_length)
        (pset! window_buffer i
               (* (pref window_buffer i)
                  (- 0.54 (* 0.46 (cos (/ (* TWOPIf (i64tof i))
                                          (i64tof (- window_length 1)))))))))
      void)))

(bind-poly window_hamming window_hamming_d)
(bind-poly window_hamming window_hamming_f)

;; where to is [0.0 - 1.0]
(bind-func hamming
  (lambda (t)
    (- 0.54 (* 0.46 (cos (* TWOPI t))))))

;;;;;;; string hashing functions ;;;;;;;;;

(bind-func djb2
  (lambda (str:i8*)
    (let ((hash:i64 5381)
          (len (strlen str))
          (i 0))
      (dotimes (i len)
        (set! hash (+ (<< hash 5) hash (convert (pref str i)))))
      hash)))

(bind-func sdbm
  (lambda (str:i8*)
    (let ((hash:i64 0)
          (len (strlen str))
          (i 0))
      (dotimes (i len)
        (set! hash (- (+ (convert (pref str i)) (<< hash 6) (<< hash 16)) hash)))
      hash)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; data buffer packing/unpacking ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; other naming options: sparse/dense, stride/unstride

(bind-func data_unpack_float
  "take a packed float* buffer and copy it into a sparse representation"
  (lambda (dest:float* src:float* stride neighbors srclen)
    (doloop (i srclen)
      (doloop (j neighbors)
        (pset! dest (+ (* stride i) j) (pref src (+ (* neighbors i) j)))))))

(bind-func data_unpack_double
  "take a packed double* buffer and copy it into a sparse representation"
  (lambda (dest:double* src:double* stride neighbors srclen)
    (doloop (i srclen)
      (doloop (j neighbors)
        (pset! dest (+ (* stride i) j) (pref src (+ (* neighbors i) j)))))))

(bind-poly data_unpack data_unpack_float)
(bind-poly data_unpack data_unpack_double)

(bind-func data_pack_float
  "take a sparse float* buffer and copy it into a packed representation"
  (lambda (dest:float* src:float* stride neighbors srclen)
    (doloop (i srclen)
      (doloop (j neighbors)
        (pset! dest (+ (* neighbors i) j) (pref src (+ (* stride i) j)))))))

(bind-func data_pack_double
  "take a sparse double* buffer and copy it into a packed representation"
  (lambda (dest:double* src:double* stride neighbors srclen)
    (doloop (i srclen)
      (doloop (j neighbors)
        (pset! dest (+ (* neighbors i) j) (pref src (+ (* stride i) j)))))))

(bind-poly data_pack data_pack_float)
(bind-poly data_pack data_pack_double)

(bind-func data_print_float
  "print a packed float* buffer"
  (lambda (buf:float* buflen ncols)
    (doloop (i buflen)
      (printf "buf[%lld] = %.4f " i (convert (pref buf i) double))
      (if (= (% i ncols) (- ncols 1))
          (println)))
    (println)))

(bind-func data_print_float_onecol
  "print a packed float* buffer"
  (lambda (buf buflen)
    (data_print_float buf buflen 1)))

(bind-func data_print_double
  "print a packed double* buffer"
  (lambda (buf:double* buflen ncols)
    (doloop (i buflen)
      (printf "buf[%lld] = %.4f " i (pref buf i))
      (if (= (% i ncols) (- ncols 1))
          (println)))
    (println)))

(bind-func data_print_double_onecol
  "print a packed double* buffer"
  (lambda (buf buflen)
    (data_print_float buf buflen 1)))

(bind-poly data_print data_print_float)
(bind-poly data_print data_print_float_onecol)
(bind-poly data_print data_print_double)
(bind-poly data_print data_print_double_onecol)

;;;;;;;;;;;;;;;
;; histogram ;;
;;;;;;;;;;;;;;;

;; currently uses floating-point values, i32 counts

(bind-type HistBin <float,float>
  "a histogram bin: <lower,count>")

(bind-func HistBin_print
  "specialised print function for HistBin*"
  (lambda (histbin:HistBin*)
    (if (null? histbin)
        (printf "<HistBin 0x0>")
        (printf "<HistBin %p minval=%f count=%f>"
                histbin
                (convert (tref histbin 0) double)
                (convert (tref histbin 1) double)))
    void))

(bind-poly print HistBin_print)

(bind-func HistBin_toString
  "specialised toString function for HistBin*"
  (lambda (histbin:HistBin*)
    (let ((str:i8* (salloc 256)))
      (if (null? histbin)
          (sprintf str "<HistBin 0x0>")
          
          (sprintf str
                   "<HistBin %p minval=%f count=%f>"
                   histbin
                   (convert (tref histbin 0) double)
                   (convert (tref histbin 1) double)))
      (Str str))))

(bind-poly toString HistBin_toString)

(bind-func histogram_float_full
  (lambda (hist:HistBin* buf:float* buflen lower upper nbins)
    (let ((current_bin:HistBin* null)
          (range (- upper lower)))
      (if (not (> range 0.))
          (begin
            (println "Error in histogram: range (- upper lower) must be greater than 0.0")
            null)
          (begin
            ;; setup the bins
            (doloop (i nbins)
              (tset! (pref-ptr hist i)
                     0
                     (+ lower (* (convert i) (/ range (convert nbins)))))
              (tset! (pref-ptr hist i)
                     1
                     0.))
            (doloop (i buflen)
              (set! current_bin
                    ;; use "mod nbins" to make sure it always goes
                    ;; into a valid slot in memory
                    (pref-ptr hist (% (convert (* (convert nbins float) (/ (- (pref buf i) lower) range)) i64) nbins)))
              (tset! current_bin 1 (+ (tref current_bin 1) 1.0)))
            hist)))))

(bind-func histogram_float_range
  "like the full version, but use the min and max values in the buffer as upper and lower"
  (lambda (hist:HistBin* buf:float* buflen nbins)
    (let ((lower 0.0)
          (upper 0.0))
      ;; find max/min values
      (doloop (i buflen)
        (if (< (pref buf i) lower)
            (set! lower (pref buf i)))
        (if (> (pref buf i) upper)
            (set! upper (pref buf i))))
      (histogram_float_full hist buf buflen lower upper nbins))))

(bind-poly histogram histogram_float_full)
(bind-poly histogram histogram_float_range)

;; end libs/core/math.xtm

(define *xtmlib-math-loaded* #t)
(impc:aot:insert-footer "xtmmath")
