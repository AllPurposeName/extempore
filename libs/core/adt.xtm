;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Extempore's data types library
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(bind-alias bool i1)

;;;;;;;;;;;;;;;;;;;;
;;

(bind-func xempty_p:[bool,!a]*
  (lambda (a)
    (if (null? a) #t #f)))


;;;;;;;;;;;;;;;;;;;;
;;
;; Boxing helpers
;;
;;;;;;;;;;;;;;;;;;;;

;; tag num and data
(bind-type xbox_t <i64,i8*,i8*>)

(bind-func xunboxi1:[i1,xbox_t*]*
  (lambda (box)
    (let ((key (tref box 0))
          (val (tref box 1)))
      ;;(if (<> 8 key) (printf "bad type conversion! from %lld->%lld!\n" key 8))
      (i64toi1 (ptrtoi64 val)))))

(bind-func xunboxi8:[i8,xbox_t*]*
  (lambda (box)
    (let ((key (tref box 0))
          (val (tref box 1)))
      ;;(if (<> 6 key) (printf "bad type conversion from %lld->%lld!\n" key 6))
      (i64toi8 (ptrtoi64 val)))))

(bind-func xunboxi32:[i32,xbox_t*]*
  (lambda (box)
    (let ((key (tref box 0))
          (val (tref box 1)))
      ;;(if (<> 4 key) (printf "bad type conversion from %lld->%lld!\n" key 4))
      (i64toi32 (ptrtoi64 val)))))

(bind-func xunboxi64:[i64,xbox_t*]*
  (lambda (box)
    (let ((key (tref box 0))
          (val (tref box 1)))
      ;;(if (<> 2 key) (printf "bad type conversion from %lld->%lld!\n" key 2))
      (ptrtoi64 val))))

(bind-func xunboxfloat:[float,xbox_t*]*
  (lambda (box)
    (let ((key (tref box 0))
          (val (tref box 1)))
      ;;(if (<> 1 key) (printf "bad type conversion from %lld->%lld!\n" key 1))
      (i64tof (ptrtoi64 val)))))

(bind-func xunboxdouble:[double,xbox_t*]*
  (lambda (box)
    (let ((key (tref box 0))
          (val (tref box 1)))
      ;;(if (<> 0 key) (printf "bad type conversion from %lld->%lld!\n" key 0))
      (i64tod (ptrtoi64 val)))))

(bind-func xunboxptr:[i8*,xbox_t*]*
  (lambda (box)
    (let ((key (tref box 0))
          (val (tref box 1)))
      ;;(if (<> -1 key) (printf "bad type conversion from %lld->%lld!\n" key -1))
      val)))

(bind-poly xunbox xunboxgen)
(bind-poly xunbox xunboxi1)
(bind-poly xunbox xunboxi8)
(bind-poly xunbox xunboxi32)
(bind-poly xunbox xunboxi64)
(bind-poly xunbox xunboxfloat)
(bind-poly xunbox xunboxdouble)
(bind-poly xunbox xunboxptr)
      

(bind-func xbox1:[xbox_t*,double]*
  (lambda (val)
    (let ((box:xbox_t* (halloc)))
      (tset! box 0 0)
      (tset! box 1 (i64toptr (dtoi64 val)))
      box)))

(bind-func xbox2:[xbox_t*,float]*
  (lambda (val)
    (let ((box:xbox_t* (halloc)))
      (tset! box 0 1)
      (tset! box 1 (i64toptr (ftoi64 val)))
      box)))

(bind-func xbox3:[xbox_t*,i64]*
  (lambda (val)
    (let ((box:xbox_t* (halloc)))
      (tset! box 0 2)
      (tset! box 1 (i64toptr val))
      box)))

(bind-func xbox4:[xbox_t*,i32]*
  (lambda (val)
    (let ((box:xbox_t* (halloc)))
      (tset! box 0 4)
      (tset! box 1 (i64toptr (i32toi64 val)))
      box)))

(bind-func xbox5:[xbox_t*,i8]*
  (lambda (val)
    (let ((box:xbox_t* (halloc)))
      (tset! box 0 6)
      (tset! box 1 (i64toptr (i8toi64 val)))
      box)))

(bind-func xbox6:[xbox_t*,i1]*
  (lambda (val)
    (let ((box:xbox_t* (halloc)))
      (tset! box 0 8)
      (tset! box 1 (i64toptr (i1toi64 val)))
      box)))

(bind-func xbox7:[xbox_t*,i8*]*
  (lambda (val)
    (let ((box:xbox_t* (halloc)))
      (tset! box 0 -1)
      (tset! box 1 val)
      box)))

(bind-func xbox8:[xbox_t*,i8*,i8*]*
  (lambda (val name)
    (let ((box:xbox_t* (halloc)))
      (tset! box 0 -1)
      (tset! box 1 val)
      (tset! box 2 name)      
      box)))

(bind-poly xbox xbox1)
(bind-poly xbox xbox2)
(bind-poly xbox xbox3)
(bind-poly xbox xbox4)
(bind-poly xbox xbox5)
(bind-poly xbox xbox6)
(bind-poly xbox xbox7)
(bind-poly xbox xbox8)


;;;;;;;;;;;;;;;;;;;;
;; pairs

(bind-type xpair_t <!first,!second>)

(bind-func xpair:[xpair_t*,!first,!second]*
  (lambda (a b)
    (let ((ppair (halloc)))
      (tset! ppair 0 a)
      (tset! ppair 1 b)
      ppair)))    

(bind-func xfirst:[!first,xpair_t*]*	   
  (lambda (a)
    (tref a 0)))

(bind-func xsecond:[!second,xpair_t*]*	   
  (lambda (a)
    (tref a 1)))


;;;;;;;;;;;;;;;;;;;;
;;
;; lists
;;

(bind-type xlist_t <!head,xlist_t*>)

(bind-func xjoin:[xlist_t*,!head,xlist_t*]*
  (lambda (a b)
    (let ((joinpair (halloc)))
      (tset! joinpair 0 a)
      (tset! joinpair 1 b)
      joinpair)))

(bind-func xhead:[!head,xlist_t*]*
  (lambda (a)
    (tref a 0)))

(bind-func xtail:[xlist_t*,xlist_t*]*
  (lambda (a)
    (tref a 1)))

;; macro list builder
(define-macro (xlist . args)
  (let loop ((lst args))
    (if (null? lst)
	'null
	`(xjoin ,(car lst) ,(loop (cdr lst))))))

(bind-func xlength:[i64,xlist_t*]*
  (lambda (a)    
    (if (null? a)
	0
	(+ 1 (xlength (xtail a))))))

(bind-func xnth_tail_:[xlist_t*,xlist_t*,i64,i64]*
  (lambda (lst idx cnt)
    (if (or (= cnt idx) (> cnt idx))
        lst
        (xnth_tail_ (xtail lst)
               idx
               (+ cnt 1)))))

(bind-func xnth_tail:[xlist_t*,xlist_t*,i64]*
  (lambda (lst idx)
    (xnth_tail_ lst idx 0)))

(bind-func xnth:[!a,xlist_t*,i64]*
  (lambda (lst idx)
    (xhead (xnth_tail lst idx))))

;; insert val into list at idx 

(bind-func xinsert:[xlist_t*,xlist_t*,i64,!a]*
  (lambda (lst idx value)
    (if (= idx 0)
        (xjoin value lst)
        (let ((pre_cell (xnth_tail lst (- idx 1)))
              (new_cell (xjoin value (xtail pre_cell))))
          (tset! pre_cell 1 new_cell)
          lst))))

;; ;; a macro for printing lists
;; (bind-func print_xlist:[i32,xlist_t*,i8*]*
;;   (lambda (lst format)
;;     (printf "%\n" )))

(bind-func xmap:[xlist_t%a*,[!head%a,!head%b]*,xlist_t%b*]*
  (lambda (func lst)
    (let ((f (lambda (l)
	       (if (null? l)
		   null
		   (xjoin (func (xhead l)) (f (xtail l)))))))
      (f lst))))

(bind-func xlast:[xlist_t*,xlist_t*]*
  (lambda (a)
    (if (null? (xtail a))
	a
	(xlast (xtail a)))))


(bind-func xappend:[xlist_t*,xlist_t*,xlist_t*]*
  (lambda (a b)
    (let ((p (xlast a)))
      (tset! p 1 b)
      a)))


;; (bind-func xreverse:[xlist_t*,xlist_t*]
;;   (lambda (a)
;;     (let ((rlist:xlist_t* (halloc)))
;;       ())))

;; xposition (nth)
;; xinsert
;; xsort
;; xsortedp
;; xdelete
;; xmember

;;;;;;;;;;;
;; TREES ;;
;;;;;;;;;;;

;; xlist_t*~i8* is specialised for <i8*,xlist_t*>*
(bind-type xtree_t <!value,i64,xlist_t*~i8*>)

(bind-func xtree:[xtree_t*,!value]*
  (lambda (a)
    (let ((tree (halloc)))
      (tset! tree 0 a)
      (tset! tree 1 (i32toi64 0))
      (tset! tree 2 (cast null xlist_t*~i8*))
      tree)))

(bind-func xtree_children:[i64,xtree_t*]*
  (lambda (t)
    (tref t 1)))

(bind-func xtree_value:[!value,xtree_t*]*
  (lambda (t)
    (tref t 0)))

(bind-func xtree_child:[xtree_t*,xtree_t*,i64]*
  (lambda (t n)
    (if (> (tref t 1) n)
        (xnth (cast (tref t 2) xlist_t*~i8*) n)
        null)))

(bind-func xtree_nodes:[xlist_t*,xtree_t*]*
  (lambda (t)
    (cast (tref t 2) xlist_t*~i8*)))

(bind-func xtree_add_child:[i64,xtree_t*,xtree_t*]*
  (lambda (parent child)
    (let ((children (tref parent 2))
          (newchildren (xjoin (cast child i8*) children)))
      (tset! parent 2 newchildren)
      (tset! parent 1 (+ 1 (tref parent 1)))
      (tref parent 1))))

(bind-func xtree_print_i64:[i32,xtree_t*]*
  (lambda (tree)
    (if (= (xtree_children tree) 0)
        (printf " %lld" (xtree_value tree))
        (begin (printf "\n%lld\n" (xtree_value tree))
               (xmap (lambda (t)
                      (xtree_print_i64 (cast t xtree_t*~i64)))
                     (xtree_nodes tree))
               (i64toi32 1)))))


;;;;;;;;;;;;;
;; STRINGS ;;
;;;;;;;;;;;;;

(bind-type xstring_t <i64,i8*>)

(bind-func xstring
  (lambda (s)
    (let ((str:xstring_t* (halloc))
          (lgth (strlen s))
          (news:i8* (halloc (+ 1 lgth))))
      (strcpy news s)
      (tset! str 0 (strlen s))
      (tset! str 1 news)
      str)))

(bind-func xstring_length
  (lambda (str:xstring_t*)
    (tref str 0)))

(bind-func xstring_cstr
  (lambda (str:xstring_t*)
    (tref str 1)))
