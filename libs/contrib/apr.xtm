;;; apr.xtm -- bindings for apache portable runtime

;; Author: Ben Swift
;; Keywords: extempore
;; Required dylibs: libapr

;;; Commentary:

;; This is based on the headers from APR, which is licenced thus:

;; /* Licensed to the Apache Software Foundation (ASF) under one or more
;;  * contributor license agreements.  See the NOTICE file distributed with
;;  * this work for additional information regarding copyright ownership.
;;  * The ASF licenses this file to You under the Apache License, Version 2.0
;;  * (the "License"); you may not use this file except in compliance with
;;  * the License.  You may obtain a copy of the License at
;;  *
;;  *     http://www.apache.org/licenses/LICENSE-2.0
;;  *
;;  * Unless required by applicable law or agreed to in writing, software
;;  * distributed under the License is distributed on an "AS IS" BASIS,
;;  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;  * See the License for the specific language governing permissions and
;;  * limitations under the License.
;;  */

;; Currently, we only bind the apr_file_io, apr_file_info and apr_env
;; headers, but we may expand our bindings in the future

;;; Code:

(sys:load "libs/aot-cache/apr.xtm" 'quiet)
(sys:load-preload-check 'apr)
(define *xtmlib-apr-loaded* #f)

(impc:aot:suppress-aot-do
 (sys:load "libs/core/std.xtm"))
(impc:aot:insert-forms
 (sys:load "libs/core/std.xtm" 'quiet))

(impc:aot:insert-header "xtmapr")

(bind-dylib libapr
  (cond ((string=? (sys:platform) "OSX") "libapr.dylib")
        ((string=? (sys:platform) "Linux") "libapr.so")
        ((string=? (sys:platform) "Windows") "libapr.dll")))

;;;;;;;;;;;;;;;;;;;
;; apr_file_io.h ;;
;;;;;;;;;;;;;;;;;;;

;; /**
;;  * @defgroup apr_file_io File I/O Handling Functions
;;  * @ingroup APR
;;  * @{
;;  */

;; /**
;;  * @defgroup apr_file_open_flags File Open Flags/Routines
;;  * @{
;;  */

;; /* Note to implementors: Values in the range 0x00100000--0x80000000
;;    are reserved for platform-specific values. */

(bind-val APR_FOPEN_READ i32 #x00001)
(bind-val APR_FOPEN_WRITE i32 #x00002)
(bind-val APR_FOPEN_CREATE i32 #x00004)
(bind-val APR_FOPEN_APPEND i32 #x00008)
(bind-val APR_FOPEN_TRUNCATE i32 #x00010)
                                      ;;    to 0 length */
(bind-val APR_FOPEN_BINARY i32 #x00020)
				   ;;       (This flag is ignored on UNIX
					 ;; because it has no meaning)*/
(bind-val APR_FOPEN_EXCL i32 #x00040)
                                      ;;    and file exists. */
(bind-val APR_FOPEN_BUFFERED i32 #x00080)
(bind-val APR_FOPEN_DELONCLOSE i32 #x00100)
(bind-val APR_FOPEN_XTHREAD i32 #x00200)
                                      ;;    the file for use across multiple
                                      ;;    threads */
(bind-val APR_FOPEN_SHARELOCK i32 #x00400)
                                      ;;    higher level locked read/write
                                      ;;    access to support writes across
                                      ;;    process/machines */
(bind-val APR_FOPEN_NOCLEANUP i32 #x00800)
           ;;                               when the file is opened. The
					 ;; apr_os_file_t handle in apr_file_t
					 ;; will not be closed when the pool
					 ;; is destroyed. */
(bind-val APR_FOPEN_SENDFILE_ENABLED i32 #x01000)
                                           ;;   file should support
                                           ;;   apr_socket_sendfile operation */
(bind-val APR_FOPEN_LARGEFILE i32 #x04000)
                                      ;;  * large file support, see WARNING below
                                      ;;  */
(bind-val APR_FOPEN_SPARSE i32 #x08000)
                                      ;;  * sparse file support, see WARNING below
                                      ;;  */
(bind-val APR_FOPEN_NONBLOCK i32 #x40000)
                                      ;;  * non blocking file io */

;; /** @def APR_FOPEN_LARGEFILE
;;  * @warning APR_FOPEN_LARGEFILE flag only has effect on some
;;  * platforms where sizeof(apr_off_t) == 4.  Where implemented, it
;;  * allows opening and writing to a file which exceeds the size which
;;  * can be represented by apr_off_t (2 gigabytes).  When a file's size
;;  * does exceed 2Gb, apr_file_info_get() will fail with an error on the
;;  * descriptor, likewise apr_stat()/apr_lstat() will fail on the
;;  * filename.  apr_dir_read() will fail with #APR_INCOMPLETE on a
;;  * directory entry for a large file depending on the particular
;;  * APR_FINFO_* flags.  Generally, it is not recommended to use this
;;  * flag.
;;  *
;;  * @def APR_FOPEN_SPARSE
;;  * @warning APR_FOPEN_SPARSE may, depending on platform, convert a
;;  * normal file to a sparse file.  Some applications may be unable
;;  * to decipher a sparse file, so it's critical that the sparse file
;;  * flag should only be used for files accessed only by APR or other
;;  * applications known to be able to decipher them.  APR does not
;;  * guarantee that it will compress the file into sparse segments
;;  * if it was previously created and written without the sparse flag.
;;  * On platforms which do not understand, or on file systems which
;;  * cannot handle sparse files, the flag is ignored by apr_file_open().
;;  *
;;  * @def APR_FOPEN_NONBLOCK
;;  * @warning APR_FOPEN_NONBLOCK is not implemented on all platforms.
;;  * Callers should be prepared for it to fail with #APR_ENOTIMPL.
;;  */

;; /** @} */

;; /**
;;  * @defgroup apr_file_seek_flags File Seek Flags
;;  * @{
;;  */

;; /* flags for apr_file_seek */
;; /** Set the file position */
(bind-val APR_SET i32 SEEK_SET)
;; /** Current */
(bind-val APR_CUR i32 SEEK_CUR)
;; /** Go to end of file */
(bind-val APR_END i32 SEEK_END)
;; /** @} */

;; /**
;;  * @defgroup apr_file_attrs_set_flags File Attribute Flags
;;  * @{
;;  */

;; /* flags for apr_file_attrs_set */
(bind-val APR_FILE_ATTR_READONLY i32 #x01)
(bind-val APR_FILE_ATTR_EXECUTABLE i32 #x02)
(bind-val APR_FILE_ATTR_HIDDEN i32 #x04)
;; /** @} */

;; /**
;;  * @defgroup apr_file_writev{_full} max iovec size
;;  * @{
;;  */
;; #if defined(DOXYGEN)
(bind-val APR_MAX_IOVEC_SIZE i32 1024)
                                               ;;      size of an iovec array */
;; #elif defined(IOV_MAX)
(bind-val APR_MAX_IOVEC_SIZE i32 IOV_MAX)
;; #elif defined(MAX_IOVEC)
(bind-val APR_MAX_IOVEC_SIZE i32 MAX_IOVEC)
;; #else
(bind-val APR_MAX_IOVEC_SIZE i32 1024)
;; #endif
;; /** @} */

;; /** File attributes */
(bind-alias apr_fileattrs_t apr_uint32_t)

;; /** Type to pass as whence argument to apr_file_seek. */
(bind-alias apr_seek_where_t i32)

;; /**
;;  * Structure for referencing files.
;;  */
(bind-alias apr_file_t apr_file_t)

;; /* File lock types/flags */
;; /**
;;  * @defgroup apr_file_lock_types File Lock Types
;;  * @{
;;  */

(bind-val APR_FLOCK_SHARED i32 1)
                                        ;;    or thread can hold a shared lock
                                        ;;    at any given time. Essentially,
                                        ;;    this is a "read lock", preventing
                                        ;;    writers from establishing an
                                        ;;    exclusive lock. */
(bind-val APR_FLOCK_EXCLUSIVE i32 2)
                                        ;;    may hold an exclusive lock at any
                                        ;;    given time. This is analogous to
                                        ;;    a "write lock". */

(bind-val APR_FLOCK_TYPEMASK i32 #x000F)
(bind-val APR_FLOCK_NONBLOCK i32 #x0010)
                                        ;;    file lock */
;; /** @} */

;; /**
;;  * Open the specified file.
;;  * @param newf The opened file descriptor.
;;  * @param fname The full path to the file (using / on all systems)
;;  * @param flag Or'ed value of:
;;  * @li #APR_FOPEN_READ           open for reading
;;  * @li #APR_FOPEN_WRITE          open for writing
;;  * @li #APR_FOPEN_CREATE         create the file if not there
;;  * @li #APR_FOPEN_APPEND         file ptr is set to end prior to all writes
;;  * @li #APR_FOPEN_TRUNCATE       set length to zero if file exists
;;  * @li #APR_FOPEN_BINARY         not a text file
;;  * @li #APR_FOPEN_BUFFERED       buffer the data.  Default is non-buffered
;;  * @li #APR_FOPEN_EXCL           return error if #APR_FOPEN_CREATE and file exists
;;  * @li #APR_FOPEN_DELONCLOSE     delete the file after closing
;;  * @li #APR_FOPEN_XTHREAD        Platform dependent tag to open the file
;;  *                               for use across multiple threads
;;  * @li #APR_FOPEN_SHARELOCK      Platform dependent support for higher
;;  *                               level locked read/write access to support
;;  *                               writes across process/machines
;;  * @li #APR_FOPEN_NOCLEANUP      Do not register a cleanup with the pool
;;  *                               passed in on the @a pool argument (see below)
;;  * @li #APR_FOPEN_SENDFILE_ENABLED  Open with appropriate platform semantics
;;  *                               for sendfile operations.  Advisory only,
;;  *                               apr_socket_sendfile does not check this flag
;;  * @li #APR_FOPEN_LARGEFILE      Platform dependent flag to enable large file
;;  *                               support, see WARNING below
;;  * @li #APR_FOPEN_SPARSE         Platform dependent flag to enable sparse file
;;  *                               support, see WARNING below
;;  * @li #APR_FOPEN_NONBLOCK       Platform dependent flag to enable
;;  *                               non blocking file io
;;  * @param perm Access permissions for file.
;;  * @param pool The pool to use.
;;  * @remark If perm is #APR_FPROT_OS_DEFAULT and the file is being created,
;;  * appropriate default permissions will be used.
;;  * @remark By default, the returned file descriptor will not be
;;  * inherited by child processes created by apr_proc_create().  This
;;  * can be changed using apr_file_inherit_set().
;;  */
(bind-lib libapr apr_file_open [apr_status_t,apr_file_t**,i8*,apr_int32_t,apr_fileperms_t,apr_pool_t*]*)

;; /**
;;  * Close the specified file.
;;  * @param file The file descriptor to close.
;;  */
(bind-lib libapr apr_file_close [apr_status_t,apr_file_t*]*)

;; /**
;;  * Delete the specified file.
;;  * @param path The full path to the file (using / on all systems)
;;  * @param pool The pool to use.
;;  * @remark If the file is open, it won't be removed until all
;;  * instances are closed.
;;  */
(bind-lib libapr apr_file_remove [apr_status_t,i8*,apr_pool_t*]*)

;; /**
;;  * Rename the specified file.
;;  * @param from_path The full path to the original file (using / on all systems)
;;  * @param to_path The full path to the new file (using / on all systems)
;;  * @param pool The pool to use.
;;  * @warning If a file exists at the new location, then it will be
;;  * overwritten.  Moving files or directories across devices may not be
;;  * possible.
;;  */
(bind-lib libapr apr_file_rename [apr_status_t,i8*,i8*,apr_pool_t*]*)

;; /**
;;  * Create a hard link to the specified file.
;;  * @param from_path The full path to the original file (using / on all systems)
;;  * @param to_path The full path to the new file (using / on all systems)
;;  * @remark Both files must reside on the same device.
;;  */
(bind-lib libapr apr_file_link [apr_status_t,i8*,i8*]*)

;; /**
;;  * Copy the specified file to another file.
;;  * @param from_path The full path to the original file (using / on all systems)
;;  * @param to_path The full path to the new file (using / on all systems)
;;  * @param perms Access permissions for the new file if it is created.
;;  *     In place of the usual or'd combination of file permissions, the
;;  *     value #APR_FPROT_FILE_SOURCE_PERMS may be given, in which case the source
;;  *     file's permissions are copied.
;;  * @param pool The pool to use.
;;  * @remark The new file does not need to exist, it will be created if required.
;;  * @warning If the new file already exists, its contents will be overwritten.
;;  */
(bind-lib libapr apr_file_copy [apr_status_t,i8*,i8*,apr_fileperms_t,apr_pool_t*]*)

;; /**
;;  * Append the specified file to another file.
;;  * @param from_path The full path to the source file (use / on all systems)
;;  * @param to_path The full path to the destination file (use / on all systems)
;;  * @param perms Access permissions for the destination file if it is created.
;;  *     In place of the usual or'd combination of file permissions, the
;;  *     value #APR_FPROT_FILE_SOURCE_PERMS may be given, in which case the source
;;  *     file's permissions are copied.
;;  * @param pool The pool to use.
;;  * @remark The new file does not need to exist, it will be created if required.
;;  */
(bind-lib libapr apr_file_append [apr_status_t,i8*,i8*,apr_fileperms_t,apr_pool_t*]*)

;; /**
;;  * Are we at the end of the file
;;  * @param fptr The apr file we are testing.
;;  * @remark Returns #APR_EOF if we are at the end of file, #APR_SUCCESS otherwise.
;;  */
(bind-lib libapr apr_file_eof [apr_status_t,apr_file_t*]*)

;; /**
;;  * Open standard error as an apr file pointer.
;;  * @param thefile The apr file to use as stderr.
;;  * @param pool The pool to allocate the file out of.
;;  *
;;  * @remark The only reason that the apr_file_open_std* functions exist
;;  * is that you may not always have a stderr/out/in on Windows.  This
;;  * is generally a problem with newer versions of Windows and services.
;;  *
;;  * @remark The other problem is that the C library functions generally work
;;  * differently on Windows and Unix.  So, by using apr_file_open_std*
;;  * functions, you can get a handle to an APR struct that works with
;;  * the APR functions which are supposed to work identically on all
;;  * platforms.
;;  */
(bind-lib libapr apr_file_open_stderr [apr_status_t,apr_file_t**,apr_pool_t*]*)

;; /**
;;  * open standard output as an apr file pointer.
;;  * @param thefile The apr file to use as stdout.
;;  * @param pool The pool to allocate the file out of.
;;  *
;;  * @remark See remarks for apr_file_open_stderr().
;;  */
(bind-lib libapr apr_file_open_stdout [apr_status_t,apr_file_t**,apr_pool_t*]*)

;; /**
;;  * open standard input as an apr file pointer.
;;  * @param thefile The apr file to use as stdin.
;;  * @param pool The pool to allocate the file out of.
;;  *
;;  * @remark See remarks for apr_file_open_stderr().
;;  */
(bind-lib libapr apr_file_open_stdin [apr_status_t,apr_file_t**,apr_pool_t*]*)

;; /**
;;  * open standard error as an apr file pointer, with flags.
;;  * @param thefile The apr file to use as stderr.
;;  * @param flags The flags to open the file with. Only the
;;  *              @li #APR_FOPEN_EXCL
;;  *              @li #APR_FOPEN_BUFFERED
;;  *              @li #APR_FOPEN_XTHREAD
;;  *              @li #APR_FOPEN_SHARELOCK
;;  *              @li #APR_FOPEN_SENDFILE_ENABLED
;;  *              @li #APR_FOPEN_LARGEFILE
;;  *
;;  *              flags should be used. The #APR_FOPEN_WRITE flag will
;;  *              be set unconditionally.
;;  * @param pool The pool to allocate the file out of.
;;  *
;;  * @remark See remarks for apr_file_open_stderr().
;;  */
(bind-lib libapr apr_file_open_flags_stderr [apr_status_t,apr_file_t**,apr_int32_t,apr_pool_t*]*)

;; /**
;;  * open standard output as an apr file pointer, with flags.
;;  * @param thefile The apr file to use as stdout.
;;  * @param flags The flags to open the file with. Only the
;;  *              @li #APR_FOPEN_EXCL
;;  *              @li #APR_FOPEN_BUFFERED
;;  *              @li #APR_FOPEN_XTHREAD
;;  *              @li #APR_FOPEN_SHARELOCK
;;  *              @li #APR_FOPEN_SENDFILE_ENABLED
;;  *              @li #APR_FOPEN_LARGEFILE
;;  *
;;  *              flags should be used. The #APR_FOPEN_WRITE flag will
;;  *              be set unconditionally.
;;  * @param pool The pool to allocate the file out of.
;;  *
;;  * @remark See remarks for apr_file_open_stderr().
;;  */
(bind-lib libapr apr_file_open_flags_stdout [apr_status_t,apr_file_t**,apr_int32_t,apr_pool_t*]*)

;; /**
;;  * open standard input as an apr file pointer, with flags.
;;  * @param thefile The apr file to use as stdin.
;;  * @param flags The flags to open the file with. Only the
;;  *              @li #APR_FOPEN_EXCL
;;  *              @li #APR_FOPEN_BUFFERED
;;  *              @li #APR_FOPEN_XTHREAD
;;  *              @li #APR_FOPEN_SHARELOCK
;;  *              @li #APR_FOPEN_SENDFILE_ENABLED
;;  *              @li #APR_FOPEN_LARGEFILE
;;  *
;;  *              flags should be used. The #APR_FOPEN_WRITE flag will
;;  *              be set unconditionally.
;;  * @param pool The pool to allocate the file out of.
;;  *
;;  * @remark See remarks for apr_file_open_stderr().
;;  */
(bind-lib libapr apr_file_open_flags_stdin [apr_status_t,apr_file_t**,apr_int32_t,apr_pool_t*]*)

;; /**
;;  * Read data from the specified file.
;;  * @param thefile The file descriptor to read from.
;;  * @param buf The buffer to store the data to.
;;  * @param nbytes On entry, the number of bytes to read; on exit, the number
;;  * of bytes read.
;;  *
;;  * @remark apr_file_read() will read up to the specified number of
;;  * bytes, but never more.  If there isn't enough data to fill that
;;  * number of bytes, all of the available data is read.  The third
;;  * argument is modified to reflect the number of bytes read.  If a
;;  * char was put back into the stream via ungetc, it will be the first
;;  * character returned.
;;  *
;;  * @remark It is not possible for both bytes to be read and an #APR_EOF
;;  * or other error to be returned.  #APR_EINTR is never returned.
;;  */
(bind-lib libapr apr_file_read [apr_status_t,apr_file_t*,void*,apr_size_t*]*)

;; /**
;;  * Write data to the specified file.
;;  * @param thefile The file descriptor to write to.
;;  * @param buf The buffer which contains the data.
;;  * @param nbytes On entry, the number of bytes to write; on exit, the number
;;  *               of bytes written.
;;  *
;;  * @remark apr_file_write() will write up to the specified number of
;;  * bytes, but never more.  If the OS cannot write that many bytes, it
;;  * will write as many as it can.  The third argument is modified to
;;  * reflect the * number of bytes written.
;;  *
;;  * @remark It is possible for both bytes to be written and an error to
;;  * be returned.  #APR_EINTR is never returned.
;;  */
(bind-lib libapr apr_file_write [apr_status_t,apr_file_t*,void*,apr_size_t*]*)

;; /**
;;  * Write data from iovec array to the specified file.
;;  * @param thefile The file descriptor to write to.
;;  * @param vec The array from which to get the data to write to the file.
;;  * @param nvec The number of elements in the struct iovec array. This must
;;  *             be smaller than #APR_MAX_IOVEC_SIZE.  If it isn't, the function
;;  *             will fail with #APR_EINVAL.
;;  * @param nbytes The number of bytes written.
;;  *
;;  * @remark It is possible for both bytes to be written and an error to
;;  * be returned.  #APR_EINTR is never returned.
;;  *
;;  * @remark apr_file_writev() is available even if the underlying
;;  * operating system doesn't provide writev().
;;  */
(bind-lib libapr apr_file_writev [apr_status_t,apr_file_t*,iovec*,apr_size_t,apr_size_t*]*)

;; /**
;;  * Read data from the specified file, ensuring that the buffer is filled
;;  * before returning.
;;  * @param thefile The file descriptor to read from.
;;  * @param buf The buffer to store the data to.
;;  * @param nbytes The number of bytes to read.
;;  * @param bytes_read If non-NULL, this will contain the number of bytes read.
;;  *
;;  * @remark apr_file_read_full() will read up to the specified number of
;;  * bytes, but never more.  If there isn't enough data to fill that
;;  * number of bytes, then the process/thread will block until it is
;;  * available or EOF is reached.  If a char was put back into the
;;  * stream via ungetc, it will be the first character returned.
;;  *
;;  * @remark It is possible for both bytes to be read and an error to be
;;  * returned.  And if *bytes_read is less than nbytes, an accompanying
;;  * error is _always_ returned.
;;  *
;;  * @remark #APR_EINTR is never returned.
;;  */
(bind-lib libapr apr_file_read_full [apr_status_t,apr_file_t*,void*,apr_size_t,apr_size_t*]*)

;; /**
;;  * Write data to the specified file, ensuring that all of the data is
;;  * written before returning.
;;  * @param thefile The file descriptor to write to.
;;  * @param buf The buffer which contains the data.
;;  * @param nbytes The number of bytes to write.
;;  * @param bytes_written If non-NULL, set to the number of bytes written.
;;  *
;;  * @remark apr_file_write_full() will write up to the specified number of
;;  * bytes, but never more.  If the OS cannot write that many bytes, the
;;  * process/thread will block until they can be written. Exceptional
;;  * error such as "out of space" or "pipe closed" will terminate with
;;  * an error.
;;  *
;;  * @remark It is possible for both bytes to be written and an error to
;;  * be returned.  And if *bytes_written is less than nbytes, an
;;  * accompanying error is _always_ returned.
;;  *
;;  * @remark #APR_EINTR is never returned.
;;  */
(bind-lib libapr apr_file_write_full [apr_status_t,apr_file_t*,void*,apr_size_t,apr_size_t*]*)


;; /**
;;  * Write data from iovec array to the specified file, ensuring that all of the
;;  * data is written before returning.
;;  * @param thefile The file descriptor to write to.
;;  * @param vec The array from which to get the data to write to the file.
;;  * @param nvec The number of elements in the struct iovec array. This must
;;  *             be smaller than #APR_MAX_IOVEC_SIZE.  If it isn't, the function
;;  *             will fail with #APR_EINVAL.
;;  * @param nbytes The number of bytes written.
;;  *
;;  * @remark apr_file_writev_full() is available even if the underlying
;;  * operating system doesn't provide writev().
;;  */
(bind-lib libapr apr_file_writev_full [apr_status_t,apr_file_t*,iovec*,apr_size_t,apr_size_t*]*)
;; /**
;;  * Write a character into the specified file.
;;  * @param ch The character to write.
;;  * @param thefile The file descriptor to write to
;;  */
(bind-lib libapr apr_file_putc [apr_status_t,i8,apr_file_t*]*)

;; /**
;;  * Read a character from the specified file.
;;  * @param ch The character to read into
;;  * @param thefile The file descriptor to read from
;;  */
(bind-lib libapr apr_file_getc [apr_status_t,i8*,apr_file_t*]*)

;; /**
;;  * Put a character back onto a specified stream.
;;  * @param ch The character to write.
;;  * @param thefile The file descriptor to write to
;;  */
(bind-lib libapr apr_file_ungetc [apr_status_t,i8,apr_file_t*]*)

;; /**
;;  * Read a line from the specified file
;;  * @param str The buffer to store the string in.
;;  * @param len The length of the string
;;  * @param thefile The file descriptor to read from
;;  * @remark The buffer will be NUL-terminated if any characters are stored.
;;  *         The newline at the end of the line will not be stripped.
;;  */
(bind-lib libapr apr_file_gets [apr_status_t,i8*,i32,apr_file_t*]*)

;; /**
;;  * Write the string into the specified file.
;;  * @param str The string to write.
;;  * @param thefile The file descriptor to write to
;;  */
(bind-lib libapr apr_file_puts [apr_status_t,i8*,apr_file_t*]*)

;; /**
;;  * Flush the file's buffer.
;;  * @param thefile The file descriptor to flush
;;  */
(bind-lib libapr apr_file_flush [apr_status_t,apr_file_t*]*)

;; /**
;;  * Transfer all file modified data and metadata to disk.
;;  * @param thefile The file descriptor to sync
;;  */
(bind-lib libapr apr_file_sync [apr_status_t,apr_file_t*]*)

;; /**
;;  * Transfer all file modified data to disk.
;;  * @param thefile The file descriptor to sync
;;  */
(bind-lib libapr apr_file_datasync [apr_status_t,apr_file_t*]*)

;; /**
;;  * Duplicate the specified file descriptor.
;;  * @param new_file The structure to duplicate into.
;;  * @param old_file The file to duplicate.
;;  * @param p The pool to use for the new file.
;;  * @remark *new_file must point to a valid apr_file_t, or point to NULL.
;;  */

(bind-lib libapr apr_file_dup [apr_status_t,apr_file_t**,apr_file_t*,apr_pool_t*]*)

;; /**
;;  * Duplicate the specified file descriptor and close the original
;;  * @param new_file The old file that is to be closed and reused
;;  * @param old_file The file to duplicate
;;  * @param p        The pool to use for the new file
;;  *
;;  * @remark new_file MUST point at a valid apr_file_t. It cannot be NULL.
;;  */
(bind-lib libapr apr_file_dup2 [apr_status_t,apr_file_t*,apr_file_t*,apr_pool_t*]*)

;; /**
;;  * Move the specified file descriptor to a new pool
;;  * @param new_file Pointer in which to return the new apr_file_t
;;  * @param old_file The file to move
;;  * @param p        The pool to which the descriptor is to be moved
;;  * @remark Unlike apr_file_dup2(), this function doesn't do an
;;  *         OS dup() operation on the underlying descriptor; it just
;;  *         moves the descriptor's apr_file_t wrapper to a new pool.
;;  * @remark The new pool need not be an ancestor of old_file's pool.
;;  * @remark After calling this function, old_file may not be used
;;  */
(bind-lib libapr apr_file_setaside [apr_status_t,apr_file_t**,apr_file_t*,apr_pool_t*]*)

;; /**
;;  * Give the specified apr file handle a new buffer
;;  * @param thefile  The file handle that is to be modified
;;  * @param buffer   The buffer
;;  * @param bufsize  The size of the buffer
;;  * @remark It is possible to add a buffer to previously unbuffered
;;  *         file handles, the #APR_FOPEN_BUFFERED flag will be added to
;;  *         the file handle's flags. Likewise, with buffer=NULL and
;;  *         bufsize=0 arguments it is possible to make a previously
;;  *         buffered file handle unbuffered.
;;  */
(bind-lib libapr apr_file_buffer_set [apr_status_t,apr_file_t*,i8*,apr_size_t]*)

;; /**
;;  * Get the size of any buffer for the specified apr file handle
;;  * @param thefile  The file handle
;;  */
(bind-lib libapr apr_file_buffer_size_get [apr_size_t,apr_file_t*]*)

;; /**
;;  * Move the read/write file offset to a specified byte within a file.
;;  * @param thefile The file descriptor
;;  * @param where How to move the pointer, one of:
;;  *              @li #APR_SET  --  set the offset to offset
;;  *              @li #APR_CUR  --  add the offset to the current position
;;  *              @li #APR_END  --  add the offset to the current file size
;;  * @param offset The offset to move the pointer to.
;;  * @remark The third argument is modified to be the offset the pointer
;;           was actually moved to.
;;  */
(bind-lib libapr apr_file_seek [apr_status_t,apr_file_t*,apr_seek_where_t,apr_off_t*]*)

;; /**
;;  * Create an anonymous pipe.
;;  * @param in The newly created pipe's file for reading.
;;  * @param out The newly created pipe's file for writing.
;;  * @param pool The pool to operate on.
;;  * @remark By default, the returned file descriptors will be inherited
;;  * by child processes created using apr_proc_create().  This can be
;;  * changed using apr_file_inherit_unset().
;;  * @bug  Some platforms cannot toggle between blocking and nonblocking,
;;  * and when passing a pipe as a standard handle to an application which
;;  * does not expect it, a non-blocking stream will fluxor the client app.
;;  * @deprecated @see apr_file_pipe_create_ex()
;;  */
(bind-lib libapr apr_file_pipe_create [apr_status_t,apr_file_t**,apr_file_t**,apr_pool_t*]*)

;; /**
;;  * Create an anonymous pipe which portably supports async timeout options.
;;  * @param in The newly created pipe's file for reading.
;;  * @param out The newly created pipe's file for writing.
;;  * @param blocking one of these values defined in apr_thread_proc.h;
;;  *                 @li #APR_FULL_BLOCK
;;  *                 @li #APR_READ_BLOCK
;;  *                 @li #APR_WRITE_BLOCK
;;  *                 @li #APR_FULL_NONBLOCK
;;  * @param pool The pool to operate on.
;;  * @remark By default, the returned file descriptors will be inherited
;;  * by child processes created using apr_proc_create().  This can be
;;  * changed using apr_file_inherit_unset().
;;  * @remark Some platforms cannot toggle between blocking and nonblocking,
;;  * and when passing a pipe as a standard handle to an application which
;;  * does not expect it, a non-blocking stream will fluxor the client app.
;;  * Use this function rather than apr_file_pipe_create() to create pipes
;;  * where one or both ends require non-blocking semantics.
;;  */
(bind-lib libapr apr_file_pipe_create_ex [apr_status_t,apr_file_t**,apr_file_t**,apr_int32_t,apr_pool_t*]*)

;; /**
;;  * Create a named pipe.
;;  * @param filename The filename of the named pipe
;;  * @param perm The permissions for the newly created pipe.
;;  * @param pool The pool to operate on.
;;  */
(bind-lib libapr apr_file_namedpipe_create [apr_status_t,i8*,apr_fileperms_t,apr_pool_t*]*)

;; /**
;;  * Get the timeout value for a pipe or manipulate the blocking state.
;;  * @param thepipe The pipe we are getting a timeout for.
;;  * @param timeout The current timeout value in microseconds.
;;  */
(bind-lib libapr apr_file_pipe_timeout_get [apr_status_t,apr_file_t*,apr_interval_time_t*]*)

;; /**
;;  * Set the timeout value for a pipe or manipulate the blocking state.
;;  * @param thepipe The pipe we are setting a timeout on.
;;  * @param timeout The timeout value in microseconds.  Values < 0 mean wait
;;  *        forever, 0 means do not wait at all.
;;  */
(bind-lib libapr apr_file_pipe_timeout_set [apr_status_t,apr_file_t*,apr_interval_time_t]*)

;; /** file (un)locking functions. */

;; /**
;;  * Establish a lock on the specified, open file. The lock may be advisory
;;  * or mandatory, at the discretion of the platform. The lock applies to
;;  * the file as a whole, rather than a specific range. Locks are established
;;  * on a per-thread/process basis; a second lock by the same thread will not
;;  * block.
;;  * @param thefile The file to lock.
;;  * @param type The type of lock to establish on the file.
;;  */
(bind-lib libapr apr_file_lock [apr_status_t,apr_file_t*,i32]*)

;; /**
;;  * Remove any outstanding locks on the file.
;;  * @param thefile The file to unlock.
;;  */
(bind-lib libapr apr_file_unlock [apr_status_t,apr_file_t*]*)

;; /**accessor and general file_io functions. */

;; /**
;;  * return the file name of the current file.
;;  * @param new_path The path of the file.
;;  * @param thefile The currently open file.
;;  */

(bind-lib libapr apr_file_name_get [apr_status_t,i8**,apr_file_t*]*)

;; /**
;;  * Return the data associated with the current file.
;;  * @param data The user data associated with the file.
;;  * @param key The key to use for retrieving data associated with this file.
;;  * @param file The currently open file.
;;  */

(bind-lib libapr apr_file_data_get [apr_status_t,void**,i8*,apr_file_t*]*)

;; /**
;;  * Set the data associated with the current file.
;;  * @param file The currently open file.
;;  * @param data The user data to associate with the file.
;;  * @param key The key to use for associating data with the file.
;;  * @param cleanup The cleanup routine to use when the file is destroyed.
;;  */

(bind-lib libapr apr_file_data_set [apr_status_t,apr_file_t*,void*,i8*,apr_status_t*]*)

;; /**
;;  * set the specified file's permission bits.
;;  * @param fname The file (name) to apply the permissions to.
;;  * @param perms The permission bits to apply to the file.
;;  *
;;  * @warning Some platforms may not be able to apply all of the
;;  * available permission bits; #APR_INCOMPLETE will be returned if some
;;  * permissions are specified which could not be set.
;;  *
;;  * @warning Platforms which do not implement this feature will return
;;  * #APR_ENOTIMPL.
;;  */
(bind-lib libapr apr_file_perms_set [apr_status_t,i8*,apr_fileperms_t]*)

;; /**
;;  * Set attributes of the specified file.
;;  * @param fname The full path to the file (using / on all systems)
;;  * @param attributes Or'd combination of
;;  *            @li #APR_FILE_ATTR_READONLY   - make the file readonly
;;  *            @li #APR_FILE_ATTR_EXECUTABLE - make the file executable
;;  *            @li #APR_FILE_ATTR_HIDDEN     - make the file hidden
;;  * @param attr_mask Mask of valid bits in attributes.
;;  * @param pool the pool to use.
;;  * @remark This function should be used in preference to explicit manipulation
;;  *      of the file permissions, because the operations to provide these
;;  *      attributes are platform specific and may involve more than simply
;;  *      setting permission bits.
;;  * @warning Platforms which do not implement this feature will return
;;  *      #APR_ENOTIMPL.
;;  */
(bind-lib libapr apr_file_attrs_set [apr_status_t,i8*,apr_fileattrs_t,apr_fileattrs_t,apr_pool_t*]*)

;; /**
;;  * Set the mtime of the specified file.
;;  * @param fname The full path to the file (using / on all systems)
;;  * @param mtime The mtime to apply to the file.
;;  * @param pool The pool to use.
;;  * @warning Platforms which do not implement this feature will return
;;  *      #APR_ENOTIMPL.
;;  */
(bind-lib libapr apr_file_mtime_set [apr_status_t,i8*,apr_time_t,apr_pool_t*]*)

;; /**
;;  * Create a new directory on the file system.
;;  * @param path the path for the directory to be created. (use / on all systems)
;;  * @param perm Permissions for the new directory.
;;  * @param pool the pool to use.
;;  */

(bind-lib libapr apr_dir_make [apr_status_t,i8*,apr_fileperms_t,apr_pool_t*]*)

;; /** Creates a new directory on the file system, but behaves like
;;  * 'mkdir -p'. Creates intermediate directories as required. No error
;;  * will be reported if PATH already exists.
;;  * @param path the path for the directory to be created. (use / on all systems)
;;  * @param perm Permissions for the new directory.
;;  * @param pool the pool to use.
;;  */
(bind-lib libapr apr_dir_make_recursive [apr_status_t,i8*,apr_fileperms_t,apr_pool_t*]*)

;; /**
;;  * Remove directory from the file system.
;;  * @param path the path for the directory to be removed. (use / on all systems)
;;  * @param pool the pool to use.
;;  * @remark Removing a directory which is in-use (e.g., the current working
;;  * directory, or during apr_dir_read, or with an open file) is not portable.
;;  */

(bind-lib libapr apr_dir_remove [apr_status_t,i8*,apr_pool_t*]*)

;; /**
;;  * get the specified file's stats.
;;  * @param finfo Where to store the information about the file.
;;  * @param wanted The desired apr_finfo_t fields, as a bit flag of APR_FINFO_* values
;;  * @param thefile The file to get information about.
;;  */

(bind-lib libapr apr_file_info_get [apr_status_t,apr_finfo_t*,apr_int32_t,apr_file_t*]*)


;; /**
;;  * Truncate the file's length to the specified offset
;;  * @param fp The file to truncate
;;  * @param offset The offset to truncate to.
;;  * @remark The read/write file offset is repositioned to offset.
;;  */
(bind-lib libapr apr_file_trunc [apr_status_t,apr_file_t*,apr_off_t]*)

;; /**
;;  * Retrieve the flags that were passed into apr_file_open()
;;  * when the file was opened.
;;  * @return apr_int32_t the flags
;;  */
(bind-lib libapr apr_file_flags_get [apr_int32_t,apr_file_t*]*)

;; /**
;;  * Get the pool used by the file.
;;  */
;; APR_POOL_DECLARE_ACCESSOR(file);

;; /**
;;  * Set a file to be inherited by child processes.
;;  *
;;  */
;; APR_DECLARE_INHERIT_SET(file);

;; /**
;;  * Unset a file from being inherited by child processes.
;;  */
;; APR_DECLARE_INHERIT_UNSET(file);

;; /**
;;  * Open a temporary file
;;  * @param fp The apr file to use as a temporary file.
;;  * @param templ The template to use when creating a temp file.
;;  * @param flags The flags to open the file with. If this is zero,
;;  *              the file is opened with
;;  *              #APR_FOPEN_CREATE | #APR_FOPEN_READ | #APR_FOPEN_WRITE |
;;  *              #APR_FOPEN_EXCL | #APR_FOPEN_DELONCLOSE
;;  * @param p The pool to allocate the file out of.
;;  * @remark
;;  * This function  generates  a unique temporary file name from template.
;;  * The last six characters of template must be XXXXXX and these are replaced
;;  * with a string that makes the filename unique. Since it will  be  modified,
;;  * template must not be a string constant, but should be declared as a character
;;  * array.
;;  *
;;  */
(bind-lib libapr apr_file_mktemp [apr_status_t,apr_file_t**,i8*,apr_int32_t,apr_pool_t*]*)


;; /**
;;  * Find an existing directory suitable as a temporary storage location.
;;  * @param temp_dir The temp directory.
;;  * @param p The pool to use for any necessary allocations.
;;  * @remark
;;  * This function uses an algorithm to search for a directory that an
;;  * an application can use for temporary storage.
;;  *
;;  */
(bind-lib libapr apr_temp_dir_get [apr_status_t,i8**,apr_pool_t*]*)

;;;;;;;;;;;;;;;;;;;;;
;; apr_file_info.h ;;
;;;;;;;;;;;;;;;;;;;;;

;; /**
;;  * @defgroup apr_file_info File Information
;;  * @ingroup APR
;;  * @{
;;  */

;; /* Many applications use the type member to determine the
;;  * existance of a file or initialization of the file info,
;;  * so the APR_NOFILE value must be distinct from APR_UNKFILE.
;;  */

;; /** apr_filetype_e values for the filetype member of the
;;  * apr_file_info_t structure
;;  * @warning: Not all of the filetypes below can be determined.
;;  * For example, a given platform might not correctly report
;;  * a socket descriptor as APR_SOCK if that type isn't
;;  * well-identified on that platform.  In such cases where
;;  * a filetype exists but cannot be described by the recognized
;;  * flags below, the filetype will be APR_UNKFILE.  If the
;;  * filetype member is not determined, the type will be APR_NOFILE.
;;  */


(bind-alias apr_filetype_e enum)

(bind-val APR_NOFILE apr_filetype_e 0)     ;; no file type determined
(bind-val APR_REG apr_filetype_e 1)        ;; a regular file
(bind-val APR_DIR apr_filetype_e 2)        ;; a directory
(bind-val APR_CHR apr_filetype_e 3)        ;; a character device
(bind-val APR_BLK apr_filetype_e 4)        ;; a block device
(bind-val APR_PIPE apr_filetype_e 5)       ;; a FIFO / pipe
(bind-val APR_LNK apr_filetype_e 6)        ;; a symbolic link
(bind-val APR_SOCK apr_filetype_e 7)       ;; a [unix domain] socket
(bind-val APR_UNKFILE7 apr_filetype_e 127) ;; a file of some other unknown type

;; /**
;;  * @defgroup apr_file_permissions File Permissions flags
;;  * @{
;;  */

(bind-val APR_FPROT_USETID i32 #x8000)
(bind-val APR_FPROT_UREAD i32 #x0400)
(bind-val APR_FPROT_UWRITE i32 #x0200)
(bind-val APR_FPROT_UEXECUTE i32 #x0100)

(bind-val APR_FPROT_GSETID i32 #x4000)
(bind-val APR_FPROT_GREAD i32 #x0040)
(bind-val APR_FPROT_GWRITE i32 #x0020)
(bind-val APR_FPROT_GEXECUTE i32 #x0010)

(bind-val APR_FPROT_WSTICKY i32 #x2000)
(bind-val APR_FPROT_WREAD i32 #x0004)
(bind-val APR_FPROT_WWRITE i32 #x0002)
(bind-val APR_FPROT_WEXECUTE i32 #x0001)

(bind-val APR_FPROT_OS_DEFAULT i32 #x0FFF)

;; /* additional permission flags for apr_file_copy  and apr_file_append */
(bind-val APR_FPROT_FILE_SOURCE_PERMS i32 #x1000)


;; /**
;;  * Structure for referencing directories.
;;  */
(bind-alias apr_dir_t apr_dir_t)
;; /**
;;  * Structure for determining file permissions.
;;  */
(bind-alias apr_fileperms_t apr_int32_t)
;; #if (defined WIN32) || (defined NETWARE)
;; /**
;;  * Structure for determining the device the file is on.
;;  */
(bind-alias apr_dev_t apr_uint32_t)
;; #else
;; /**
;;  * Structure for determining the device the file is on.
;;  */
(bind-alias apr_dev_t dev_t)
;; #endif

;; /**
;;  * @defgroup apr_file_stat Stat Functions
;;  * @{
;;  */
;; /** file info structure */
(bind-alias apr_finfo_t apr_finfo_t)

(bind-val APR_FINFO_LINK i32 #x00000001)
(bind-val APR_FINFO_MTIME i32 #x00000010)
(bind-val APR_FINFO_CTIME i32 #x00000020)
(bind-val APR_FINFO_ATIME i32 #x00000040)
(bind-val APR_FINFO_SIZE i32 #x00000100)
(bind-val APR_FINFO_CSIZE i32 #x00000200)
(bind-val APR_FINFO_DEV i32 #x00001000)
(bind-val APR_FINFO_INODE i32 #x00002000)
(bind-val APR_FINFO_NLINK i32 #x00004000)
(bind-val APR_FINFO_TYPE i32 #x00008000)
(bind-val APR_FINFO_USER i32 #x00010000)
(bind-val APR_FINFO_GROUP i32 #x00020000)
(bind-val APR_FINFO_UPROT i32 #x00100000)
(bind-val APR_FINFO_GPROT i32 #x00200000)
(bind-val APR_FINFO_WPROT i32 #x00400000)
(bind-val APR_FINFO_ICASE i32 #x01000000)
(bind-val APR_FINFO_NAME i32 #x02000000)

(bind-val APR_FINFO_MIN i32 #x00008170)
(bind-val APR_FINFO_IDENT i32 #x00003000)
(bind-val APR_FINFO_OWNER i32 #x00030000)
(bind-val APR_FINFO_PROT i32 #x00700000)
(bind-val APR_FINFO_NORM i32 #x0073b170)
(bind-val APR_FINFO_DIRENT i32 #x02000000)

;; ;; /**
;; ;;  * The file information structure.  This is analogous to the POSIX
;; ;;  * stat structure.
;; ;;  */
;; struct apr_finfo_t {
;;     ;; /** Allocates memory and closes lingering handles in the specified pool */
;;     apr_pool_t *pool;
;;     ;; /** The bitmask describing valid fields of this apr_finfo_t structure
;;     ;;  *  including all available 'wanted' fields and potentially more */
;;     apr_int32_t valid;
;;     ;; /** The access permissions of the file.  Mimics Unix access rights. */
;;     apr_fileperms_t protection;
;;     ;; /** The type of file.  One of APR_REG, APR_DIR, APR_CHR, APR_BLK, APR_PIPE,
;;     ;;  * APR_LNK or APR_SOCK.  If the type is undetermined, the value is APR_NOFILE.
;;     ;;  * If the type cannot be determined, the value is APR_UNKFILE.
;;     ;;  */
;;     apr_filetype_e filetype;
;;     ;; /** The user id that owns the file */
;;     apr_uid_t user;
;;     ;; /** The group id that owns the file */
;;     apr_gid_t group;
;;     ;; /** The inode of the file. */
;;     apr_ino_t inode;
;;     ;; /** The id of the device the file is on. */
;;     apr_dev_t device;
;;     ;; /** The number of hard links to the file. */
;;     apr_int32_t nlink;
;;     ;; /** The size of the file */
;;     apr_off_t size;
;;     ;; /** The storage size consumed by the file */
;;     apr_off_t csize;
;;     ;; /** The time the file was last accessed */
;;     apr_time_t atime;
;;     ;; /** The time the file was last modified */
;;     apr_time_t mtime;
;;     ;; /** The time the file was created, or the inode was last changed */
;;     apr_time_t ctime;
;;     ;; /** The pathname of the file (possibly unrooted) */
;;     const char *fname;
;;     ;; /** The file's name (no path) in filesystem case */
;;     const char *name;
;;     ;; /** Unused */
;;     struct apr_file_t *filehand;
;; };

(bind-type apr_finfo_t <apr_pool_t*,apr_int32_t,apr_fileperms_t,apr_filetype_e,apr_uid_t,apr_gid_t,apr_ino_t,apr_dev_t,apr_int32_t,apr_off_t,apr_off_t,apr_time_t,apr_time_t,apr_time_t,i8*,i8*,apr_file_t*>
  "file information structure - analogous to the POSIX stat structure")


;; /**
;;  * get the specified file's stats.  The file is specified by filename,
;;  * instead of using a pre-opened file.
;;  * @param finfo Where to store the information about the file, which is
;;  * never touched if the call fails.
;;  * @param fname The name of the file to stat.
;;  * @param wanted The desired apr_finfo_t fields, as a bit flag of APR_FINFO_
;;                  values
;;  * @param pool the pool to use to allocate the new file.
;;  *
;;  * @note If @c APR_INCOMPLETE is returned all the fields in @a finfo may
;;  *       not be filled in, and you need to check the @c finfo->valid bitmask
;;  *       to verify that what you're looking for is there.
;;  */

(bind-lib libapr apr_stat [apr_status_t,apr_finfo_t*,i8*,apr_int32_t,apr_pool_t*]*)

;; /** @} */
;; /**
;;  * @defgroup apr_dir Directory Manipulation Functions
;;  * @{
;;  */

;; /**
;;  * Open the specified directory.
;;  * @param new_dir The opened directory descriptor.
;;  * @param dirname The full path to the directory (use / on all systems)
;;  * @param pool The pool to use.
;;  */

(bind-lib libapr apr_dir_open [apr_status_t,apr_dir_t**,i8*,apr_pool_t*]*)

;; /**
;;  * close the specified directory.
;;  * @param thedir the directory descriptor to close.
;;  */

(bind-lib libapr apr_dir_close [apr_status_t,apr_dir_t*]*)

;; /**
;;  * Read the next entry from the specified directory.
;;  * @param finfo the file info structure and filled in by apr_dir_read
;;  * @param wanted The desired apr_finfo_t fields, as a bit flag of APR_FINFO_
;;                  values
;;  * @param thedir the directory descriptor returned from apr_dir_open
;;  * @remark No ordering is guaranteed for the entries read.
;;  *
;;  * @note If @c APR_INCOMPLETE is returned all the fields in @a finfo may
;;  *       not be filled in, and you need to check the @c finfo->valid bitmask
;;  *       to verify that what you're looking for is there. When no more
;;  *       entries are available, APR_ENOENT is returned.
;;  */

(bind-lib libapr apr_dir_read [apr_status_t,apr_finfo_t*,apr_int32_t,apr_dir_t*]*)

;; /**
;;  * Rewind the directory to the first entry.
;;  * @param thedir the directory descriptor to rewind.
;;  */

(bind-lib libapr apr_dir_rewind [apr_status_t,apr_dir_t*]*)
;; /** @} */

;; /**
;;  * @defgroup apr_filepath Filepath Manipulation Functions
;;  * @{
;;  */

;; /** Cause apr_filepath_merge to fail if addpath is above rootpath
;;  * @bug in APR 0.9 and 1.x, this flag's behavior is undefined
;;  * if the rootpath is NULL or empty.  In APR 2.0 this should be
;;  * changed to imply NOTABSOLUTE if the rootpath is NULL or empty.
;;  */
(bind-val APR_FILEPATH_NOTABOVEROOT i32 #x01)

;; /** internal: Only meaningful with APR_FILEPATH_NOTABOVEROOT */
(bind-val APR_FILEPATH_SECUREROOTTEST i32 #x02)

;; /** Cause apr_filepath_merge to fail if addpath is above rootpath,
;;  * even given a rootpath /foo/bar and an addpath ../bar/bash
;;  */
(bind-val APR_FILEPATH_SECUREROOT i32 #x03)

;; /** Fail apr_filepath_merge if the merged path is relative */
(bind-val APR_FILEPATH_NOTRELATIVE i32 #x04)

;; /** Fail apr_filepath_merge if the merged path is absolute */
(bind-val APR_FILEPATH_NOTABSOLUTE i32 #x08)

;; /** Return the file system's native path format (e.g. path delimiters
;;  * of ':' on MacOS9, '\' on Win32, etc.) */
(bind-val APR_FILEPATH_NATIVE i32 #x10)

;; /** Resolve the true case of existing directories and file elements
;;  * of addpath, (resolving any aliases on Win32) and append a proper
;;  * trailing slash if a directory
;;  */
(bind-val APR_FILEPATH_TRUENAME i32 #x20)

;; /**
;;  * Extract the rootpath from the given filepath
;;  * @param rootpath the root file path returned with APR_SUCCESS or APR_EINCOMPLETE
;;  * @param filepath the pathname to parse for its root component
;;  * @param flags the desired rules to apply, from
;;  * <PRE>
;;  *      APR_FILEPATH_NATIVE    Use native path separators (e.g. '\' on Win32)
;;  *      APR_FILEPATH_TRUENAME  Tests that the root exists, and makes it proper
;;  * </PRE>
;;  * @param p the pool to allocate the new path string from
;;  * @remark on return, filepath points to the first non-root character in the
;;  * given filepath.  In the simplest example, given a filepath of "/foo",
;;  * returns the rootpath of "/" and filepath points at "foo".  This is far
;;  * more complex on other platforms, which will canonicalize the root form
;;  * to a consistant format, given the APR_FILEPATH_TRUENAME flag, and also
;;  * test for the validity of that root (e.g., that a drive d:/ or network
;;  * share //machine/foovol/).
;;  * The function returns APR_ERELATIVE if filepath isn't rooted (an
;;  * error), APR_EINCOMPLETE if the root path is ambiguous (but potentially
;;  * legitimate, e.g. "/" on Windows is incomplete because it doesn't specify
;;  * the drive letter), or APR_EBADPATH if the root is simply invalid.
;;  * APR_SUCCESS is returned if filepath is an absolute path.
;;  */
(bind-lib libapr apr_filepath_root [apr_status_t,i8**,i8**,apr_int32_t,apr_pool_t*]*)

;; /**
;;  * Merge additional file path onto the previously processed rootpath
;;  * @param newpath the merged paths returned
;;  * @param rootpath the root file path (NULL uses the current working path)
;;  * @param addpath the path to add to the root path
;;  * @param flags the desired APR_FILEPATH_ rules to apply when merging
;;  * @param p the pool to allocate the new path string from
;;  * @remark if the flag APR_FILEPATH_TRUENAME is given, and the addpath
;;  * contains wildcard characters ('*', '?') on platforms that don't support
;;  * such characters within filenames, the paths will be merged, but the
;;  * result code will be APR_EPATHWILD, and all further segments will not
;;  * reflect the true filenames including the wildcard and following segments.
;;  */

(bind-lib libapr apr_filepath_merge [apr_status_t,i8**,i8*,i8*,apr_int32_t,apr_pool_t*]*)

;; /**
;;  * Split a search path into separate components
;;  * @param pathelts the returned components of the search path
;;  * @param liststr the search path (e.g., <tt>getenv("PATH")</tt>)
;;  * @param p the pool to allocate the array and path components from
;;  * @remark empty path components do not become part of @a pathelts.
;;  * @remark the path separator in @a liststr is system specific;
;;  * e.g., ':' on Unix, ';' on Windows, etc.
;;  */
(bind-lib libapr apr_filepath_list_split [apr_status_t,apr_array_header_t**,i8*,apr_pool_t*]*)

;; /**
;;  * Merge a list of search path components into a single search path
;;  * @param liststr the returned search path; may be NULL if @a pathelts is empty
;;  * @param pathelts the components of the search path
;;  * @param p the pool to allocate the search path from
;;  * @remark emtpy strings in the source array are ignored.
;;  * @remark the path separator in @a liststr is system specific;
;;  * e.g., ':' on Unix, ';' on Windows, etc.
;;  */
(bind-lib libapr apr_filepath_list_merge [apr_status_t,i8**,apr_array_header_t*,apr_pool_t*]*)

;; /**
;;  * Return the default file path (for relative file names)
;;  * @param path the default path string returned
;;  * @param flags optional flag APR_FILEPATH_NATIVE to retrieve the
;;  *              default file path in os-native format.
;;  * @param p the pool to allocate the default path string from
;;  */
(bind-lib libapr apr_filepath_get [apr_status_t,i8**,apr_int32_t,apr_pool_t*]*)

;; /**
;;  * Set the default file path (for relative file names)
;;  * @param path the default path returned
;;  * @param p the pool to allocate any working storage
;;  */
(bind-lib libapr apr_filepath_set [apr_status_t,i8*,apr_pool_t*]*)

;; /** The FilePath character encoding is unknown */
(bind-val APR_FILEPATH_ENCODING_UNKNOWN i32 0)

;; /** The FilePath character encoding is locale-dependent */
(bind-val APR_FILEPATH_ENCODING_LOCALE i32 1)

;; /** The FilePath character encoding is UTF-8 */
(bind-val APR_FILEPATH_ENCODING_UTF8 i32 2)

;; /**
;;  * Determine the encoding used internally by the FilePath functions
;;  * @param style points to a variable which receives the encoding style flag
;;  * @param p the pool to allocate any working storage
;;  * @remark Use @c apr_os_locale_encoding and/or @c apr_os_default_encoding
;;  * to get the name of the path encoding if it's not UTF-8.
;;  */
(bind-lib libapr apr_filepath_encoding [apr_status_t,i32*,apr_pool_t*]*)

;;;;;;;;;;;;;;;
;; apr_env.h ;;
;;;;;;;;;;;;;;;

;; /**
;;  * @defgroup apr_env Functions for manipulating the environment
;;  * @ingroup APR
;;  * @{
;;  */

;; /**
;;  * Get the value of an environment variable
;;  * @param value the returned value, allocated from @a pool
;;  * @param envvar the name of the environment variable
;;  * @param pool where to allocate @a value and any temporary storage from
;;  */
(bind-lib libapr apr_env_get [apr_status_t,i8**,i8*,apr_pool_t*]*)

;; /**
;;  * Set the value of an environment variable
;;  * @param envvar the name of the environment variable
;;  * @param value the value to set
;;  * @param pool where to allocate temporary storage from
;;  */
(bind-lib libapr apr_env_set [apr_status_t,i8*,i8*,apr_pool_t*]*)

;; /**
;;  * Delete a variable from the environment
;;  * @param envvar the name of the environment variable
;;  * @param pool where to allocate temporary storage from
;;  */
(bind-lib libapr apr_env_delete [apr_status_t,i8*,apr_pool_t*]*)

(impc:aot:insert-footer "xtmapr")
(define *xtmlib-apr-loaded* #t)
