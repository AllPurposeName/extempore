;; first, the code to actually get the data back for visualisation
;; (assumes MPI - doesn't yet support the nanomsg communication)

;; allocate memory for *all* the particles (or at least a
;; subset) for visualisation on head node
(bind-val part_all float*)

(bind-func pbpic2_alloc_and_visuals_arrays
  (lambda ()
    (let ((part_all_:float* (halloc (if (= kstrt 1)
                                        (* nvp idimp npmax)
                                        0:i32))))
      (set! part_all part_all_))))

(pbpic2_alloc_and_visuals_arrays)

(bind-func pbpic2_gather_data
  "gather data (or a subset) from all the nodes to the head node for
visualisation"
  (lambda ()
    ;; ;; gather the fields (fxyze)
    ;; (if (<>
    ;;      (MPI_Gather (convert fxyze i8*) ;; gather field data
    ;;                  (* nxe ny ndim) ;; field size * floats-per-field-component
    ;;                  MPI_FLOAT
    ;;                  (convert fxyze_all i8*) ;; recv buffer on root node
    ;;                  (* nxe ny ndim) ;; num particles * floats-per-particle
    ;;                  MPI_FLOAT
    ;;                  0 ;; root
    ;;                  MPI_COMM_WORLD)
    ;;      0)
    ;;     (println "MPI_Gather fields error."))

    ;; gather the particles
    (if (<> (MPI_Gather (convert part i8*) ;; gather particle data
                        (* npmax idimp) ;; num particles * floats-per-particle
                        MPI_FLOAT
                        (convert part_all i8*) ;; recv buffer on root node
                        (* npmax idimp) ;; num particles * floats-per-particle
                        MPI_FLOAT
                        0 ;; root
                        MPI_COMM_WORLD)
            0)
        (println "MPI_Gather particles error."))))

;; now the actual graphics code

(sys:load "libs/external/glfw3.xtm")

(bind-val width i32 800)
(bind-val height i32 600)

(bind-val window GLFWwindow*
  (glfw_init_and_create_interaction_window width height))

(sys:load "libs/external/gl/gl-objects.xtm")

;; set up the FBO & backing textures

(bind-val fbo FBO*)
(bind-val ss_quad_vao VAO*)

(bind-val post_process_sp ShaderProgram)

(bind-func create_post_process_shader
  (lambda (vsource:i8* fsource:i8*)
    (set! post_process_sp (ShaderProgram_create vsource fsource))))

(create_post_process_shader
 (sys:slurp-file "libs/contrib/pic/framebuffer.vert")
 (sys:slurp-file "libs/contrib/pic/framebuffer.frag"))

;; OpenGL setup

(call-as-xtlang
 ;; (glDisable GL_DEPTH_TEST)
 (glDepthMask GL_FALSE)
 (glEnable GL_BLEND)
 (glBlendFunc GL_SRC_ALPHA GL_ONE)
 (glEnable GL_PROGRAM_POINT_SIZE)
 (glDisable GL_LINE_SMOOTH)
 void)

;; fields

(bind-val field_vbo VBO*)
(bind-val field_vao VAO*)
(bind-val field_sp ShaderProgram)

(bind-func create_field_shader
  (lambda (vsource:i8* fsource:i8*)
    (set! field_sp (ShaderProgram_create vsource fsource))))

(impc:aot:do-or-emit
      (create_field_shader (sys:slurp-file "libs/contrib/pic/pbpic2-field.vert")
                           (sys:slurp-file "libs/contrib/pic/pbpic2-field.frag")))

;; this data should have interleaved the `bases' of the field arrows
;; (i.e. the grid) in 2D with the ndim (i.e. 3D) field components

(bind-val field_arrows float*)

(impc:aot:do-or-emit
 (call-as-xtlang
  (let ((field_arrows_:float* (halloc (* 4 nx ny))))
    (set! field_arrows field_arrows_))))

;; set base verts (i.e. every second vec2) to regular grid
(impc:aot:do-or-emit
 (call-as-xtlang
  (let ((idx 0))
    (doloop (i nx)
      (doloop (j ny)
        (set! idx (* (+ (* i nx) j) 4))
        (pset! field_arrows
               idx
               (- (* (/ (convert i float) (convert nx float)) 2.0) 1.0))
        (pset! field_arrows
               (+ idx 1)
               (- (* (/ (convert j float) (convert ny float)) 2.0) 1.0)))))))

(bind-func copy_field_xy_to_arrows_buffer
  (lambda (field:float* scale_factor:float)
    (let ((field_arrows_idx 0)
          (field_idx 0)
          (max_length 0.))
      ;; (doloop (k (* nxe ny))
      ;;   (set! field_idx (* k ndim))
      ;;   (if (> (pref field field_idx) max_length)
      ;;       (set! max_length
      ;;             (pref field field_idx)))
      ;;   (if (> (pref field (+ field_idx 1)) max_length)
      ;;       (set! max_length
      ;;             (pref field (+ field_idx 1)))))
      ;; (if (> max_length 0.25)
      ;;     (set! scale_factor (* 0.25 (/ 1.0 max_length))))
      (doloop (i nx)
        (doloop (j ny)
          (set! field_arrows_idx (* (+ (* i nx) j) 4))
          (set! field_idx (+ (* i nxe) j 1))
          (pset! field_arrows ;; x component
                 (+ field_arrows_idx 2)
                 (+ (pref field_arrows field_arrows_idx)
                    (* scale_factor (pref field field_idx))))
          (pset! field_arrows ;; x component
                 (+ field_arrows_idx 3)
                 (+ (pref field_arrows (+ field_arrows_idx 1))
                    (* scale_factor (pref field (+ field_idx 1))))))))))

;; not sure why fxyze tends to get massive (junk) numbers in it, but
;; this hack cleans them out.
(bind-func remove_guff_from_arrows_buffer
  (lambda ()
    (let ((idx 0))
      (doloop (i nx)
        (doloop (j ny)
          (set! idx (* (+ (* i ny) j) 4))
          ;; (println "idx:" idx)
          (if (> (fabs (pref field_arrows (+ 2 idx))) 1.0)
              (pset! field_arrows
                     (+ 2 idx)
                     (pref field_arrows (+ 0 idx))))
          (if (> (fabs (pref field_arrows (+ 3 idx))) 1.0)
              (pset! field_arrows
                     (+ 3 idx)
                     (pref field_arrows (+ 1 idx)))))))))

;; particles

(bind-val particle_vbo VBO*)
(bind-val particle_vao VAO*)

(bind-val particle_sp ShaderProgram)

(bind-func create_particle_shader
  (lambda (vsource:i8* fsource:i8*)
    (set! particle_sp (ShaderProgram_create vsource fsource))))

(impc:aot:do-or-emit
      (create_particle_shader (sys:slurp-file "libs/contrib/pic/pbpic2-particle.vert")
                              (sys:slurp-file "libs/contrib/pic/pbpic2-particle.frag")))

;; init all the things
(impc:aot:do-or-emit
 (call-as-xtlang
  ;; FBO
  (let ((fbw_ptr:i32* (salloc))
        (fbh_ptr:i32* (salloc)))
    (glfwGetFramebufferSize window fbw_ptr fbh_ptr)
    (println (set! fbo (FBO_create_with_textures (pref fbw_ptr 0) (pref fbh_ptr 0) #t)))
    (set! ss_quad_vao (VAO_create_ss_quad)))
  ;; particles
  (set! particle_vbo (VBO_create part_all (convert (* nvp idimp npmax))))
  (set! particle_vao (VAO_create))
  (VAO_bind_attribute particle_vao particle_vbo 0 2 5 0)
  (VAO_bind_attribute particle_vao particle_vbo 1 3 5 2)
  ;; fields
  (set! field_vbo (VBO_create field_arrows (convert (* 4 nx ny))))
  (set! field_vao (VAO_create))
  (VAO_bind_attribute field_vao field_vbo 0 2)
  void))

;; draw all the things

(bind-func gl_draw_field
  (lambda ()
    (copy_field_xy_to_arrows_buffer fxyze .1)
    ;; (remove_guff_from_arrows_buffer)
    (VBO_update_data field_vbo)
    (glUseProgram field_sp)
    (VAO_bind_and_draw_arrays field_vao GL_LINES 0 (convert (* 4 nxe ny)))
    void))

(bind-func gl_draw_particles
  (lambda ()
    ;; move particles, update VBO
    (VBO_update_data particle_vbo)
    ;; draw the world
    (let ((nxnyloc (glGetUniformLocation particle_sp "nxny")))
      (glUseProgram particle_sp)
      (glUniform2f nxnyloc (convert nxe) (convert ny)))
    (VAO_bind_and_draw_arrays particle_vao GL_POINTS 0 (* nvp npmax))
    void))

(bind-func gl_draw_framebuffer
  (lambda ()
    ;; bind default framebuffer
    (glBindFramebuffer GL_FRAMEBUFFER 0)
    ;; clear the framebuffer's colour and depth buffers
    (glClear (bor GL_COLOR_BUFFER_BIT GL_DEPTH_BUFFER_BIT))
    ;; our post-processing shader for the screen-space quad
    (glUseProgram post_process_sp)
    ;; bind the quad's VAO
    (glBindVertexArray (VAO_id ss_quad_vao))
    ;; activate the first texture slot and put texture from previous pass in it
    (glActiveTexture GL_TEXTURE0)
    (glBindTexture GL_TEXTURE_2D (FBO_color_texture fbo))
    ;; draw the quad
    (glDrawArrays GL_TRIANGLE_STRIP 0 4)))

(bind-func gl_draw_loop
  (let ((drawbufs_ptr:GLenum* (zalloc)))
    (pset! drawbufs_ptr 0 GL_COLOR_ATTACHMENT0)
    (lambda (time:i64 delta_t:double)
      ;; set FBO as render target
      (glBindFramebuffer GL_FRAMEBUFFER (FBO_id fbo))
      (glDrawBuffers 1 drawbufs_ptr)
      (glClear (bor GL_COLOR_BUFFER_BIT GL_DEPTH_BUFFER_BIT))
      ;; draw the things
      (gl_draw_particles)
      (gl_draw_field)
      ;; render it to screen from FBO
      (gl_draw_framebuffer)
      (glfwPollEvents)
      (glfwSwapBuffers window)
      (let ((next_time (+ time (convert (* 44100. delta_t)))))
        (callback next_time gl_draw_loop next_time delta_t)))))

;; start it running
(gl_draw_loop (now) (/ 1. 60.))
