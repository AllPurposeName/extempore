;;; compiler.xtm -- tests for compiler infrastructure

;; Author: Ben Swift
;; Keywords: extempore
;; Required dylibs:

;;; Commentary:

;; Current test coverage: 0.00001% - but you've gotta start somewhere

;;; Code:

(sys:load "libs/core/test.xtm")

;; bind-func

(xtmtest
 '(bind-func simplefunc
    "simplefunc docstring"
    (lambda ()
      864))
 (simplefunc)
 864)

(xtmtest-result (impc:ti:closure-exists? "simplefunc") #t)
(xtmtest-result (equal? (impc:ti:get-closure-arg-types "simplefunc")
                        '("i64"))
                #t)
(xtmtest-result (equal? (impc:ti:get-closure-type "simplefunc")
                        '(213 2))
                #t)

(xtmtest
 '(bind-func twoargfunc
    "simplefunc docstring"
    (lambda (a:i64 b)
      (* a b 2)))
 (twoargfunc 2 6)
 24)

(xtmtest-result (equal? (impc:ti:get-closure-arg-types "twoargfunc")
                        (list "i64" "i64" "i64"))
                #t)

(xtmtest
 '(bind-func test_mzone_type
    (lambda ()
      (let ((mz:mzone* null))
        mz)))
 (test_mzone_type))

;; this is in the stdlib
(bind-func zcopy_i1
  (lambda (x:i1 fromz:mzone* toz:mzone*) x))

;; bind-val tests

(xtmtest
 '(bind-val benval i64)
 (begin
   (bind-func test_benval
     (lambda ()
       (set! benval 42)
       benval))
   (test_benval))
 42)

;; bind-type

(bind-type BenType <i32,i32>)

(bind-func test_bentype
  (lambda ()
    (let ((bt (BenType 3 0)))
      bt)))

;; TODO this is where it's failing currently - the "i8*" cdr of ("%__fptr528" "i8*") is trying to be cdr'd again, which fails.

;; need to find out how to excercise the impc:ir:apply-closure code
;; path in the old version? what should the ast be at this point? Have
;; I stuffed up my cache gets somehow?  Also, why is it __fptr528 ?

(let ((ast '(("%__fptr528" "i8*") a b))
      (types '((bt . "%BenType*") (a . 4) (b . 4) (test_bentype 213 4 4 4)))
      (ftype-provided? #t))
  (if ftype-provided?
      (cdr (impc:ir:get-type-from-str (cadar ast)))
      (if (and (assoc-strcmp (car ast) types)
               (impc:ir:closure? (cdr (assoc-strcmp (car ast) types)))
               (= 2 (impc:ir:get-ptr-depth (cdr (assoc-strcmp (car ast) types)))))
          (cddr (assoc-strcmp (car ast) types))
          (if (impc:ir:closure? (cdr (assoc-strcmp (car ast) types)))
              (impc:compiler:print-bad-type-error (car ast) "remember that closures must be pointers")
              (impc:compiler:print-bad-type-error (car ast) "bad type for closure")))))

(bind-func test_bentype
  (lambda (a b)
    (let ((bt:BenType* (BenType a b)))
      (+ (tref bt 0)
         (tref bt 1)))))

(bind-func test_bentype2
  (lambda (a b)
    (BenType a b)))

(bind-func test_bentype
  (lambda (a b)
    (let ((bt:BenType* (alloc)))
      (tfill! bt a b)
      (+ (tref bt 0)
         (tref bt 1)))))

(bind-func funcone
  (lambda (a)
    (+ a 2)))

(println (llvm:get-globalvar "funcone"))

(bind-func functwo
  (lambda (b)
    (+ (funcone b) 4)))

(println (test_bentype 4 5))

(println (impc:ir:get-named-type "BenType"))
(println (impc:ti:closure-exists? "BenType"))
(println (llvm:get-globalvar "BenType"))
(println (llvm:get-global-variable-type "BenType"))
(set! *impc:compiler:verbose* #f)

(println "stophere")

(set! *impc:ti:print-main-check* #f)
(set! *impc:ti:print-sub-checks* #f)

(set! *impc:ti:print-main-check* #t)
(set! *impc:ti:print-sub-checks* #t)

(println (macro-expand '(bind-type bentype3 <i32,i32>)))

(println (impc:ir:get-type-str (impc:ti:get-namedtype-type "bentype1")))
(println (llvm:get-named-type "bentype1"))


;; TODO - fix the already-bound-error invocations so that they get
;; passed a pretty string (or convert to one internally)

;; figure out what's going wrong with build-type-dataconstructor













(println (llvm:get-function-args-withoutzone "test_mzone_type"))
(println (impc:ti:get-closure-arg-types "test_mzone_type"))
(println (impc:ir:get-type-str 2))



(let* ((closure-type "<{i8*, i8*, %mzone* (i8*, i8*)*}>**")
       (closure-type "{i8*, i8*, %mzone* (i8*, i8*)*}**"))
  (println 'p3 (map impc:ir:get-type-str
              (cdr (impc:ir:get-type-from-str closure-type))))
  (println))

(println )

(println (llvm:get-named-type "mzone"))
(println (impc:ir:get-named-type "mzone"))
(println (impc:ti:get-tuple-type-from-name "mzone"))
(println (impc:ir:get-type-from-pretty-str "<i8*,i32,i8*,i64,clsvar*>"))
(println (impc:ir:get-type-from-pretty-str (impc:ti:get-namedtype-type "mzone")))
(xtmtest-result (impc:ti:namedtype-exists? "bentype4") #t)

(xtmtest-result (impc:ir:get-base-type "<i64>**") "<i64>")
(xtmtest-result (impc:ir:get-ptr-depth "<i64>**") 2)

(xtmtest-result (equal? (impc:ir:get-type-from-str "{ i64 }")
                        (impc:ir:get-type-from-pretty-str "<i64>"))
                #t)

(bind-alias benalias i32)

;; named type tests


;; TODO

;; in LLVM IR, look for all the places that check if a named type
;; exists, and see if they need an % prepended to them

;; the error is initally coming from the closure,
;; e.g. ir:get-type-from-pretty-str stype: "{i8*, i8*, bentype2* (i8*, i8*, i64)*}**" args: NIL


(bind-func zcopy_i1
  (lambda (x:i1 fromz:mzone* toz:mzone*) x))

(println (impc:ir:get-base-type "%mzone"))

(println (impc:ir:str-list-check "%mzone**"))
(println (impc:ir:str-list-check "{ i64 }"))

(println (impc:ir:tuple? "%mzone**"))

;; this is different (old vs new)
(println (impc:ir:get-type-size "{ i64 i32 }")) ;; old 12, new 16
(println (impc:ir:get-type-size "{ i64 i8}")) ;; old 12, new 16
(println (impc:ir:get-type-size "{ i8 i64 }")) ;; old 12, new 16
(println (impc:ir:get-type-size "{ i64 i64 i64 i64 i64 i64 i32 }")) ;; old 52, new 56

(println (llvm:get-struct-size "{ i8, i64 }"))


(bind-val benval i64)

(bind-type fred <fred*>)

(bind-type IntList <i64,List*>)

(println (llvm:get-named-type "%mzone"))
(println (impc:ti:get-namedtype-type "%mzone"))

(println (impc:ir:str-list-check "{ i64 }*"))

(bind-type Pair <i32,i32>)



(println (impc:ir:tuple? "%mzone"))

(println (impc:ir:get-type-from-pretty-str "mzone"))
(println (impc:ir:get-type-from-str (impc:ir:get-type-from-pretty-str "mzone")))


(xtmtest-result (not (llvm:get-globalvar "benval")) #f)

(xtmtest-result (impc:ti:get-globalvar-type "benval") "i64")

(let ((types '("i32" "<i64>" "[i64,i8]" "|4,i1|")))
  (for-each (lambda (t)
              (println 't: t)
              (let ((ugly (impc:ir:get-type-from-str t))
                    (pretty (impc:ir:get-type-from-pretty-str t)))
                (if (not (equal? ugly pretty))
                    (println 'ugly: ugly 'pretty: pretty))))
            types))

(impc:ir:get-type-from-pretty-str (impc:ti:get-globalvar-type "benval"))
(impc:ir:get-type-from-pretty-str "[i64]")


(xtmtest
 '(bind-val bentuple <i64,i64,i8>)
 (call-as-xtlang
  (tfill! bentuple 1 2 3)
  (println "benval:" benval)
  (tref bentuple 1))
 2)

(bind-val bentuple <i64,i64,i8>)

(bind-func dostuff_with_bentuple
  (lambda ()
    (tfill! bentuple 1 2 3)
    (printf "benval: %lld\n" benval)
    (tref bentuple 1)))

(xtmtest-result (impc:ti:get-globalvar-type "bentuple")
                "<i64,i64,i8>")

(bind-alias envt i8*)

(println *impc:ir:type-aliases*)

(bind-func audio_64bit (lambda () #f))

(impc:ti:get-nativefunc-arg-types "impc_false")

;; this currently fails
(bind-val benval i64)
(bind-func func_with_gv_ref
  (lambda ()
    (set! benval 64)
    benval))

(func_with_gv_ref)

(llvm:get-global-variable-type "benval")

(impc:ir:type? "i64")

(impc:ir:gname)

(impc:ti:print-closure-list)
(impc:ti:print-globalvar-list)


;; places to check:










(bind-func testextref
  (lambda ()
    (set! benval 22)
    void))

(impc:ir:get-type-from-pretty-str "[i64,i64,i32]")
(impc:ir:get-type-from-str "{ i64 }")
(impc:ir:get-type-from-pretty-str "|2,i64|")


;; some poly stuff

(bind-poly simplefunc-poly simplefunc)
(bind-poly random imp_randf)

(bind-type bentype <i64>)



(println '*impc:ir:polytypes*: *impc:ir:polytypes*)

(xtmtest-result (impc:ir:pointer? "%bentype") #f)

(impc:ti:print-namedtype-list)

(impc:ir:get-pretty-tuple-arg-strings "<i64>")

(impc:ir:get-base-type "bentype***")


(xtmtest-print-results)

(bind-val benptr i64**)

(sys:load "libs/core/std.xtm")

(println (impc:ir:get-function-type "imp_randf"))
(println (impc:ir:get-function-type "audio_64bit"))



(println (impc:ti:get-closure-or-nativefunc-type "imp_randf"))
(println (impc:ir:pretty-print-type (impc:ir:get-type-from-pretty-str (impc:ti:get-closure-or-nativefunc-type "audio_64bit"))))
(println (impc:ti:get-closure-or-nativefunc-type "audio_64bit"))

(let ((ast '(ret-> zcopy_i1 zcopy_i1)))
  (symbol? (caddr ast)))

(bind-func test_namedtype
  (lambda (zone:mzone*)
    zone))

"(catch (quit 1) (bind-func test_namedtype (lambda (zone:mzone*) zone)))"

(impc:compiler:print-bad-type-error "mzone" "and this is the problem")

(bind-type benpoly <!a>)

(bind-func test_benpoly2
  (lambda ()
    (let ((bp (benpoly 35)))
      (tref bp 0))))



(println *impc:ir:gpolytypes*)
(println *impc:ir:polytypes*)

(println (impc:ir:gpolytype-types 'benpoly))
(println (impc:ir:polytype-types 'benpoly))

(impc:ir:types-equal? "%mzone" "i64**")

(let ((base (impc:ir:get-base-type "mzone*")))
  (println base)
  (println (llvm:get-named-type base))
  (println (impc:ir:get-type-from-pretty-str (impc:ir:get-named-type base)))
  (println (impc:ir:get-type-str (impc:ir:get-type-from-pretty-str (impc:ir:get-named-type base))))
  (println))

(println (llvm:get-named-type "%mzone"))

(impc:ir:get-named-type "bentype")
(impc:ir:get-named-type "benpoly")
(llvm:get-named-type "bentype")


(impc:ir:get-tuple-type-from-str "{ i64, i64 }")

;; updated understanding of the problem:

;; impc:ir:get-named-type used to return a LLVM IR (string)
;; representation of the type, but now (under the new scheme cache
;; regie) returns an xtlang pretty string type. (note that for generic
;; types this is further messed up - returns a symbol and a list of
;; list-types respectively).

;; HOWEVER, mzone and clsvar (special types, declared in IR) are
;; packed types (i.e. <{}> rather than just {} in LLVM IR) and the
;; cache currently doesn't know how to return this (since xtlang's
;; pretty types don't have a notation for packed types).

;; the options are, to try and fix it:

;; - special-case these two named types to return the right (packed) IR string

;; - create a notation for packed types in xtlang

;; - change make-tuple to make all xtlang types (tuples) packed

;; - store LLVM IR (rather than xtlang pretty) type strings in the cache

;; these options aren't mutually exclusive. some of them need to work
;; together to fix it. I think I favour option 1 for the moment.




;; for git bisect - ./extempore --nostd --eval "(catch (quit 1) (bind-func test_namedtype (lambda (zone:mzone*) zone)))"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; alignment issues - things to check

;; looks like we need to special-case the 64-bit to be 4 aligned

;; what about floats/doubles""

;; vector?  check /4,float/ and /2,double/ in particluar
