;;; compiler.xtm -- tests for compiler infrastructure

;; Author: Ben Swift
;; Keywords: extempore
;; Required dylibs:

;;; Commentary:

;; Current test coverage: 0.00001% - but you've gotta start somewhere

;;; Code:

(sys:load "libs/core/test.xtm")

(impc:ti:update-closure-list "benclosure"
                              "[i64,i64]*"
                              "this is the docstring"
                              '((a . "i64"))
                              '(lambda (a) (+ a 42)))

(xtmtest-result (impc:ti:get-closure-type "benclosure") "[i64,i64]*")

(impc:ti:update-closure-list "benclosure"
                              "[i64,i64]*"
                              "this is the second docstring"
                              '()
                              '(lambda (a) 42))

(xtmtest-result (impc:ti:get-closure-docstring "benclosure")
                "this is the second docstring")

(bind-func simplefunc
  "simplefunc docstring"
  (lambda ()
    864))

(println (simplefunc))

(equal? (llvm:get-function "simplefunc")
        (llvm:get-function-pointer "simplefunc"))

(xtmtest
 '(bind-func simplefunc
    "simplefunc docstring"
    (lambda ()
      864))
 (simplefunc)
 864)

(xtmtest-result (impc:ti:closure-exists? "simplefunc") #t)
(xtmtest-result (impc:ti:get-closure-type "simplefunc") "[i64]*")


(xtmtest
 '(bind-func twoargfunc
    "simplefunc docstring"
    (lambda (a:i64 b)
      (* a b 2)))
 (twoargfunc 2 6)
 24)

(xtmtest-result (equal? (impc:ti:get-closure-arg-types "twoargfunc")
                        (list "i64" "i64" "i64"))
                #t)

;; bind-val tests

(xtmtest
 '(bind-val benval i64)
 (call-as-xtlang
  (set! benval 42)
  (println "benval:" benval)
  benval)
 42)

(bind-val benval i64)


(xtmtest-result (not (llvm:get-globalvar "benval")) #f)

(xtmtest-result (impc:ti:get-globalvar-type "benval") "i64")

(let ((types '("i32" "<i64>" "[i64,i8]" "|4,i1|")))
  (for-each (lambda (t)
              (println 't: t)
              (let ((ugly (impc:ir:get-type-from-str t))
                    (pretty (impc:ir:get-type-from-pretty-str t)))
                (if (not (equal? ugly pretty))
                    (println 'ugly: ugly 'pretty: pretty))))
            types))

(impc:ir:get-type-from-pretty-str (impc:ti:get-globalvar-type "benval"))
(impc:ir:get-type-from-pretty-str "[i64]")


(xtmtest
 '(bind-val bentuple <i64,i64,i8>)
 (call-as-xtlang
  (tfill! bentuple 1 2 3)
  (println "benval:" benval)
  (tref bentuple 1))
 2)

(bind-val bentuple <i64,i64,i8>)

(bind-func dostuff_with_bentuple
  (lambda ()
    (tfill! bentuple 1 2 3)
    (printf "benval: %lld\n" benval)
    (tref bentuple 1)))

(xtmtest-result (impc:ti:get-globalvar-type "bentuple")
                "<i64,i64,i8>")

(bind-alias envt i8*)

(println *impc:ir:type-aliases*)

(set! *impc:ti:print-main-check* #t)
(set! *impc:ti:print-sub-checks* #t)

(set! *impc:ti:print-main-check* #f)
(set! *impc:ti:print-sub-checks* #f)

(bind-func audio_64bit (lambda () #f))

(impc:ti:get-nativefunc-arg-types "impc_false")

;; this currently fails
(bind-val benval i64)
(bind-func func_with_gv_ref
  (lambda ()
    (set! benval 64)
    benval))

(func_with_gv_ref)

(llvm:get-global-variable-type "benval")

(impc:ir:type? "i64")

(impc:ir:gname)

(impc:ti:print-closure-list)
(impc:ti:print-globalvar-list)


;; places to check:










(bind-func testextref
  (lambda ()
    (set! benval 22)
    void))

(impc:ir:get-type-from-pretty-str "[i64,i64,i32]")
(impc:ir:get-type-from-str "{ i64 }")
(impc:ir:get-type-from-pretty-str "|2,i64|")

;; bind-type

(bind-type bentype <i64>)

(xtmtest-result (impc:ti:namedtype-exists? "bentype") #t)

(xtmtest-result (impc:ir:get-base-type "<i64>**") "<i64>")
(xtmtest-result (impc:ir:get-ptr-depth "<i64>**") 2)

(xtmtest-result (equal? (impc:ir:get-type-from-str "{ i64 }")
                        (impc:ir:get-type-from-pretty-str "<i64>"))
                #t)

;; some poly stuff

(bind-poly simplefunc-poly simplefunc)
(bind-poly random imp_randf)

(bind-type bentype <i64>)



(println '*impc:ir:polytypes*: *impc:ir:polytypes*)

(xtmtest-result (impc:ir:pointer? "%bentype") #f)

(impc:ti:print-namedtype-list)

(impc:ir:get-pretty-tuple-arg-strings "<i64>")

(impc:ir:get-base-type "bentype***")


(xtmtest-print-results)

(bind-val benptr i64**)

(sys:load "libs/core/std.xtm")

(println (impc:ir:get-function-type "imp_randf"))
(println (impc:ir:get-function-type "audio_64bit"))



(println (impc:ti:get-closure-or-nativefunc-type "imp_randf"))
(println (impc:ir:pretty-print-type (impc:ir:get-type-from-pretty-str (impc:ti:get-closure-or-nativefunc-type "audio_64bit"))))
(println (impc:ti:get-closure-or-nativefunc-type "audio_64bit"))

(let ((ast '(ret-> zcopy_i1 zcopy_i1)))
  (symbol? (caddr ast)))


"(catch (quit 1) (bind-func test_namedtype (lambda (zone:mzone*) zone)))"

(impc:compiler:print-bad-type-error "mzone" "and this is the problem")

(bind-type benpoly <!a>)

(bind-func test_benpoly2
  (lambda ()
    (let ((bp (benpoly 35)))
      (tref bp 0))))



(println *impc:ir:gpolytypes*)
(println *impc:ir:polytypes*)

(println (impc:ir:gpolytype-types 'benpoly))
(println (impc:ir:polytype-types 'benpoly))

(impc:ir:types-equal? "%mzone" "i64**")

(let ((base (impc:ir:get-base-type "mzone*")))
  (println base)
  (println (llvm:get-named-type base))
  (println (impc:ir:get-type-str (impc:ir:get-type-from-pretty-str (impc:ir:get-named-type base)))))



(impc:ir:get-named-type "bentype")
(impc:ir:get-named-type "benpoly")
(llvm:get-named-type "bentype")


(impc:ir:get-tuple-type-from-str "{ i64, i64 }")

;; updated understanding of the problem:

;; impc:ir:get-named-type used to return a LLVM IR (string)
;; representation of the type, but now (under the new scheme cache
;; regie) returns an xtlang pretty string type. (note that for generic
;; types this is further messed up - returns a symbol and a list of
;; list-types respectively).

;; HOWEVER, mzone and clsvar (special types, declared in IR) are
;; packed types (i.e. <{}> rather than just {} in LLVM IR) and the
;; cache currently doesn't know how to return this (since xtlang's
;; pretty types don't have a notation for packed types).

;; the options are, to try and fix it:

;; - special-case these two named types to return the right (packed) IR string

;; - create a notation for packed types in xtlang

;; - change make-tuple to make all xtlang types (tuples) packed

;; - store LLVM IR (rather than xtlang pretty) type strings in the cache

;; these options aren't mutually exclusive. some of them need to work
;; together to fix it. I think I favour option 1 for the moment.




;; for git bisect - ./extempore --nostd --eval "(catch (quit 1) (bind-func test_namedtype (lambda (zone:mzone*) zone)))"
