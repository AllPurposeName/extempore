;;; generics.xtm -- rudimentary unit testing for xtlang code

;; Author: Andrew Sorensen
;; Keywords: extempore

;;; Commentary:

;; a test suite for xtlang generics code.

;;; Code:

(define start_time (now))

(sys:load "tests/test.xtm")


;; (define *impc:ti:print-full-generic-types* #t)
;; (define *impc:ti:print-code-specialization-compiles* #t)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 
;; generic types
;;

;; Generic Point {x,y}
(bind-type Point <!a,!a>)

;; make and return a Point
(bind-func test_point_1
  "Test doc-string"
  (lambda ()
    (let ((x (Point 1.0 2.0)))
      x)))

(bind-func test_point_2
  (lambda ()
    (let ((x (Point 1 2)))
      x)))

;; print the point
(bind-func test_point_3
  (lambda ()
    (let ((x (test_point_1))
          (y (test_point_2)))
      (println x y))))

(test-xtfunc (test_point_3))


;; Generic Size {width,height}
(bind-type Size <!a,!a>)
;; points and size must be the same primitive type!
(bind-type Rectangle <Point*,Size*>)
;; this basically the same as Rectangle
(bind-type RectangleA <Point:<!a,!a>*,Size:<!a,!a>*>)
;; this allows *different* point and size primitives
(bind-type RectangleB <Point:<!a,!a>*,Size:<!b,!b>*>)

;; make some rectangles
(bind-func test_rectangle_1
  (lambda ()
    (let ((a (Rectangle (Point 1 2) (Size 3 4)))
          (b (RectangleA (Point 5 6) (Size 7 8)))
          (c (RectangleB (Point 9. 10.) (Size 11 12))))
      c)))

(bind-func test_rectangle_2
  (lambda ()
    (let ((a (Rectangle (Point 1 2) (Size 3 4)))
          (b (RectangleA (Point 5 6) (Size 7 8)))
          (c (RectangleB (Point 9. 10.) (Size 11 12))))
      (println a)
      (println b)
      (println c))))

(test-xtfunc (test_rectangle_2))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; recursive generic types
;;

(bind-type Tree <!a,Tree*,Tree*>)

(bind-func Leaf:[Tree:<!a,Tree*,Tree*>*,!a]*
  "Make A Leaf"
  (lambda (x)
    (let ((t (Tree x null null)))
      t)))

(bind-func tree_value:[!a,Tree*]*
  (lambda (t)
    (tref t 0)))

(bind-func print_tree:[void,Tree*]*
  (lambda (t)
    (let ((f (lambda (t)
               (if (null? t) void
                   (begin
                     (printout (tree_value t) " ")
                     (f (tref t 1))
                     (f (tref t 2))
                     void)))))      
      (f t)
      (println))))


(bind-func tree_test
  (lambda ()
    (let ((t1 (Leaf 3))
          (t2 (Leaf 4))
          (t3 (Tree 2 t1 t2))
          (t4 (Tree 1 t3 null))
          (t5 (Leaf (Point 3.0 4.0)))
          (t6 (Tree (Point 1.0 2.0) t5 null)))
      (println)
      (printout "Integer Tree: ")
      (print_tree t4)
      (printout "Point Tree: ")
      (print_tree t6)
      (println))))

(test-xtfunc (tree_test))


;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; list tests
;;

(bind-func test_list_1
  (lambda ()
    (let ((l (list 1 2 3 4 5)))
      (list_print l)
      (car (cdr l)))))

(test-xtfunc (test_list_1) 2)

(bind-func test_list_2
  (lambda ()
    (let ((l (list 1 2 3 4 5))
          (l2 (map (lambda (x) (* x x)) l)))
      (list_print l2))))

(test-xtfunc (test_list_2))

;; note that f is type checked independtly
;; at the moment and so requires explicit
;; type in this instance.
(bind-func test_list_3
  (lambda ()
    (let ((l (list 1.0 2.0 3.0 4.0))
          (f (lambda (x:double) (* x x)))
          (l2 (map f l)))
      (list_print l2))))

(test-xtfunc (test_list_3))

(bind-func test_set_car
  (lambda ()
    (let ((lst (list 1 2 3)))
      (set_car (nth_tail lst 1) 5)
      (list_print lst)
      (= (nth lst 1) 5))))

(test-xtfunc (test_set_car) 1)

(bind-func test_set_cdr
  (lambda ()
    (let ((lst1 (list 1 2 3))
	  (lst2 (list 4 5 6)))
      (set_cdr (nth_tail lst1 2) lst2)
      (list_print lst1)
      (= (length lst1) 6))))

(test-xtfunc (test_set_cdr) 1)

;; map2
(bind-func test_list_4
  (lambda ()
    (let ((l1 (list 1 2 3 4))
          (l2 (list 1.0 2.0 3.0 4.0)))
      (map2 (lambda (a b) (Pair a b)) l1 l2))))

(bind-func test_list_5
  (lambda ()
    (let ((l (test_list_4)))
      (for-each (lambda (x) (println x)) l))))

(test-xtfunc (test_list_5))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; lists of lists

(bind-func test_list_6
  (lambda ()
    (let ((l1 (list 1 2 3))
          (l2 (list l1 l1 l1)))
      l2)))

(bind-func test_list_7
  (lambda ()
    (let ((l1 (list 1 2 3))
          (l2 (list l1 l1))
          (l3 (list l2 l2)))
      l3)))

(bind-func test_list_8
  (lambda ()
    (let ((l1 (list (Point 1 2) (Point 3 4) (Point 5 6)))
          (l2 (list l1 l1 l1)))
      (for-each (lambda (x)                  
                  ;; type inferencer needs a
                  ;; little help here
                  ;; (should try to fix this!
                  (for-each (lambda (x:Point:<i64,i64>*)
                              (printout x ","))
                            x)
                  (println))                
                l2)
      l2)))

(test-xtfunc (test_list_8))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; test some list functions
;;

(bind-func test_append_insert_length
  (lambda ()
    (let ((v1 (list 1 2 3 4))
          (v2 (list 5 6 7 8))
          (v3 (append v1 v2)))
      (insert v3 4 77)
      (list_print v3)
      (println "length:" (length v3))
      (length v3))))

(test-xtfunc (test_append_insert_length) 9)

(bind-func test_list_membership
  (lambda (x)
    (let ((pred (lambda (a:i64 b) (= a b)))
	  (lst (list 1 2 3))
	  (result (member x lst pred)))
      (if (not (null? result))
	  (println "list contains" x)
	  (println "list does not contain" x))
      (not (null? result)))))

(test-xtfunc (test_list_membership 2) 1)
(test-xtfunc (test_list_membership 4) 0)

(bind-func test_list_swap
  (lambda ()
    (let ((lst (list 1 2 3 4 5)))
      (swap lst 1 3)
      (list_print lst)
      (= (nth lst 1) 4))))

(test-xtfunc (test_list_swap) 1)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; assoc lists

(bind-func test_assoc_1
  (lambda ()
    (let ((dict (list (Pair (Str "Andrew") 40)
                      (Pair (Str "Alison") 39)
                      (Pair (Str "Ben") 29))))
      dict)))

(bind-func test_assoc_2
  (lambda ()
    (let ((dict (test_assoc_1)))
      (list_print dict)
      ;; (for-each (lambda (p) (println p)) dict)
      (println "Ben is" (dict_find dict (Str "Ben")) "years old")
      (println "Andrew is" (dict_find dict (Str "Andrew")) "years old")
      void)))

(test-xtfunc (test_assoc_2))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; BTree

(bind-func btree_test_1
  (lambda ()
    (let ((t1 (BLeaf 3))
          (t2 (BLeaf 4))
          (t3 (BTree 2 t1 t2))
          (t4 (BTree 1 t3 null)))
      (print_btree t4)
      t3)))

(test-xtfunc (btree_test_1))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; a maybe monad test
;;

(bind-type Maybe <i1,!a>)

(bind-func return_maybe:[Maybe:<i1,!a>*,!a]*
  (lambda (x)
    (let ((maybe (Maybe #t x)))
      maybe)))

(bind-func nothing_maybe:[Maybe*,!a]*
  (lambda (x)
    (let ((maybe (Maybe #f x)))
      maybe)))

(bind-func bind_maybe:[Maybe:<i1,!b>*,Maybe:<i1,!a>*,[Maybe:<i1,!b>*,!a]*]*
  (lambda (m f)
    (if (tref m 0)
        (f (tref m 1))
        (nothing_maybe 0))))

;; maybe multiply i32 
(bind-func maybe_mul
  (lambda (a:Maybe:<i1,i32>* b:Maybe:<i1,i32>*)
    (bind_maybe
     a (lambda (x:i32)
         (bind_maybe
          b (lambda (y:i32)
              (let ((z (* x y)))
                (if (> z (i64toi32 50))
                    (nothing_maybe (i64toi32 0))
                    (return_maybe z)))))))))

(bind-func maybe_print
  (lambda (x:i32)
    (let ((w (printf "%d\n" x)))
      (if (>= w 0)
          (return_maybe w)
          (nothing_maybe 0)))))

(bind-func test
  (lambda (w:i32)
    (let ((x (return_maybe w))
          (y (return_maybe (i64toi32 5)))
          (z (return_maybe (i64toi32 2)))
          (res (maybe_mul x (maybe_mul y z))))
      (bind_maybe res maybe_print)
      void)))
      
;; should print 30 40 and 50
(test-xtfunc (test 3))
(test-xtfunc (test 4))
;; but NOT 60
(test-xtfunc (test 6))
;; and of course 20 is ok!
(test-xtfunc (test 2))


(print-test-results)

(println 'total-time: (* 1.0 (/ (- (now) start_time) *samplerate*)) 'seconds)

