;;
;; Copyright (c) 2011, Andrew Sorensen
;;
;; All rights reserved.
;;
;;
;; Redistribution and use in source and binary forms, with or without
;; modification, are permitted provided that the following conditions are met:
;;
;; 1. Redistributions of source code must retain the above copyright notice,
;;    this list of conditions and the following disclaimer.
;;
;; 2. Redistributions in binary form must reproduce the above copyright notice,
;;    this list of conditions and the following disclaimer in the documentation
;;    and/or other materials provided with the distribution.
;;
;; Neither the name of the authors nor other contributors may be used to endorse
;; or promote products derived from this software without specific prior written
;; permission.
;;
;;
;; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;; ARE DISCLEXTD. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
;; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;; POSSIBILITY OF SUCH DAMAGE.
;;
;;

;;;;;;;;;;;;;;;;;;;;;;;;;
;; GLOBAL XTLANG CACHE ;;
;;;;;;;;;;;;;;;;;;;;;;;;;

;; global lists which cache the state (especially types) of all the
;; things.

;; types should be stored in the list format, although they can be
;; printed prettily, obviously

;;;;;;;;;;;;;;
;; named types
;; -----------
;;
(define *impc:ti:namedtype-list* '(("mzone" . #((list 14 108 2 2 2 "%mzone*") "Extempore memory zone"))
                                   ("clsvar" . #((list 14 108 4 108 2 "%clsvar*") "Extempore closure address table: <name,offset,type,TODO_whatisthis,next_table>"))))
;;
;; each element of the list is of the form
;;
;; (name . #(type docstring))

(define impc:ti:print-namedtype-list
  (lambda ()
    (println '*impc:ti:namedtype-list*: *impc:ti:namedtype-list*)))

(define impc:ti:reset-namedtype-list
  (lambda ()
    (set! *impc:ti:namedtype-list* '())))

;; type is immutable, doesn't need a setter
(define impc:ti:get-namedtype-type
  (lambda (namedtype-name)
    (let ((cls-list (assoc-strcmp (impc:ir:clean-named-type namedtype-name) *impc:ti:namedtype-list*)))
      ;; (println 'namedtype-name: namedtype-name 'cls-list: cls-list)
      (if cls-list (vector-ref (cdr cls-list) 0) #f))))

(define impc:ti:namedtype-exists?
  (lambda (namedtype-name)
    (if (impc:ti:get-namedtype-type namedtype-name) #t #f)))

(define impc:ti:register-new-namedtype
  (lambda (namedtype-name type docstring)
    (if (impc:ti:namedtype-exists? namedtype-name)
        (impc:compiler:print-already-bound-error namedtype-name type)
        ;; check arg types
        (if (not (and (or (string? namedtype-name) (begin (println 'namedtype-name: namedtype-name) #f))
                      (or (or (list? type) (integer? type)) (begin (println 'type: type) #f))
                      (or (string? docstring) (begin (println docstring) #f))))
            (impc:compiler:print-compiler-error "couldn't register new named type")
            (set! *impc:ti:namedtype-list*
                  (cons (cons namedtype-name (vector type docstring))
                        *impc:ti:namedtype-list*))))))

(define impc:ti:get-namedtype-docstring
  (lambda (namedtype-name)
    (let ((cls-list (assoc-strcmp (impc:ir:clean-named-type namedtype-name) *impc:ti:namedtype-list*)))
      (if cls-list (vector-ref (cdr cls-list) 1) #f))))

(define impc:ti:set-namedtype-docstring
  (lambda (namedtype-name docstring)
    (let ((cls-list (assoc-strcmp (impc:ir:clean-named-type namedtype-name) *impc:ti:namedtype-list*)))
      (if cls-list (vector-set! (cdr cls-list) 1 docstring) #f))))

;;;;;;;;;;;
;; closures
;; --------
;;
(define *impc:ti:closure-list* '())
;;
;; each element of the list is of the form
;;
;; (name . #(type docstring body))
;;
;; this list replaces *impc:closuretypes*, *impc:closurebodies* and *impc:docstrings*
;;
;; TODO:
;;
;; - if we keep these lists sorted, then lookups become O(log2(N))
;;   rather than O(N) (or we could even use a hash-map one day...)

(define impc:ti:print-closure-list
  (lambda ()
    (println '*impc:ti:closure-list*: *impc:ti:closure-list*)))

(define impc:ti:reset-closure-list
  (lambda ()
    (set! *impc:ti:closure-list* '())))

(define impc:ti:register-new-closure
  (lambda (closure-name type docstring body)
    ;; check arg types
    (if (not (and (or (string? closure-name) (begin (println 'closure-name: closure-name) #f))
                  (or (list? type) (begin (println 'type: type) #f))
                  (or (string? docstring) (begin (println docstring)))
                  (or (list? body) (begin (println 'body: body) #f))))
        (impc:compiler:print-compiler-error "couldn't register new closure")
        (let ((existing (assoc-strcmp closure-name *impc:ti:closure-list*)))
          (if existing
              ;; update details if it already exists
              (set-cdr! existing (vector type docstring body))
              ;; or create a new entry
              (set! *impc:ti:closure-list*
                    (cons (cons closure-name (vector type docstring body))
                          *impc:ti:closure-list*)))))))

(define impc:ti:get-closure-type
  (lambda (closure-name)
    (let ((cls-list (assoc-strcmp closure-name *impc:ti:closure-list*)))
      ;; (println 'cls-list: cls-list)
      (if cls-list (vector-ref (cdr cls-list) 0) #f))))

(define impc:ti:get-closure-arg-types
  (lambda (name)
    (let ((type (impc:ti:get-closure-type name)))
      (if (or (not type) (null? type))
          #f
          (map impc:ir:get-type-str (cdr type))))))

(define impc:ti:closure-exists?
  (lambda (closure-name)
    (let ((res (impc:ti:get-closure-type closure-name)))
      (if (and res (not (null? res))) #t #f))))

(define impc:ti:set-closure-type
  (lambda (closure-name type)
    (let ((cls-list (assoc-strcmp closure-name *impc:ti:closure-list*)))
      (if cls-list (vector-set! (cdr cls-list) 0 type) #f))))

(define impc:ti:get-closure-docstring
  (lambda (closure-name)
    (let ((cls-list (assoc-strcmp closure-name *impc:ti:closure-list*)))
      (if cls-list (vector-ref (cdr cls-list) 1) #f))))

(define impc:ti:set-closure-docstring
  (lambda (closure-name docstring)
    (let ((cls-list (assoc-strcmp closure-name *impc:ti:closure-list*)))
      (if cls-list (vector-set! (cdr cls-list) 1 docstring) #f))))

(define impc:ti:get-closure-body
  (lambda (closure-name)
    (let ((cls-list (assoc-strcmp closure-name *impc:ti:closure-list*)))
      (if cls-list (vector-ref (cdr cls-list) 2) #f))))

(define impc:ti:set-closure-body
  (lambda (closure-name body)
    (let ((cls-list (assoc-strcmp closure-name *impc:ti:closure-list*)))
      (if cls-list (vector-set! (cdr cls-list) 2 body) #f))))


;;;;;;;;;;;;;;;;;;;;;;;
;; native (C) functions
;; --------------------
;;
;; each element of the list is of the form
;;
;; (name . #(type docstring))
;;
(define *impc:ti:nativefunc-list*
  '(;; functions in Extempore binary (defined in {EXTLLVM,SchemeFFI}.cpp)
    ("rmatch" . #((list 213 10 108 108) ""))
    ("rsplit" . #((list 213 10 108 108 108 108) ""))
    ("rreplace" . #((list 213 108 108 108 108 108) ""))
    ("base64_encode" . #((list 213 108 108 2 2) ""))
    ("base64_decode" . #((list 213 108 108 2 2) ""))
    ("cname_encode" . #((list 213 108 108 2 2) ""))
    ("cname_decode" . #((list 213 108 108 2 2) ""))
    ("clock_clock" . #((list 213 0) ""))
    ("swap64f" . #((list 213 2 0) ""))
    ("unswap64f" . #((list 213 0 2) ""))
    ("swap32f" . #((list 213 4 1) ""))
    ("unswap32f" . #((list 213 1 4) ""))
    ("swap64i" . #((list 213 2 2) ""))
    ("unswap64i" . #((list 213 2 2) ""))
    ("swap32i" . #((list 213 4 4) ""))
    ("unswap32i" . #((list 213 4 4) ""))
    ("thread_fork" . #((list 213 108 108 108) ""))
    ("thread_join" . #((list 213 4 108) ""))
    ("thread_kill" . #((list 213 4 108) ""))
    ("thread_self" . #((list 213 108) ""))
    ("thread_sleep" . #((list 213 2 2 2) ""))
    ("mutex_create" . #((list 213 108) ""))
    ("mutex_destroy" . #((list 213 4 108) ""))
    ("mutex_lock" . #((list 213 4 108) ""))
    ("mutex_unlock" . #((list 213 4 108) ""))
    ("mutex_trylock" . #((list 213 4 108) ""))
    ("llvm_threads_get_callback_zone" . #((list 213 "%mzone*") ""))
    ("llvm_runtime_error" . #((list 213 -1 2 108) ""))
    ("llvm_zone_create" . #((list 213 "%mzone*" 2) ""))
    ("llvm_peek_zone_stack" . #((list 213 "%mzone*") ""))
    ("llvm_pop_zone_stack" . #((list 213 "%mzone*") ""))
    ("llvm_push_zone_stack" . #((list 213 -1 "%mzone*") ""))
    ("llvm_zone_destroy" . #((list 213 -1 "%mzone*") ""))
    ("llvm_zone_print" . #((list 213 -1 "%mzone*") ""))
    ("llvm_zone_reset" . #((list 213 "%mzone*" "%mzone*") ""))
    ("llvm_zone_copy_ptr" . #((list 213 10 108 108) ""))
    ("llvm_zone_mark" . #((list 213 -1 "%mzone*") ""))
    ("llvm_zone_mark_size" . #((list 213 2 "%mzone*") ""))
    ("llvm_zone_ptr_set_size" . #((list 213 -1 108 2) ""))
    ("llvm_zone_ptr_size" . #((list 213 2 108) ""))
    ("llvm_zone_malloc" . #((list 213 108 "%mzone*" 2) ""))
    ("llvm_stack_alloc" . #((list 213 108 2) ""))
    ("llvm_ptr_in_zone" . #((list 213 10 "%mzone*" 108) ""))
    ("llvm_ptr_in_current_zone" . #((list 213 10 108) ""))
    ("get_address_table" . #((list 213 "%clsvar*" 108 "%clsvar*") ""))
    ("get_address_offset" . #((list 213 4 108 "%clsvar*") ""))
    ("check_address_type" . #((list 213 10 108 "%clsvar*" 108) ""))
    ("check_address_exists" . #((list 213 10 108 "%clsvar*") ""))
    ("new_address_table" . #((list 213 "%clsvar*") ""))
    ("add_address_table" . #((list 213 "%clsvar*" "%mzone*" 108 4 108 4 "%clsvar*") ""))
    ("llvm_print_pointer" . #((list 213 -1 108) ""))
    ("llvm_print_i32" . #((list 213 -1 4) ""))
    ("llvm_print_i64" . #((list 213 -1 2) ""))
    ("llvm_print_f32" . #((list 213 -1 1) ""))
    ("llvm_print_f64" . #((list 213 -1 0) ""))
    ("llvm_memset" . #((list 213 108 108 4 2) ""))
    ("extitoa" . #((list 213 108 2) ""))
    ("string_hash" . #((list 213 2 108) ""))
    ("llvm_schedule_callback" . #((list 213 -1 2 108) ""))
    ("llvm_get_function_ptr" . #((list 213 108 108) ""))
    ("ascii_text_color" . #((list 213 -1 4 4 4) ""))
    ("llvm_send_udp" . #((list 213 -1 108 4 108 4) ""))
    ("next_prime" . #((list 213 2 2) ""))
    ("malloc" . #((list 213 108 2) ""))
    ("free" . #((list 213 -1 108) ""))
    ("malloc16" . #((list 213 108 2) ""))
    ("free16" . #((list 213 -1 108) ""))
    ("system" . #((list 213 4 108) ""))
    ("getenv" . #((list 213 108 108) ""))
    ("setenv" . #((list 213 4 108 108 4) ""))
    ("unsetenv" . #((list 213 4 108) ""))
    ("abs" . #((list 213 4 4) ""))
    ("llabs" . #((list 213 2 2) ""))
    ("mk_i64" . #((list 213 108 108 2) ""))
    ("mk_i32" . #((list 213 108 108 4) ""))
    ("mk_i16" . #((list 213 108 108 6) ""))
    ("mk_i8" . #((list 213 108 108 8) ""))
    ("mk_i1" . #((list 213 108 108 10) ""))
    ("mk_double" . #((list 213 108 108 0) ""))
    ("mk_float" . #((list 213 108 108 1) ""))
    ("mk_string" . #((list 213 108 108 108) ""))
    ("mk_cptr" . #((list 213 108 108 108) ""))
    ("i64value" . #((list 213 2 108) ""))
    ("i32value" . #((list 213 4 108) ""))
    ("i16value" . #((list 213 6 108) ""))
    ("i8value" . #((list 213 8 108) ""))
    ("i1value" . #((list 213 10 108) ""))
    ("is_integer" . #((list 213 4 108) ""))
    ("r64value" . #((list 213 0 108) ""))
    ("r32value" . #((list 213 1 108) ""))
    ("is_real" . #((list 213 4 108) ""))
    ("string_value" . #((list 213 108 108) ""))
    ("is_string" . #((list 213 4 108) ""))
    ("cptr_value" . #((list 213 108 108) ""))
    ("is_cptr" . #((list 213 4 108) ""))
    ("is_cptr_or_str" . #((list 213 4 108) ""))
    ("list_ref" . #((list 213 108 108 4 108) ""))
    ("rand" . #((list 213 4) ""))
    ("llvm_tan" . #((list 213 0 0) ""))
    ("llvm_cosh" . #((list 213 0 0) ""))
    ("llvm_tanh" . #((list 213 0 0) ""))
    ("llvm_sinh" . #((list 213 0 0) ""))
    ("llvm_acos" . #((list 213 0 0) ""))
    ("llvm_asin" . #((list 213 0 0) ""))
    ("llvm_atan" . #((list 213 0 0) ""))
    ("llvm_atan2" . #((list 213 0 0 0) ""))
    ("tanf" . #((list 213 1 1) ""))
    ("coshf" . #((list 213 1 1) ""))
    ("tanhf" . #((list 213 1 1) ""))
    ("sinhf" . #((list 213 1 1) ""))
    ("acosf" . #((list 213 1 1) ""))
    ("asinf" . #((list 213 1 1) ""))
    ("atanf" . #((list 213 1 1) ""))
    ("atan2f" . #((list 213 1 1 1) ""))
    ("acosh" . #((list 213 0 0) ""))
    ("asinh" . #((list 213 0 0) ""))
    ("atanh" . #((list 213 0 0) ""))
    ("cbrt" . #((list 213 0 0) ""))
    ("copysign" . #((list 213 0 0 0) ""))
    ("erf" . #((list 213 0 0) ""))
    ("erfc" . #((list 213 0 0) ""))
    ("expm1" . #((list 213 0 0) ""))
    ("fdim" . #((list 213 0 0 0) ""))
    ("fmax" . #((list 213 0 0 0) ""))
    ("fmin" . #((list 213 0 0 0) ""))
    ("hypot" . #((list 213 0 0 0) ""))
    ("ilogb" . #((list 213 0 0) ""))
    ("lgamma" . #((list 213 0 0) ""))
    ("llrint" . #((list 213 2 0) ""))
    ("lrint" . #((list 213 2 0) ""))
    ("rint" . #((list 213 4 0) ""))
    ("llround" . #((list 213 2 0) ""))
    ("lround" . #((list 213 4 0) ""))
    ("log1p" . #((list 213 0 0) ""))
    ("logb" . #((list 213 4 0) ""))
    ("nan" . #((list 213 0 108) ""))
    ("nextafter" . #((list 213 0 0 0) ""))
    ("nexttoward" . #((list 213 0 0 0) ""))
    ("remainder" . #((list 213 0 0 0) ""))
    ("remquo" . #((list 213 0 0 0 108) ""))
    ("scalbn" . #((list 213 0 0 4) ""))
    ("tgamma" . #((list 213 0 0) ""))
    ("trunc" . #((list 213 0 0) ""))
    ("acoshf" . #((list 213 1 1) ""))
    ("asinhf" . #((list 213 1 1) ""))
    ("atanhf" . #((list 213 1 1) ""))
    ("cbrtf" . #((list 213 1 1) ""))
    ("copysignf" . #((list 213 1 1 1) ""))
    ("erff" . #((list 213 1 1) ""))
    ("erfcf" . #((list 213 1 1) ""))
    ("expm1f" . #((list 213 1 1) ""))
    ("fdimf" . #((list 213 1 1 1) ""))
    ("fmaxf" . #((list 213 1 1 1) ""))
    ("fminf" . #((list 213 1 1 1) ""))
    ("hypotf" . #((list 213 1 1 1) ""))
    ("ilogbf" . #((list 213 1 1) ""))
    ("lgammaf" . #((list 213 1 1) ""))
    ("llrintf" . #((list 213 2 1) ""))
    ("lrintf" . #((list 213 2 1) ""))
    ("rintf" . #((list 213 4 1) ""))
    ("llroundf" . #((list 213 2 1) ""))
    ("lroundf" . #((list 213 4 1) ""))
    ("log1pf" . #((list 213 1 1) ""))
    ("log2f" . #((list 213 1 1) ""))
    ("logbf" . #((list 213 4 1) ""))
    ("nanf" . #((list 213 1 108) ""))
    ("nextafterf" . #((list 213 1 1 1) ""))
    ("nexttowardf" . #((list 213 1 1 1) ""))
    ("remainderf" . #((list 213 1 1 1) ""))
    ("remquof" . #((list 213 1 1 1 108) ""))
    ("scalbnf" . #((list 213 1 1 4) ""))
    ("tgammaf" . #((list 213 1 1) ""))
    ("llvm.sin.f64" . #((list 213 0 0) ""))
    ("llvm.cos.f64" . #((list 213 0 0) ""))
    ("llvm.ceil.f64" . #((list 213 0 0) ""))
    ("llvm.floor.f64" . #((list 213 0 0) ""))
    ("llvm.exp.f64" . #((list 213 0 0) ""))
    ("llvm.fmod.f64" . #((list 213 0 0) ""))
    ("llvm.pow.f64" . #((list 213 0 0 0) ""))
    ("llvm.log.f64" . #((list 213 0 0) ""))
    ("llvm.log2.f64" . #((list 213 0 0) ""))
    ("llvm.log10.f64" . #((list 213 0 0) ""))
    ("llvm.sqrt.f64" . #((list 213 0 0) ""))
    ("llvm.fabs.f64" . #((list 213 0 0) ""))
    ("llvm.round.f64" . #((list 213 0 0) ""))
    ("llvm.trunc.f64" . #((list 213 0 0) ""))
    ("llvm.nearbyint.f64" . #((list 213 0 0) ""))
    ("llvm.fma.f64" . #((list 213 0 0 0 0) ""))
    ("llvm.exp2.f64" . #((list 213 0 0) ""))
    ("llvm.powi.f64" . #((list 213 0 0 4) ""))
    ("llvm.sin.f32" . #((list 213 1 1) ""))
    ("llvm.cos.f32" . #((list 213 1 1) ""))
    ("llvm.ceil.f32" . #((list 213 1 1) ""))
    ("llvm.floor.f32" . #((list 213 1 1) ""))
    ("llvm.exp.f32" . #((list 213 1 1) ""))
    ("llvm.fmod.f32" . #((list 213 1 1) ""))
    ("llvm.pow.f32" . #((list 213 1 1 1) ""))
    ("llvm.log.f32" . #((list 213 1 1) ""))
    ("llvm.log2.f32" . #((list 213 1 1) ""))
    ("llvm.log10.f32" . #((list 213 1 1) ""))
    ("llvm.sqrt.f32" . #((list 213 1 1) ""))
    ("llvm.fabs.f32" . #((list 213 1 1) ""))
    ("llvm.round.f32" . #((list 213 1 1) ""))
    ("llvm.trunc.f32" . #((list 213 1 1) ""))
    ("llvm.nearbyint.f32" . #((list 213 1 1) ""))
    ("llvm.fma.f32" . #((list 213 1 1 1 1) ""))
    ("llvm.exp2.f32" . #((list 213 1 1) ""))
    ("llvm.powi.f32" . #((list 213 1 1 4) ""))
    ("llvm.sin.v2f64" . #((list 213 (16 2 0) (16 2 0)) ""))
    ("llvm.cos.v2f64" . #((list 213 (16 2 0) (16 2 0)) ""))
    ("llvm.ceil.v2f64" . #((list 213 (16 2 0) (16 2 0)) ""))
    ("llvm.floor.v2f64" . #((list 213 (16 2 0) (16 2 0)) ""))
    ("llvm.exp.v2f64" . #((list 213 (16 2 0) (16 2 0)) ""))
    ("llvm.fmod.v2f64" . #((list 213 (16 2 0) (16 2 0)) ""))
    ("llvm.pow.v2f64" . #((list 213 (16 2 0) (16 2 0) (16 2 0)) ""))
    ("llvm.log.v2f64" . #((list 213 (16 2 0) (16 2 0)) ""))
    ("llvm.log2.v2f64" . #((list 213 (16 2 0) (16 2 0)) ""))
    ("llvm.log10.v2f64" . #((list 213 (16 2 0) (16 2 0)) ""))
    ("llvm.sqrt.v2f64" . #((list 213 (16 2 0) (16 2 0)) ""))
    ("llvm.fabs.v2f64" . #((list 213 (16 2 0) (16 2 0)) ""))
    ("llvm.round.v2f64" . #((list 213 (16 2 0) (16 2 0)) ""))
    ("llvm.trunc.v2f64" . #((list 213 (16 2 0) (16 2 0)) ""))
    ("llvm.nearbyint.v2f64" . #((list 213 (16 2 0) (16 2 0)) ""))
    ("llvm.fma.v2f64" . #((list 213 (16 2 0) (16 2 0) (16 2 0) (16 2 0)) ""))
    ("llvm.exp2.v2f64" . #((list 213 (16 2 0) (16 2 0)) ""))
    ("llvm.powi.v2f64" . #((list 213 (16 2 0) (16 2 0) (16 2 4)) ""))
    ("llvm.sin.v4f64" . #((list 213 (16 4 0) (16 4 0)) ""))
    ("llvm.cos.v4f64" . #((list 213 (16 4 0) (16 4 0)) ""))
    ("llvm.ceil.v4f64" . #((list 213 (16 4 0) (16 4 0)) ""))
    ("llvm.floor.v4f64" . #((list 213 (16 4 0) (16 4 0)) ""))
    ("llvm.exp.v4f64" . #((list 213 (16 4 0) (16 4 0)) ""))
    ("llvm.fmod.v4f64" . #((list 213 (16 4 0) (16 4 0)) ""))
    ("llvm.pow.v4f64" . #((list 213 (16 4 0) (16 4 0) (16 4 0)) ""))
    ("llvm.log.v4f64" . #((list 213 (16 4 0) (16 4 0)) ""))
    ("llvm.log2.v4f64" . #((list 213 (16 4 0) (16 4 0)) ""))
    ("llvm.log10.v4f64" . #((list 213 (16 4 0) (16 4 0)) ""))
    ("llvm.sqrt.v4f64" . #((list 213 (16 4 0) (16 4 0)) ""))
    ("llvm.fabs.v4f64" . #((list 213 (16 4 0) (16 4 0)) ""))
    ("llvm.round.v4f64" . #((list 213 (16 4 0) (16 4 0)) ""))
    ("llvm.trunc.v4f64" . #((list 213 (16 4 0) (16 4 0)) ""))
    ("llvm.nearbyint.v4f64" . #((list 213 (16 4 0) (16 4 0)) ""))
    ("llvm.fma.v4f64" . #((list 213 (16 4 0) (16 4 0) (16 4 0) (16 4 0)) ""))
    ("llvm.exp2.v4f64" . #((list 213 (16 4 0) (16 4 0)) ""))
    ("llvm.powi.v4f64" . #((list 213 (16 4 0) (16 4 0) (16 4 4)) ""))
    ("llvm.sin.v4f32" . #((list 213 (16 4 1) (16 4 1)) ""))
    ("llvm.cos.v4f32" . #((list 213 (16 4 1) (16 4 1)) ""))
    ("llvm.ceil.v4f32" . #((list 213 (16 4 1) (16 4 1)) ""))
    ("llvm.floor.v4f32" . #((list 213 (16 4 1) (16 4 1)) ""))
    ("llvm.exp.v4f32" . #((list 213 (16 4 1) (16 4 1)) ""))
    ("llvm.fmod.v4f32" . #((list 213 (16 4 1) (16 4 1)) ""))
    ("llvm.pow.v4f32" . #((list 213 (16 4 1) (16 4 1) (16 4 1)) ""))
    ("llvm.log.v4f32" . #((list 213 (16 4 1) (16 4 1)) ""))
    ("llvm.log2.v4f32" . #((list 213 (16 4 1) (16 4 1)) ""))
    ("llvm.log10.v4f32" . #((list 213 (16 4 1) (16 4 1)) ""))
    ("llvm.sqrt.v4f32" . #((list 213 (16 4 1) (16 4 1)) ""))
    ("llvm.fabs.v4f32" . #((list 213 (16 4 1) (16 4 1)) ""))
    ("llvm.round.v4f32" . #((list 213 (16 4 1) (16 4 1)) ""))
    ("llvm.trunc.v4f32" . #((list 213 (16 4 1) (16 4 1)) ""))
    ("llvm.nearbyint.v4f32" . #((list 213 (16 4 1) (16 4 1)) ""))
    ("llvm.fma.v4f32" . #((list 213 (16 4 1) (16 4 1) (16 4 1) (16 4 1)) ""))
    ("llvm.exp2.v4f32" . #((list 213 (16 4 1) (16 4 1)) ""))
    ("llvm.powi.v4f32" . #((list 213 (16 4 1) (16 4 1) (16 4 4)) ""))
    ("llvm.sin.v8f32" . #((list 213 (16 8 1) (16 8 1)) ""))
    ("llvm.cos.v8f32" . #((list 213 (16 8 1) (16 8 1)) ""))
    ("llvm.ceil.v8f32" . #((list 213 (16 8 1) (16 8 1)) ""))
    ("llvm.floor.v8f32" . #((list 213 (16 8 1) (16 8 1)) ""))
    ("llvm.exp.v8f32" . #((list 213 (16 8 1) (16 8 1)) ""))
    ("llvm.fmod.v8f32" . #((list 213 (16 8 1) (16 8 1)) ""))
    ("llvm.pow.v8f32" . #((list 213 (16 8 1) (16 8 1) (16 8 1)) ""))
    ("llvm.log.v8f32" . #((list 213 (16 8 1) (16 8 1)) ""))
    ("llvm.log2.v8f32" . #((list 213 (16 8 1) (16 8 1)) ""))
    ("llvm.log10.v8f32" . #((list 213 (16 8 1) (16 8 1)) ""))
    ("llvm.sqrt.v8f32" . #((list 213 (16 8 1) (16 8 1)) ""))
    ("llvm.fabs.v8f32" . #((list 213 (16 8 1) (16 8 1)) ""))
    ("llvm.round.v8f32" . #((list 213 (16 8 1) (16 8 1)) ""))
    ("llvm.trunc.v8f32" . #((list 213 (16 8 1) (16 8 1)) ""))
    ("llvm.nearbyint.v8f32" . #((list 213 (16 8 1) (16 8 1)) ""))
    ("llvm.fma.v8f32" . #((list 213 (16 8 1) (16 8 1) (16 8 1) (16 8 1)) ""))
    ("llvm.exp2.v8f32" . #((list 213 (16 8 1) (16 8 1)) ""))
    ("llvm.powi.v8f32" . #((list 213 (16 8 1) (16 8 1) (16 8 4)) ""))
    ("clearerr" . #((list 213 -1 108) ""))
    ("ctermid" . #((list 213 108 108) ""))
    ("fclose" . #((list 213 4 108) ""))
    ("fdopen" . #((list 213 108 4 108) ""))
    ("feof" . #((list 213 4 108) ""))
    ("ferror" . #((list 213 4 108) ""))
    ("fflush" . #((list 213 4 108) ""))
    ("fgetc" . #((list 213 4 108) ""))
    ("fgets" . #((list 213 108 108 4 108) ""))
    ("fileno" . #((list 213 4 108) ""))
    ("flockfile" . #((list 213 -1 108) ""))
    ("fopen" . #((list 213 108 108 108) ""))
    ("fputc" . #((list 213 4 4 108) ""))
    ("fputs" . #((list 213 4 108 108) ""))
    ("fread" . #((list 213 2 108 2 2 108) ""))
    ("freopen" . #((list 213 108 108 108 108) ""))
    ("fseek" . #((list 213 4 108 2 4) ""))
    ("ftell" . #((list 213 2 108) ""))
    ("ftrylockfile" . #((list 213 4 108) ""))
    ("funlockfile" . #((list 213 -1 108) ""))
    ("fwrite" . #((list 213 2 108 2 2 108) ""))
    ("getc" . #((list 213 4 108) ""))
    ("getchar" . #((list 213 4) ""))
    ("getc_unlocked" . #((list 213 4 108) ""))
    ("getchar_unlocked" . #((list 213 4) ""))
    ("gets" . #((list 213 108 108) ""))
    ("getw" . #((list 213 4 108) ""))
    ("pclose" . #((list 213 4 108) ""))
    ("perror" . #((list 213 -1 108) ""))
    ("popen" . #((list 213 108 108 108) ""))
    ("putc" . #((list 213 4 4 108) ""))
    ("putchar" . #((list 213 4 4) ""))
    ("putc_unlocked" . #((list 213 4 4 108) ""))
    ("putchar_unlocked" . #((list 213 4 4) ""))
    ("puts" . #((list 213 4 108) ""))
    ("putw" . #((list 213 4 4 108) ""))
    ("remove" . #((list 213 4 108) ""))
    ("rename" . #((list 213 4 108 108) ""))
    ("rewind" . #((list 213 -1 108) ""))
    ("setbuf" . #((list 213 -1 108 108) ""))
    ("setvbuf" . #((list 213 4 108 108 4 2) ""))
    ("tempnam" . #((list 213 108 108 108) ""))
    ("tmpfile" . #((list 213 108) ""))
    ("tmpnam" . #((list 213 108 108) ""))
    ("ungetc" . #((list 213 4 4 108) ""))
    ("atof" . #((list 213 0 108) ""))
    ("atoi" . #((list 213 4 108) ""))
    ("atol" . #((list 213 2 108) ""))
    ("memccpy" . #((list 213 108 108 108 4 2) ""))
    ("memchr" . #((list 213 108 108 4 2) ""))
    ("memcmp" . #((list 213 4 108 108 2) ""))
    ("memcpy" . #((list 213 108 108 108 2) ""))
    ("memmove" . #((list 213 108 108 108 2) ""))
    ("memset" . #((list 213 108 108 4 2) ""))
    ("strcat" . #((list 213 108 108 108) ""))
    ("strchr" . #((list 213 108 108 4) ""))
    ("strcmp" . #((list 213 4 108 108) ""))
    ("strcoll" . #((list 213 4 108 108) ""))
    ("strcpy" . #((list 213 108 108 108) ""))
    ("strcspn" . #((list 213 2 108 108) ""))
    ("strdup" . #((list 213 108 108) ""))
    ("strerror" . #((list 213 108 4) ""))
    ("strlen" . #((list 213 2 108) ""))
    ("strncat" . #((list 213 108 108 108 2) ""))
    ("strncmp" . #((list 213 4 108 108 2) ""))
    ("strncpy" . #((list 213 108 108 108 2) ""))
    ("strpbrk" . #((list 213 108 108 108) ""))
    ("strrchr" . #((list 213 108 108 4) ""))
    ("strspn" . #((list 213 2 108 108) ""))
    ("strstr" . #((list 213 108 108 108) ""))
    ("strtok" . #((list 213 108 108 108) ""))
    ("strtok_r" . #((list 213 108 108 108 208) ""))
    ("strxfrm" . #((list 213 2 108 108 2) ""))
    ("longjmp" . #((list 213 -1 108 4) ""))
    ("setjmp" . #((list 213 4 108) ""))
    ("glAccum" . #((list 213 -1 4 1) ""))
    ("glAlphaFunc" . #((list 213 -1 4 1) ""))
    ("glAreTexturesResident" . #((list 213 8 4 104 108) ""))
    ("glArrayElement" . #((list 213 -1 4) ""))
    ("glBegin" . #((list 213 -1 4) ""))
    ("glBindTexture" . #((list 213 -1 4 4) ""))
    ("glBitmap" . #((list 213 -1 4 4 1 1 1 1 108) ""))
    ("glBlendColor" . #((list 213 -1 1 1 1 1) ""))
    ("glBlendEquation" . #((list 213 -1 4) ""))
    ("glBlendEquationSeparate" . #((list 213 -1 4 4) ""))
    ("glBlendFunc" . #((list 213 -1 4 4) ""))
    ("glCallList" . #((list 213 -1 4) ""))
    ("glCallLists" . #((list 213 -1 4 4 108) ""))
    ("glClear" . #((list 213 -1 4) ""))
    ("glClearAccum" . #((list 213 -1 1 1 1 1) ""))
    ("glClearColor" . #((list 213 -1 1 1 1 1) ""))
    ("glClearDepth" . #((list 213 -1 0) ""))
    ("glClearIndex" . #((list 213 -1 1) ""))
    ("glClearStencil" . #((list 213 -1 4) ""))
    ("glClipPlane" . #((list 213 -1 4 100) ""))
    ("glColor3b" . #((list 213 -1 8 8 8) ""))
    ("glColor3bv" . #((list 213 -1 108) ""))
    ("glColor3d" . #((list 213 -1 0 0 0) ""))
    ("glColor3dv" . #((list 213 -1 100) ""))
    ("glColor3f" . #((list 213 -1 1 1 1) ""))
    ("glColor3fv" . #((list 213 -1 101) ""))
    ("glColor3i" . #((list 213 -1 4 4 4) ""))
    ("glColor3iv" . #((list 213 -1 104) ""))
    ("glColor3s" . #((list 213 -1 6 6 6) ""))
    ("glColor3sv" . #((list 213 -1 106) ""))
    ("glColor3ub" . #((list 213 -1 8 8 8) ""))
    ("glColor3ubv" . #((list 213 -1 108) ""))
    ("glColor3ui" . #((list 213 -1 4 4 4) ""))
    ("glColor3uiv" . #((list 213 -1 104) ""))
    ("glColor3us" . #((list 213 -1 6 6 6) ""))
    ("glColor3usv" . #((list 213 -1 106) ""))
    ("glColor4b" . #((list 213 -1 8 8 8 8) ""))
    ("glColor4bv" . #((list 213 -1 108) ""))
    ("glColor4d" . #((list 213 -1 0 0 0 0) ""))
    ("glColor4dv" . #((list 213 -1 100) ""))
    ("glColor4f" . #((list 213 -1 1 1 1 1) ""))
    ("glColor4fv" . #((list 213 -1 101) ""))
    ("glColor4i" . #((list 213 -1 4 4 4 4) ""))
    ("glColor4iv" . #((list 213 -1 104) ""))
    ("glColor4s" . #((list 213 -1 6 6 6 6) ""))
    ("glColor4sv" . #((list 213 -1 106) ""))
    ("glColor4ub" . #((list 213 -1 8 8 8 8) ""))
    ("glColor4ubv" . #((list 213 -1 108) ""))
    ("glColor4ui" . #((list 213 -1 4 4 4 4) ""))
    ("glColor4uiv" . #((list 213 -1 104) ""))
    ("glColor4us" . #((list 213 -1 6 6 6 6) ""))
    ("glColor4usv" . #((list 213 -1 106) ""))
    ("glColorMask" . #((list 213 -1 8 8 8 8) ""))
    ("glColorMaterial" . #((list 213 -1 4 4) ""))
    ("glColorPointer" . #((list 213 -1 4 4 4 108) ""))
    ("glColorSubTable" . #((list 213 -1 4 4 4 4 4 108) ""))
    ("glColorTable" . #((list 213 -1 4 4 4 4 4 108) ""))
    ("glColorTableParameterfv" . #((list 213 -1 4 4 101) ""))
    ("glColorTableParameteriv" . #((list 213 -1 4 4 104) ""))
    ("glConvolutionFilter1D" . #((list 213 -1 4 4 4 4 4 108) ""))
    ("glConvolutionFilter2D" . #((list 213 -1 4 4 4 4 4 4 108) ""))
    ("glConvolutionParameterf" . #((list 213 -1 4 4 1) ""))
    ("glConvolutionParameterfv" . #((list 213 -1 4 4 101) ""))
    ("glConvolutionParameteri" . #((list 213 -1 4 4 4) ""))
    ("glConvolutionParameteriv" . #((list 213 -1 4 4 104) ""))
    ("glCopyColorSubTable" . #((list 213 -1 4 4 4 4 4) ""))
    ("glCopyColorTable" . #((list 213 -1 4 4 4 4 4) ""))
    ("glCopyConvolutionFilter1D" . #((list 213 -1 4 4 4 4 4) ""))
    ("glCopyConvolutionFilter2D" . #((list 213 -1 4 4 4 4 4 4) ""))
    ("glCopyPixels" . #((list 213 -1 4 4 4 4 4) ""))
    ("glCopyTexImage1D" . #((list 213 -1 4 4 4 4 4 4 4) ""))
    ("glCopyTexImage2D" . #((list 213 -1 4 4 4 4 4 4 4 4) ""))
    ("glCopyTexSubImage1D" . #((list 213 -1 4 4 4 4 4 4) ""))
    ("glCopyTexSubImage2D" . #((list 213 -1 4 4 4 4 4 4 4 4) ""))
    ("glCopyTexSubImage3D" . #((list 213 -1 4 4 4 4 4 4 4 4 4) ""))
    ("glCullFace" . #((list 213 -1 4) ""))
    ("glDeleteLists" . #((list 213 -1 4 4) ""))
    ("glDeleteTextures" . #((list 213 -1 4 104) ""))
    ("glDepthFunc" . #((list 213 -1 4) ""))
    ("glDepthMask" . #((list 213 -1 8) ""))
    ("glDepthRange" . #((list 213 -1 0 0) ""))
    ("glDisable" . #((list 213 -1 4) ""))
    ("glDisableClientState" . #((list 213 -1 4) ""))
    ("glDrawArrays" . #((list 213 -1 4 4 4) ""))
    ("glDrawBuffer" . #((list 213 -1 4) ""))
    ("glDrawElements" . #((list 213 -1 4 4 4 108) ""))
    ("glDrawPixels" . #((list 213 -1 4 4 4 4 108) ""))
    ("glDrawRangeElements" . #((list 213 -1 4 4 4 4 4 108) ""))
    ("glEdgeFlag" . #((list 213 -1 8) ""))
    ("glEdgeFlagPointer" . #((list 213 -1 4 108) ""))
    ("glEdgeFlagv" . #((list 213 -1 108) ""))
    ("glEnable" . #((list 213 -1 4) ""))
    ("glEnableClientState" . #((list 213 -1 4) ""))
    ("glEnd" . #((list 213 -1) ""))
    ("glEndList" . #((list 213 -1) ""))
    ("glEvalCoord1d" . #((list 213 -1 0) ""))
    ("glEvalCoord1dv" . #((list 213 -1 100) ""))
    ("glEvalCoord1f" . #((list 213 -1 1) ""))
    ("glEvalCoord1fv" . #((list 213 -1 101) ""))
    ("glEvalCoord2d" . #((list 213 -1 0 0) ""))
    ("glEvalCoord2dv" . #((list 213 -1 100) ""))
    ("glEvalCoord2f" . #((list 213 -1 1 1) ""))
    ("glEvalCoord2fv" . #((list 213 -1 101) ""))
    ("glEvalMesh1" . #((list 213 -1 4 4 4) ""))
    ("glEvalMesh2" . #((list 213 -1 4 4 4 4 4) ""))
    ("glEvalPoint1" . #((list 213 -1 4) ""))
    ("glEvalPoint2" . #((list 213 -1 4 4) ""))
    ("glFeedbackBuffer" . #((list 213 -1 4 4 101) ""))
    ("glFinish" . #((list 213 -1) ""))
    ("glFlush" . #((list 213 -1) ""))
    ("glFogf" . #((list 213 -1 4 1) ""))
    ("glFogfv" . #((list 213 -1 4 101) ""))
    ("glFogi" . #((list 213 -1 4 4) ""))
    ("glFogiv" . #((list 213 -1 4 104) ""))
    ("glFrontFace" . #((list 213 -1 4) ""))
    ("glFrustum" . #((list 213 -1 0 0 0 0 0 0) ""))
    ("glGenLists" . #((list 213 4 4) ""))
    ("glGenTextures" . #((list 213 -1 4 104) ""))
    ("glGetBooleanv" . #((list 213 -1 4 108) ""))
    ("glGetClipPlane" . #((list 213 -1 4 100) ""))
    ("glGetColorTable" . #((list 213 -1 4 4 4 108) ""))
    ("glGetColorTableParameterfv" . #((list 213 -1 4 4 101) ""))
    ("glGetColorTableParameteriv" . #((list 213 -1 4 4 104) ""))
    ("glGetConvolutionFilter" . #((list 213 -1 4 4 4 108) ""))
    ("glGetConvolutionParameterfv" . #((list 213 -1 4 4 101) ""))
    ("glGetConvolutionParameteriv" . #((list 213 -1 4 4 104) ""))
    ("glGetDoublev" . #((list 213 -1 4 100) ""))
    ("glGetError" . #((list 213 4) ""))
    ("glGetFloatv" . #((list 213 -1 4 101) ""))
    ("glGetHistogram" . #((list 213 -1 4 8 4 4 108) ""))
    ("glGetHistogramParameterfv" . #((list 213 -1 4 4 101) ""))
    ("glGetHistogramParameteriv" . #((list 213 -1 4 4 104) ""))
    ("glGetIntegerv" . #((list 213 -1 4 104) ""))
    ("glGetLightfv" . #((list 213 -1 4 4 101) ""))
    ("glGetLightiv" . #((list 213 -1 4 4 104) ""))
    ("glGetMapdv" . #((list 213 -1 4 4 100) ""))
    ("glGetMapfv" . #((list 213 -1 4 4 101) ""))
    ("glGetMapiv" . #((list 213 -1 4 4 104) ""))
    ("glGetMaterialfv" . #((list 213 -1 4 4 101) ""))
    ("glGetMaterialiv" . #((list 213 -1 4 4 104) ""))
    ("glGetMinmax" . #((list 213 -1 4 8 4 4 108) ""))
    ("glGetMinmaxParameterfv" . #((list 213 -1 4 4 101) ""))
    ("glGetMinmaxParameteriv" . #((list 213 -1 4 4 104) ""))
    ("glGetPixelMapfv" . #((list 213 -1 4 101) ""))
    ("glGetPixelMapuiv" . #((list 213 -1 4 104) ""))
    ("glGetPixelMapusv" . #((list 213 -1 4 106) ""))
    ("glGetPointerv" . #((list 213 -1 4 208) ""))
    ("glGetPolygonStipple" . #((list 213 -1 108) ""))
    ("glGetSeparableFilter" . #((list 213 -1 4 4 4 108 108 108) ""))
    ("glGetString" . #((list 213 108 4) ""))
    ("glGetTexEnvfv" . #((list 213 -1 4 4 101) ""))
    ("glGetTexEnviv" . #((list 213 -1 4 4 104) ""))
    ("glGetTexGendv" . #((list 213 -1 4 4 100) ""))
    ("glGetTexGenfv" . #((list 213 -1 4 4 101) ""))
    ("glGetTexGeniv" . #((list 213 -1 4 4 104) ""))
    ("glGetTexImage" . #((list 213 -1 4 4 4 4 108) ""))
    ("glGetTexLevelParameterfv" . #((list 213 -1 4 4 4 101) ""))
    ("glGetTexLevelParameteriv" . #((list 213 -1 4 4 4 104) ""))
    ("glGetTexParameterfv" . #((list 213 -1 4 4 101) ""))
    ("glGetTexParameteriv" . #((list 213 -1 4 4 104) ""))
    ("glHint" . #((list 213 -1 4 4) ""))
    ("glHistogram" . #((list 213 -1 4 4 4 8) ""))
    ("glIndexMask" . #((list 213 -1 4) ""))
    ("glIndexPointer" . #((list 213 -1 4 4 108) ""))
    ("glIndexd" . #((list 213 -1 0) ""))
    ("glIndexdv" . #((list 213 -1 100) ""))
    ("glIndexf" . #((list 213 -1 1) ""))
    ("glIndexfv" . #((list 213 -1 101) ""))
    ("glIndexi" . #((list 213 -1 4) ""))
    ("glIndexiv" . #((list 213 -1 104) ""))
    ("glIndexs" . #((list 213 -1 6) ""))
    ("glIndexsv" . #((list 213 -1 106) ""))
    ("glIndexub" . #((list 213 -1 8) ""))
    ("glIndexubv" . #((list 213 -1 108) ""))
    ("glInitNames" . #((list 213 -1) ""))
    ("glInterleavedArrays" . #((list 213 -1 4 4 108) ""))
    ("glIsEnabled" . #((list 213 8 4) ""))
    ("glIsList" . #((list 213 8 4) ""))
    ("glIsTexture" . #((list 213 8 4) ""))
    ("glLightModelf" . #((list 213 -1 4 1) ""))
    ("glLightModelfv" . #((list 213 -1 4 101) ""))
    ("glLightModeli" . #((list 213 -1 4 4) ""))
    ("glLightModeliv" . #((list 213 -1 4 104) ""))
    ("glLightf" . #((list 213 -1 4 4 1) ""))
    ("glLightfv" . #((list 213 -1 4 4 101) ""))
    ("glLighti" . #((list 213 -1 4 4 4) ""))
    ("glLightiv" . #((list 213 -1 4 4 104) ""))
    ("glLineStipple" . #((list 213 -1 4 6) ""))
    ("glLineWidth" . #((list 213 -1 1) ""))
    ("glListBase" . #((list 213 -1 4) ""))
    ("glLoadIdentity" . #((list 213 -1) ""))
    ("glLoadMatrixd" . #((list 213 -1 100) ""))
    ("glLoadMatrixf" . #((list 213 -1 101) ""))
    ("glLoadName" . #((list 213 -1 4) ""))
    ("glLogicOp" . #((list 213 -1 4) ""))
    ("glMap1d" . #((list 213 -1 4 0 0 4 4 100) ""))
    ("glMap1f" . #((list 213 -1 4 1 1 4 4 101) ""))
    ("glMap2d" . #((list 213 -1 4 0 0 4 4 0 0 4 4 100) ""))
    ("glMap2f" . #((list 213 -1 4 1 1 4 4 1 1 4 4 101) ""))
    ("glMapGrid1d" . #((list 213 -1 4 0 0) ""))
    ("glMapGrid1f" . #((list 213 -1 4 1 1) ""))
    ("glMapGrid2d" . #((list 213 -1 4 0 0 4 0 0) ""))
    ("glMapGrid2f" . #((list 213 -1 4 1 1 4 1 1) ""))
    ("glMaterialf" . #((list 213 -1 4 4 1) ""))
    ("glMaterialfv" . #((list 213 -1 4 4 101) ""))
    ("glMateriali" . #((list 213 -1 4 4 4) ""))
    ("glMaterialiv" . #((list 213 -1 4 4 104) ""))
    ("glMatrixMode" . #((list 213 -1 4) ""))
    ("glMinmax" . #((list 213 -1 4 4 8) ""))
    ("glMultMatrixd" . #((list 213 -1 100) ""))
    ("glMultMatrixf" . #((list 213 -1 101) ""))
    ("glNewList" . #((list 213 -1 4 4) ""))
    ("glNormal3b" . #((list 213 -1 8 8 8) ""))
    ("glNormal3bv" . #((list 213 -1 108) ""))
    ("glNormal3d" . #((list 213 -1 0 0 0) ""))
    ("glNormal3dv" . #((list 213 -1 100) ""))
    ("glNormal3f" . #((list 213 -1 1 1 1) ""))
    ("glNormal3fv" . #((list 213 -1 101) ""))
    ("glNormal3i" . #((list 213 -1 4 4 4) ""))
    ("glNormal3iv" . #((list 213 -1 104) ""))
    ("glNormal3s" . #((list 213 -1 6 6 6) ""))
    ("glNormal3sv" . #((list 213 -1 106) ""))
    ("glNormalPointer" . #((list 213 -1 4 4 108) ""))
    ("glOrtho" . #((list 213 -1 0 0 0 0 0 0) ""))
    ("glPassThrough" . #((list 213 -1 1) ""))
    ("glPixelMapfv" . #((list 213 -1 4 4 101) ""))
    ("glPixelMapuiv" . #((list 213 -1 4 4 104) ""))
    ("glPixelMapusv" . #((list 213 -1 4 4 106) ""))
    ("glPixelStoref" . #((list 213 -1 4 1) ""))
    ("glPixelStorei" . #((list 213 -1 4 4) ""))
    ("glPixelTransferf" . #((list 213 -1 4 1) ""))
    ("glPixelTransferi" . #((list 213 -1 4 4) ""))
    ("glPixelZoom" . #((list 213 -1 1 1) ""))
    ("glPointSize" . #((list 213 -1 1) ""))
    ("glPolygonMode" . #((list 213 -1 4 4) ""))
    ("glPolygonOffset" . #((list 213 -1 1 1) ""))
    ("glPolygonStipple" . #((list 213 -1 108) ""))
    ("glPopAttrib" . #((list 213 -1) ""))
    ("glPopClientAttrib" . #((list 213 -1) ""))
    ("glPopMatrix" . #((list 213 -1) ""))
    ("glPopName" . #((list 213 -1) ""))
    ("glPrioritizeTextures" . #((list 213 -1 4 104 101) ""))
    ("glPushAttrib" . #((list 213 -1 4) ""))
    ("glPushClientAttrib" . #((list 213 -1 4) ""))
    ("glPushMatrix" . #((list 213 -1) ""))
    ("glPushName" . #((list 213 -1 4) ""))
    ("glRasterPos2d" . #((list 213 -1 0 0) ""))
    ("glRasterPos2dv" . #((list 213 -1 100) ""))
    ("glRasterPos2f" . #((list 213 -1 1 1) ""))
    ("glRasterPos2fv" . #((list 213 -1 101) ""))
    ("glRasterPos2i" . #((list 213 -1 4 4) ""))
    ("glRasterPos2iv" . #((list 213 -1 104) ""))
    ("glRasterPos2s" . #((list 213 -1 6 6) ""))
    ("glRasterPos2sv" . #((list 213 -1 106) ""))
    ("glRasterPos3d" . #((list 213 -1 0 0 0) ""))
    ("glRasterPos3dv" . #((list 213 -1 100) ""))
    ("glRasterPos3f" . #((list 213 -1 1 1 1) ""))
    ("glRasterPos3fv" . #((list 213 -1 101) ""))
    ("glRasterPos3i" . #((list 213 -1 4 4 4) ""))
    ("glRasterPos3iv" . #((list 213 -1 104) ""))
    ("glRasterPos3s" . #((list 213 -1 6 6 6) ""))
    ("glRasterPos3sv" . #((list 213 -1 106) ""))
    ("glRasterPos4d" . #((list 213 -1 0 0 0 0) ""))
    ("glRasterPos4dv" . #((list 213 -1 100) ""))
    ("glRasterPos4f" . #((list 213 -1 1 1 1 1) ""))
    ("glRasterPos4fv" . #((list 213 -1 101) ""))
    ("glRasterPos4i" . #((list 213 -1 4 4 4 4) ""))
    ("glRasterPos4iv" . #((list 213 -1 104) ""))
    ("glRasterPos4s" . #((list 213 -1 6 6 6 6) ""))
    ("glRasterPos4sv" . #((list 213 -1 106) ""))
    ("glReadBuffer" . #((list 213 -1 4) ""))
    ("glReadPixels" . #((list 213 -1 4 4 4 4 4 4 108) ""))
    ("glRectd" . #((list 213 -1 0 0 0 0) ""))
    ("glRectdv" . #((list 213 -1 100 100) ""))
    ("glRectf" . #((list 213 -1 1 1 1 1) ""))
    ("glRectfv" . #((list 213 -1 101 101) ""))
    ("glRecti" . #((list 213 -1 4 4 4 4) ""))
    ("glRectiv" . #((list 213 -1 104 104) ""))
    ("glRects" . #((list 213 -1 6 6 6 6) ""))
    ("glRectsv" . #((list 213 -1 106 106) ""))
    ("glRenderMode" . #((list 213 4 4) ""))
    ("glResetHistogram" . #((list 213 -1 4) ""))
    ("glResetMinmax" . #((list 213 -1 4) ""))
    ("glRotated" . #((list 213 -1 0 0 0 0) ""))
    ("glRotatef" . #((list 213 -1 1 1 1 1) ""))
    ("glScaled" . #((list 213 -1 0 0 0) ""))
    ("glScalef" . #((list 213 -1 1 1 1) ""))
    ("glScissor" . #((list 213 -1 4 4 4 4) ""))
    ("glSelectBuffer" . #((list 213 -1 4 104) ""))
    ("glSeparableFilter2D" . #((list 213 -1 4 4 4 4 4 4 108 108) ""))
    ("glShadeModel" . #((list 213 -1 4) ""))
    ("glStencilFunc" . #((list 213 -1 4 4 4) ""))
    ("glStencilMask" . #((list 213 -1 4) ""))
    ("glStencilOp" . #((list 213 -1 4 4 4) ""))
    ("glTexCoord1d" . #((list 213 -1 0) ""))
    ("glTexCoord1dv" . #((list 213 -1 100) ""))
    ("glTexCoord1f" . #((list 213 -1 1) ""))
    ("glTexCoord1fv" . #((list 213 -1 101) ""))
    ("glTexCoord1i" . #((list 213 -1 4) ""))
    ("glTexCoord1iv" . #((list 213 -1 104) ""))
    ("glTexCoord1s" . #((list 213 -1 6) ""))
    ("glTexCoord1sv" . #((list 213 -1 106) ""))
    ("glTexCoord2d" . #((list 213 -1 0 0) ""))
    ("glTexCoord2dv" . #((list 213 -1 100) ""))
    ("glTexCoord2f" . #((list 213 -1 1 1) ""))
    ("glTexCoord2fv" . #((list 213 -1 101) ""))
    ("glTexCoord2i" . #((list 213 -1 4 4) ""))
    ("glTexCoord2iv" . #((list 213 -1 104) ""))
    ("glTexCoord2s" . #((list 213 -1 6 6) ""))
    ("glTexCoord2sv" . #((list 213 -1 106) ""))
    ("glTexCoord3d" . #((list 213 -1 0 0 0) ""))
    ("glTexCoord3dv" . #((list 213 -1 100) ""))
    ("glTexCoord3f" . #((list 213 -1 1 1 1) ""))
    ("glTexCoord3fv" . #((list 213 -1 101) ""))
    ("glTexCoord3i" . #((list 213 -1 4 4 4) ""))
    ("glTexCoord3iv" . #((list 213 -1 104) ""))
    ("glTexCoord3s" . #((list 213 -1 6 6 6) ""))
    ("glTexCoord3sv" . #((list 213 -1 106) ""))
    ("glTexCoord4d" . #((list 213 -1 0 0 0 0) ""))
    ("glTexCoord4dv" . #((list 213 -1 100) ""))
    ("glTexCoord4f" . #((list 213 -1 1 1 1 1) ""))
    ("glTexCoord4fv" . #((list 213 -1 101) ""))
    ("glTexCoord4i" . #((list 213 -1 4 4 4 4) ""))
    ("glTexCoord4iv" . #((list 213 -1 104) ""))
    ("glTexCoord4s" . #((list 213 -1 6 6 6 6) ""))
    ("glTexCoord4sv" . #((list 213 -1 106) ""))
    ("glTexCoordPointer" . #((list 213 -1 4 4 4 108) ""))
    ("glTexEnvf" . #((list 213 -1 4 4 1) ""))
    ("glTexEnvfv" . #((list 213 -1 4 4 101) ""))
    ("glTexEnvi" . #((list 213 -1 4 4 4) ""))
    ("glTexEnviv" . #((list 213 -1 4 4 104) ""))
    ("glTexGend" . #((list 213 -1 4 4 0) ""))
    ("glTexGendv" . #((list 213 -1 4 4 100) ""))
    ("glTexGenf" . #((list 213 -1 4 4 1) ""))
    ("glTexGenfv" . #((list 213 -1 4 4 101) ""))
    ("glTexGeni" . #((list 213 -1 4 4 4) ""))
    ("glTexGeniv" . #((list 213 -1 4 4 104) ""))
    ("glTexImage1D" . #((list 213 -1 4 4 4 4 4 4 4 108) ""))
    ("glTexImage2D" . #((list 213 -1 4 4 4 4 4 4 4 4 108) ""))
    ("glTexImage3D" . #((list 213 -1 4 4 4 4 4 4 4 4 4 108) ""))
    ("glTexParameterf" . #((list 213 -1 4 4 1) ""))
    ("glTexParameterfv" . #((list 213 -1 4 4 101) ""))
    ("glTexParameteri" . #((list 213 -1 4 4 4) ""))
    ("glTexParameteriv" . #((list 213 -1 4 4 104) ""))
    ("glTexSubImage1D" . #((list 213 -1 4 4 4 4 4 4 108) ""))
    ("glTexSubImage2D" . #((list 213 -1 4 4 4 4 4 4 4 4 108) ""))
    ("glTexSubImage3D" . #((list 213 -1 4 4 4 4 4 4 4 4 4 4 108) ""))
    ("glTranslated" . #((list 213 -1 0 0 0) ""))
    ("glTranslatef" . #((list 213 -1 1 1 1) ""))
    ("glVertex2d" . #((list 213 -1 0 0) ""))
    ("glVertex2dv" . #((list 213 -1 100) ""))
    ("glVertex2f" . #((list 213 -1 1 1) ""))
    ("glVertex2fv" . #((list 213 -1 101) ""))
    ("glVertex2i" . #((list 213 -1 4 4) ""))
    ("glVertex2iv" . #((list 213 -1 104) ""))
    ("glVertex2s" . #((list 213 -1 6 6) ""))
    ("glVertex2sv" . #((list 213 -1 106) ""))
    ("glVertex3d" . #((list 213 -1 0 0 0) ""))
    ("glVertex3dv" . #((list 213 -1 100) ""))
    ("glVertex3f" . #((list 213 -1 1 1 1) ""))
    ("glVertex3fv" . #((list 213 -1 101) ""))
    ("glVertex3i" . #((list 213 -1 4 4 4) ""))
    ("glVertex3iv" . #((list 213 -1 104) ""))
    ("glVertex3s" . #((list 213 -1 6 6 6) ""))
    ("glVertex3sv" . #((list 213 -1 106) ""))
    ("glVertex4d" . #((list 213 -1 0 0 0 0) ""))
    ("glVertex4dv" . #((list 213 -1 100) ""))
    ("glVertex4f" . #((list 213 -1 1 1 1 1) ""))
    ("glVertex4fv" . #((list 213 -1 101) ""))
    ("glVertex4i" . #((list 213 -1 4 4 4 4) ""))
    ("glVertex4iv" . #((list 213 -1 104) ""))
    ("glVertex4s" . #((list 213 -1 6 6 6 6) ""))
    ("glVertex4sv" . #((list 213 -1 106) ""))
    ("glVertexPointer" . #((list 213 -1 4 4 4 108) ""))
    ("glViewport" . #((list 213 -1 4 4 4 4) ""))
    ("glSampleCoverage" . #((list 213 -1 1 8) ""))
    ("glSamplePass" . #((list 213 -1 4) ""))
    ("glLoadTransposeMatrixf" . #((list 213 -1 101) ""))
    ("glLoadTransposeMatrixd" . #((list 213 -1 100) ""))
    ("glMultTransposeMatrixf" . #((list 213 -1 101) ""))
    ("glMultTransposeMatrixd" . #((list 213 -1 100) ""))
    ("glCompressedTexImage3D" . #((list 213 -1 4 4 4 4 4 4 4 4 108) ""))
    ("glCompressedTexImage2D" . #((list 213 -1 4 4 4 4 4 4 4 108) ""))
    ("glCompressedTexImage1D" . #((list 213 -1 4 4 4 4 4 4 108) ""))
    ("glCompressedTexSubImage3D" . #((list 213 -1 4 4 4 4 4 4 4 4 4 4 108) ""))
    ("glCompressedTexSubImage2D" . #((list 213 -1 4 4 4 4 4 4 4 4 108) ""))
    ("glCompressedTexSubImage1D" . #((list 213 -1 4 4 4 4 4 4 108) ""))
    ("glGetCompressedTexImage" . #((list 213 -1 4 4 108) ""))
    ("glClientActiveTexture" . #((list 213 -1 4) ""))
    ("glMultiTexCoord1d" . #((list 213 -1 4 0) ""))
    ("glMultiTexCoord1dv" . #((list 213 -1 4 100) ""))
    ("glMultiTexCoord1f" . #((list 213 -1 4 1) ""))
    ("glMultiTexCoord1fv" . #((list 213 -1 4 101) ""))
    ("glMultiTexCoord1i" . #((list 213 -1 4 4) ""))
    ("glMultiTexCoord1iv" . #((list 213 -1 4 104) ""))
    ("glMultiTexCoord1s" . #((list 213 -1 4 6) ""))
    ("glMultiTexCoord1sv" . #((list 213 -1 4 106) ""))
    ("glMultiTexCoord2d" . #((list 213 -1 4 0 0) ""))
    ("glMultiTexCoord2dv" . #((list 213 -1 4 100) ""))
    ("glMultiTexCoord2f" . #((list 213 -1 4 1 1) ""))
    ("glMultiTexCoord2fv" . #((list 213 -1 4 101) ""))
    ("glMultiTexCoord2i" . #((list 213 -1 4 4 4) ""))
    ("glMultiTexCoord2iv" . #((list 213 -1 4 104) ""))
    ("glMultiTexCoord2s" . #((list 213 -1 4 6 6) ""))
    ("glMultiTexCoord2sv" . #((list 213 -1 4 106) ""))
    ("glMultiTexCoord3d" . #((list 213 -1 4 0 0 0) ""))
    ("glMultiTexCoord3dv" . #((list 213 -1 4 100) ""))
    ("glMultiTexCoord3f" . #((list 213 -1 4 1 1 1) ""))
    ("glMultiTexCoord3fv" . #((list 213 -1 4 101) ""))
    ("glMultiTexCoord3i" . #((list 213 -1 4 4 4 4) ""))
    ("glMultiTexCoord3iv" . #((list 213 -1 4 104) ""))
    ("glMultiTexCoord3s" . #((list 213 -1 4 6 6 6) ""))
    ("glMultiTexCoord3sv" . #((list 213 -1 4 106) ""))
    ("glMultiTexCoord4d" . #((list 213 -1 4 0 0 0 0) ""))
    ("glMultiTexCoord4dv" . #((list 213 -1 4 100) ""))
    ("glMultiTexCoord4f" . #((list 213 -1 4 1 1 1 1) ""))
    ("glMultiTexCoord4fv" . #((list 213 -1 4 101) ""))
    ("glMultiTexCoord4i" . #((list 213 -1 4 4 4 4 4) ""))
    ("glMultiTexCoord4iv" . #((list 213 -1 4 104) ""))
    ("glMultiTexCoord4s" . #((list 213 -1 4 6 6 6 6) ""))
    ("glMultiTexCoord4sv" . #((list 213 -1 4 106) ""))
    ("glFogCoordf" . #((list 213 -1 1) ""))
    ("glFogCoordfv" . #((list 213 -1 101) ""))
    ("glFogCoordd" . #((list 213 -1 0) ""))
    ("glFogCoorddv" . #((list 213 -1 100) ""))
    ("glFogCoordPointer" . #((list 213 -1 4 4 108) ""))
    ("glSecondaryColor3b" . #((list 213 -1 8 8 8) ""))
    ("glSecondaryColor3bv" . #((list 213 -1 108) ""))
    ("glSecondaryColor3d" . #((list 213 -1 0 0 0) ""))
    ("glSecondaryColor3dv" . #((list 213 -1 100) ""))
    ("glSecondaryColor3f" . #((list 213 -1 1 1 1) ""))
    ("glSecondaryColor3fv" . #((list 213 -1 101) ""))
    ("glSecondaryColor3i" . #((list 213 -1 4 4 4) ""))
    ("glSecondaryColor3iv" . #((list 213 -1 104) ""))
    ("glSecondaryColor3s" . #((list 213 -1 6 6 6) ""))
    ("glSecondaryColor3sv" . #((list 213 -1 106) ""))
    ("glSecondaryColor3ub" . #((list 213 -1 8 8 8) ""))
    ("glSecondaryColor3ubv" . #((list 213 -1 108) ""))
    ("glSecondaryColor3ui" . #((list 213 -1 4 4 4) ""))
    ("glSecondaryColor3uiv" . #((list 213 -1 104) ""))
    ("glSecondaryColor3us" . #((list 213 -1 6 6 6) ""))
    ("glSecondaryColor3usv" . #((list 213 -1 106) ""))
    ("glSecondaryColorPointer" . #((list 213 -1 4 4 4 108) ""))
    ("glPointParameterf" . #((list 213 -1 4 1) ""))
    ("glPointParameterfv" . #((list 213 -1 4 101) ""))
    ("glPointParameteri" . #((list 213 -1 4 4) ""))
    ("glPointParameteriv" . #((list 213 -1 4 104) ""))
    ("glBlendFuncSeparate" . #((list 213 -1 4 4 4 4) ""))
    ("glMultiDrawArrays" . #((list 213 -1 4 104 104 4) ""))
    ("glMultiDrawElements" . #((list 213 -1 4 104 4 208 4) ""))
    ("glWindowPos2d" . #((list 213 -1 0 0) ""))
    ("glWindowPos2dv" . #((list 213 -1 100) ""))
    ("glWindowPos2f" . #((list 213 -1 1 1) ""))
    ("glWindowPos2fv" . #((list 213 -1 101) ""))
    ("glWindowPos2i" . #((list 213 -1 4 4) ""))
    ("glWindowPos2iv" . #((list 213 -1 104) ""))
    ("glWindowPos2s" . #((list 213 -1 6 6) ""))
    ("glWindowPos2sv" . #((list 213 -1 106) ""))
    ("glWindowPos3d" . #((list 213 -1 0 0 0) ""))
    ("glWindowPos3dv" . #((list 213 -1 100) ""))
    ("glWindowPos3f" . #((list 213 -1 1 1 1) ""))
    ("glWindowPos3fv" . #((list 213 -1 101) ""))
    ("glWindowPos3i" . #((list 213 -1 4 4 4) ""))
    ("glWindowPos3iv" . #((list 213 -1 104) ""))
    ("glWindowPos3s" . #((list 213 -1 6 6 6) ""))
    ("glWindowPos3sv" . #((list 213 -1 106) ""))
    ("glGenQueries" . #((list 213 -1 4 104) ""))
    ("glDeleteQueries" . #((list 213 -1 4 104) ""))
    ("glIsQuery" . #((list 213 8 4) ""))
    ("glBeginQuery" . #((list 213 -1 4 4) ""))
    ("glEndQuery" . #((list 213 -1 4) ""))
    ("glGetQueryiv" . #((list 213 -1 4 4 104) ""))
    ("glGetQueryObjectiv" . #((list 213 -1 4 4 104) ""))
    ("glGetQueryObjectuiv" . #((list 213 -1 4 4 104) ""))
    ("glDeleteBuffers" . #((list 213 -1 4 104) ""))
    ("glIsBuffer" . #((list 213 8 4) ""))
    ("glGetBufferSubData" . #((list 213 -1 4 4 4 108) ""))
    ("glMapBuffer" . #((list 213 108 4 4) ""))
    ("glUnmapBuffer" . #((list 213 8 4) ""))
    ("glGetBufferParameteriv" . #((list 213 -1 4 4 104) ""))
    ("glGetBufferPointerv" . #((list 213 -1 4 4 208) ""))
    ("glDrawBuffers" . #((list 213 -1 4 104) ""))
    ("glBindVertexArray" . #((list 213 -1 4) ""))
    ("glDeleteVertexArrays" . #((list 213 -1 4 104) ""))
    ("glGenVertexArrays" . #((list 213 -1 4 104) ""))
    ("glVertexAttrib1d" . #((list 213 -1 4 0) ""))
    ("glVertexAttrib1dv" . #((list 213 -1 4 100) ""))
    ("glVertexAttrib1f" . #((list 213 -1 4 1) ""))
    ("glVertexAttrib1fv" . #((list 213 -1 4 101) ""))
    ("glVertexAttrib1s" . #((list 213 -1 4 6) ""))
    ("glVertexAttrib1sv" . #((list 213 -1 4 106) ""))
    ("glVertexAttrib2d" . #((list 213 -1 4 0 0) ""))
    ("glVertexAttrib2dv" . #((list 213 -1 4 100) ""))
    ("glVertexAttrib2f" . #((list 213 -1 4 1 1) ""))
    ("glVertexAttrib2fv" . #((list 213 -1 4 101) ""))
    ("glVertexAttrib2s" . #((list 213 -1 4 6 6) ""))
    ("glVertexAttrib2sv" . #((list 213 -1 4 106) ""))
    ("glVertexAttrib3d" . #((list 213 -1 4 0 0 0) ""))
    ("glVertexAttrib3dv" . #((list 213 -1 4 100) ""))
    ("glVertexAttrib3f" . #((list 213 -1 4 1 1 1) ""))
    ("glVertexAttrib3fv" . #((list 213 -1 4 101) ""))
    ("glVertexAttrib3s" . #((list 213 -1 4 6 6 6) ""))
    ("glVertexAttrib3sv" . #((list 213 -1 4 106) ""))
    ("glVertexAttrib4Nbv" . #((list 213 -1 4 108) ""))
    ("glVertexAttrib4Niv" . #((list 213 -1 4 104) ""))
    ("glVertexAttrib4Nsv" . #((list 213 -1 4 106) ""))
    ("glVertexAttrib4Nub" . #((list 213 -1 4 8 8 8 8) ""))
    ("glVertexAttrib4Nubv" . #((list 213 -1 4 108) ""))
    ("glVertexAttrib4Nuiv" . #((list 213 -1 4 104) ""))
    ("glVertexAttrib4Nusv" . #((list 213 -1 4 106) ""))
    ("glVertexAttrib4bv" . #((list 213 -1 4 108) ""))
    ("glVertexAttrib4d" . #((list 213 -1 4 0 0 0 0) ""))
    ("glVertexAttrib4dv" . #((list 213 -1 4 100) ""))
    ("glVertexAttrib4f" . #((list 213 -1 4 1 1 1 1) ""))
    ("glVertexAttrib4fv" . #((list 213 -1 4 101) ""))
    ("glVertexAttrib4iv" . #((list 213 -1 4 104) ""))
    ("glVertexAttrib4s" . #((list 213 -1 4 6 6 6 6) ""))
    ("glVertexAttrib4sv" . #((list 213 -1 4 106) ""))
    ("glVertexAttrib4ubv" . #((list 213 -1 4 108) ""))
    ("glVertexAttrib4uiv" . #((list 213 -1 4 104) ""))
    ("glVertexAttrib4usv" . #((list 213 -1 4 106) ""))
    ("glGetVertexAttribdv" . #((list 213 -1 4 4 100) ""))
    ("glGetVertexAttribfv" . #((list 213 -1 4 4 101) ""))
    ("glGetVertexAttribiv" . #((list 213 -1 4 4 104) ""))
    ("glGetVertexAttribPointerv" . #((list 213 -1 4 4 208) ""))
    ("glDeleteShader" . #((list 213 -1 4) ""))
    ("glDetachShader" . #((list 213 -1 4 4) ""))
    ("glDeleteProgram" . #((list 213 -1 4) ""))
    ("glValidateProgram" . #((list 213 -1 4) ""))
    ("glUniform2i" . #((list 213 -1 4 4 4) ""))
    ("glUniform3i" . #((list 213 -1 4 4 4 4) ""))
    ("glUniform4i" . #((list 213 -1 4 4 4 4 4) ""))
    ("glUniform1iv" . #((list 213 -1 4 4 104) ""))
    ("glUniform2iv" . #((list 213 -1 4 4 104) ""))
    ("glUniform3iv" . #((list 213 -1 4 4 104) ""))
    ("glUniform4iv" . #((list 213 -1 4 4 104) ""))
    ("glUniformMatrix2fv" . #((list 213 -1 4 4 8 101) ""))
    ("glIsShader" . #((list 213 8 4) ""))
    ("glIsProgram" . #((list 213 8 4) ""))
    ("glGetAttachedShaders" . #((list 213 -1 4 4 104 104) ""))
    ("glGetActiveUniform" . #((list 213 -1 4 4 4 104 104 104 108) ""))
    ("glGetUniformfv" . #((list 213 -1 4 4 101) ""))
    ("glGetUniformiv" . #((list 213 -1 4 4 104) ""))
    ("glGetShaderSource" . #((list 213 -1 4 4 104 108) ""))
    ("glGetActiveAttrib" . #((list 213 -1 4 4 4 104 104 104 108) ""))
    ("glStencilFuncSeparate" . #((list 213 -1 4 4 4 4) ""))
    ("glStencilOpSeparate" . #((list 213 -1 4 4 4 4) ""))
    ("glStencilMaskSeparate" . #((list 213 -1 4 4) ""))
    ("glUniformMatrix2x3fv" . #((list 213 -1 4 4 8 101) ""))
    ("glUniformMatrix3x2fv" . #((list 213 -1 4 4 8 101) ""))
    ("glUniformMatrix2x4fv" . #((list 213 -1 4 4 8 101) ""))
    ("glUniformMatrix4x2fv" . #((list 213 -1 4 4 8 101) ""))
    ("glUniformMatrix3x4fv" . #((list 213 -1 4 4 8 101) ""))
    ("glUniformMatrix4x3fv" . #((list 213 -1 4 4 8 101) ""))
    ("glutInit" . #((list 213 -1 104 208) ""))
    ("glutInitDisplayMode" . #((list 213 -1 4) ""))
    ("glutInitDisplayString" . #((list 213 -1 108) ""))
    ("glutInitWindowPosition" . #((list 213 -1 4 4) ""))
    ("glutInitWindowSize" . #((list 213 -1 4 4) ""))
    ("glutMainLoop" . #((list 213 -1) ""))
    ("glutCreateWindow" . #((list 213 4 108) ""))
    ("glutCreateSubWindow" . #((list 213 4 4 4 4 4 4) ""))
    ("glutDestroyWindow" . #((list 213 -1 4) ""))
    ("glutPostRedisplay" . #((list 213 -1) ""))
    ("glutPostWindowRedisplay" . #((list 213 -1 4) ""))
    ("glutSwapBuffers" . #((list 213 -1) ""))
    ("glutGetWindow" . #((list 213 4) ""))
    ("glutSetWindow" . #((list 213 -1 4) ""))
    ("glutSetWindowTitle" . #((list 213 -1 108) ""))
    ("glutSetIconTitle" . #((list 213 -1 108) ""))
    ("glutPositionWindow" . #((list 213 -1 4 4) ""))
    ("glutReshapeWindow" . #((list 213 -1 4 4) ""))
    ("glutPopWindow" . #((list 213 -1) ""))
    ("glutPushWindow" . #((list 213 -1) ""))
    ("glutIconifyWindow" . #((list 213 -1) ""))
    ("glutShowWindow" . #((list 213 -1) ""))
    ("glutHideWindow" . #((list 213 -1) ""))
    ("glutFullScreen" . #((list 213 -1) ""))
    ("glutSetCursor" . #((list 213 -1 4) ""))
    ("glutWarpPointer" . #((list 213 -1 4 4) ""))
    ("glutSurfaceTexture" . #((list 213 -1 4 4 4) ""))
    ("glutWMCloseFunc" . #((list 213 -1 (213 -1)) ""))
    ("glutCheckLoop" . #((list 213 -1) ""))
    ("glutEstablishOverlay" . #((list 213 -1) ""))
    ("glutRemoveOverlay" . #((list 213 -1) ""))
    ("glutUseLayer" . #((list 213 -1 4) ""))
    ("glutPostOverlayRedisplay" . #((list 213 -1) ""))
    ("glutPostWindowOverlayRedisplay" . #((list 213 -1 4) ""))
    ("glutShowOverlay" . #((list 213 -1) ""))
    ("glutHideOverlay" . #((list 213 -1) ""))
    ("glutCreateMenu" . #((list 213 4 (213 -1 4)) ""))
    ("glutDestroyMenu" . #((list 213 -1 4) ""))
    ("glutGetMenu" . #((list 213 4) ""))
    ("glutSetMenu" . #((list 213 -1 4) ""))
    ("glutAddMenuEntry" . #((list 213 -1 108 4) ""))
    ("glutAddSubMenu" . #((list 213 -1 108 4) ""))
    ("glutChangeToMenuEntry" . #((list 213 -1 4 108 4) ""))
    ("glutChangeToSubMenu" . #((list 213 -1 4 108 4) ""))
    ("glutRemoveMenuItem" . #((list 213 -1 4) ""))
    ("glutAttachMenu" . #((list 213 -1 4) ""))
    ("glutDetachMenu" . #((list 213 -1 4) ""))
    ("glutDisplayFunc" . #((list 213 -1 108) ""))
    ("glutReshapeFunc" . #((list 213 -1 108) ""))
    ("glutKeyboardFunc" . #((list 213 -1 108) ""))
    ("glutMouseFunc" . #((list 213 -1 108) ""))
    ("glutMotionFunc" . #((list 213 -1 108) ""))
    ("glutPassiveMotionFunc" . #((list 213 -1 108) ""))
    ("glutEntryFunc" . #((list 213 -1 108) ""))
    ("glutVisibilityFunc" . #((list 213 -1 108) ""))
    ("glutIdleFunc" . #((list 213 -1 108) ""))
    ("glutTimerFunc" . #((list 213 -1 4 108 4) ""))
    ("glutMenuStateFunc" . #((list 213 -1 108) ""))
    ("glutSpecialFunc" . #((list 213 -1 108) ""))
    ("glutSpaceballMotionFunc" . #((list 213 -1 108) ""))
    ("glutSpaceballRotateFunc" . #((list 213 -1 108) ""))
    ("glutSpaceballButtonFunc" . #((list 213 -1 108) ""))
    ("glutButtonBoxFunc" . #((list 213 -1 108) ""))
    ("glutDialsFunc" . #((list 213 -1 108) ""))
    ("glutTabletMotionFunc" . #((list 213 -1 108) ""))
    ("glutTabletButtonFunc" . #((list 213 -1 108) ""))
    ("glutMenuStatusFunc" . #((list 213 -1 108) ""))
    ("glutOverlayDisplayFunc" . #((list 213 -1 108) ""))
    ("glutWindowStatusFunc" . #((list 213 -1 108) ""))
    ("glutKeyboardUpFunc" . #((list 213 -1 108) ""))
    ("glutSpecialUpFunc" . #((list 213 -1 108) ""))
    ("glutJoystickFunc" . #((list 213 -1 108 4) ""))
    ("glutSetColor" . #((list 213 -1 4 1 1 1) ""))
    ("glutGetColor" . #((list 213 1 4 4) ""))
    ("glutCopyColormap" . #((list 213 -1 4) ""))
    ("glutGet" . #((list 213 4 4) ""))
    ("glutDeviceGet" . #((list 213 4 4) ""))
    ("glutExtensionSupported" . #((list 213 4 108) ""))
    ("glutGetModifiers" . #((list 213 4) ""))
    ("glutLayerGet" . #((list 213 4 4) ""))
    ("glutGetProcAddress" . #((list 213 108 108) ""))
    ("glutBitmapCharacter" . #((list 213 -1 108 4) ""))
    ("glutBitmapWidth" . #((list 213 4 108 4) ""))
    ("glutStrokeCharacter" . #((list 213 -1 108 4) ""))
    ("glutStrokeWidth" . #((list 213 4 108 4) ""))
    ("glutBitmapLength" . #((list 213 4 108 108) ""))
    ("glutStrokeLength" . #((list 213 4 108 108) ""))
    ("glutWireSphere" . #((list 213 -1 0 4 4) ""))
    ("glutSolidSphere" . #((list 213 -1 0 4 4) ""))
    ("glutWireCone" . #((list 213 -1 0 0 4 4) ""))
    ("glutSolidCone" . #((list 213 -1 0 0 4 4) ""))
    ("glutWireCube" . #((list 213 -1 0) ""))
    ("glutSolidCube" . #((list 213 -1 0) ""))
    ("glutWireTorus" . #((list 213 -1 0 0 4 4) ""))
    ("glutSolidTorus" . #((list 213 -1 0 0 4 4) ""))
    ("glutWireDodecahedron" . #((list 213 -1) ""))
    ("glutSolidDodecahedron" . #((list 213 -1) ""))
    ("glutWireTeapot" . #((list 213 -1 0) ""))
    ("glutSolidTeapot" . #((list 213 -1 0) ""))
    ("glutWireOctahedron" . #((list 213 -1) ""))
    ("glutSolidOctahedron" . #((list 213 -1) ""))
    ("glutWireTetrahedron" . #((list 213 -1) ""))
    ("glutSolidTetrahedron" . #((list 213 -1) ""))
    ("glutWireIcosahedron" . #((list 213 -1) ""))
    ("glutSolidIcosahedron" . #((list 213 -1) ""))
    ("glutVideoResizeGet" . #((list 213 4 4) ""))
    ("glutSetupVideoResizing" . #((list 213 -1) ""))
    ("glutStopVideoResizing" . #((list 213 -1) ""))
    ("glutVideoResize" . #((list 213 -1 4 4 4 4) ""))
    ("glutVideoPan" . #((list 213 -1 4 4 4 4) ""))
    ("glutReportErrors" . #((list 213 -1) ""))
    ("glutIgnoreKeyRepeat" . #((list 213 -1 4) ""))
    ("glutSetKeyRepeat" . #((list 213 -1 4) ""))
    ("glutForceJoystickFunc" . #((list 213 -1) ""))
    ("glutGameModeString" . #((list 213 -1 108) ""))
    ("glutEnterGameMode" . #((list 213 4) ""))
    ("glutLeaveGameMode" . #((list 213 -1) ""))
    ("glutGameModeGet" . #((list 213 4 4) ""))
    ("glActiveTextureARB" . #((list 213 -1 4) ""))
    ("glClientActiveTextureARB" . #((list 213 -1 4) ""))
    ("glMultiTexCoord1dARB" . #((list 213 -1 4 0) ""))
    ("glMultiTexCoord1dvARB" . #((list 213 -1 4 100) ""))
    ("glMultiTexCoord1fARB" . #((list 213 -1 4 1) ""))
    ("glMultiTexCoord1fvARB" . #((list 213 -1 4 101) ""))
    ("glMultiTexCoord1iARB" . #((list 213 -1 4 4) ""))
    ("glMultiTexCoord1ivARB" . #((list 213 -1 4 104) ""))
    ("glMultiTexCoord1sARB" . #((list 213 -1 4 6) ""))
    ("glMultiTexCoord1svARB" . #((list 213 -1 4 106) ""))
    ("glMultiTexCoord2dARB" . #((list 213 -1 4 0 0) ""))
    ("glMultiTexCoord2dvARB" . #((list 213 -1 4 100) ""))
    ("glMultiTexCoord2fARB" . #((list 213 -1 4 1 1) ""))
    ("glMultiTexCoord2fvARB" . #((list 213 -1 4 101) ""))
    ("glMultiTexCoord2iARB" . #((list 213 -1 4 4 4) ""))
    ("glMultiTexCoord2ivARB" . #((list 213 -1 4 104) ""))
    ("glMultiTexCoord2sARB" . #((list 213 -1 4 6 6) ""))
    ("glMultiTexCoord2svARB" . #((list 213 -1 4 106) ""))
    ("glMultiTexCoord3dARB" . #((list 213 -1 4 0 0 0) ""))
    ("glMultiTexCoord3dvARB" . #((list 213 -1 4 100) ""))
    ("glMultiTexCoord3fARB" . #((list 213 -1 4 1 1 1) ""))
    ("glMultiTexCoord3fvARB" . #((list 213 -1 4 101) ""))
    ("glMultiTexCoord3iARB" . #((list 213 -1 4 4 4 4) ""))
    ("glMultiTexCoord3ivARB" . #((list 213 -1 4 104) ""))
    ("glMultiTexCoord3sARB" . #((list 213 -1 4 6 6 6) ""))
    ("glMultiTexCoord3svARB" . #((list 213 -1 4 106) ""))
    ("glMultiTexCoord4dARB" . #((list 213 -1 4 0 0 0 0) ""))
    ("glMultiTexCoord4dvARB" . #((list 213 -1 4 100) ""))
    ("glMultiTexCoord4fARB" . #((list 213 -1 4 1 1 1 1) ""))
    ("glMultiTexCoord4fvARB" . #((list 213 -1 4 101) ""))
    ("glMultiTexCoord4iARB" . #((list 213 -1 4 4 4 4 4) ""))
    ("glMultiTexCoord4ivARB" . #((list 213 -1 4 104) ""))
    ("glMultiTexCoord4sARB" . #((list 213 -1 4 6 6 6 6) ""))
    ("glMultiTexCoord4svARB" . #((list 213 -1 4 106) ""))
    ("glLoadTransposeMatrixfARB" . #((list 213 -1 101) ""))
    ("glLoadTransposeMatrixdARB" . #((list 213 -1 100) ""))
    ("glMultTransposeMatrixfARB" . #((list 213 -1 101) ""))
    ("glMultTransposeMatrixdARB" . #((list 213 -1 100) ""))
    ("glSampleCoverageARB" . #((list 213 -1 1 8) ""))
    ("glSamplePassARB" . #((list 213 -1 4) ""))
    ("glCompressedTexImage3DARB" . #((list 213 -1 4 4 4 4 4 4 4 4 108) ""))
    ("glCompressedTexImage2DARB" . #((list 213 -1 4 4 4 4 4 4 4 108) ""))
    ("glCompressedTexImage1DARB" . #((list 213 -1 4 4 4 4 4 4 108) ""))
    ("glCompressedTexSubImage3DARB" . #((list 213 -1 4 4 4 4 4 4 4 4 4 4 108) ""))
    ("glCompressedTexSubImage2DARB" . #((list 213 -1 4 4 4 4 4 4 4 4 108) ""))
    ("glCompressedTexSubImage1DARB" . #((list 213 -1 4 4 4 4 4 4 108) ""))
    ("glGetCompressedTexImageARB" . #((list 213 -1 4 4 108) ""))
    ("glWeightbvARB" . #((list 213 -1 4 108) ""))
    ("glWeightsvARB" . #((list 213 -1 4 106) ""))
    ("glWeightivARB" . #((list 213 -1 4 104) ""))
    ("glWeightfvARB" . #((list 213 -1 4 101) ""))
    ("glWeightdvARB" . #((list 213 -1 4 100) ""))
    ("glWeightubvARB" . #((list 213 -1 4 108) ""))
    ("glWeightusvARB" . #((list 213 -1 4 106) ""))
    ("glWeightuivARB" . #((list 213 -1 4 104) ""))
    ("glWeightPointerARB" . #((list 213 -1 4 4 4 108) ""))
    ("glVertexBlendARB" . #((list 213 -1 4) ""))
    ("glWindowPos2dARB" . #((list 213 -1 0 0) ""))
    ("glWindowPos2dvARB" . #((list 213 -1 100) ""))
    ("glWindowPos2fARB" . #((list 213 -1 1 1) ""))
    ("glWindowPos2fvARB" . #((list 213 -1 101) ""))
    ("glWindowPos2iARB" . #((list 213 -1 4 4) ""))
    ("glWindowPos2ivARB" . #((list 213 -1 104) ""))
    ("glWindowPos2sARB" . #((list 213 -1 6 6) ""))
    ("glWindowPos2svARB" . #((list 213 -1 106) ""))
    ("glWindowPos3dARB" . #((list 213 -1 0 0 0) ""))
    ("glWindowPos3dvARB" . #((list 213 -1 100) ""))
    ("glWindowPos3fARB" . #((list 213 -1 1 1 1) ""))
    ("glWindowPos3fvARB" . #((list 213 -1 101) ""))
    ("glWindowPos3iARB" . #((list 213 -1 4 4 4) ""))
    ("glWindowPos3ivARB" . #((list 213 -1 104) ""))
    ("glWindowPos3sARB" . #((list 213 -1 6 6 6) ""))
    ("glWindowPos3svARB" . #((list 213 -1 106) ""))
    ("glGenQueriesARB" . #((list 213 -1 4 104) ""))
    ("glDeleteQueriesARB" . #((list 213 -1 4 104) ""))
    ("glBeginQueryARB" . #((list 213 -1 4 4) ""))
    ("glEndQueryARB" . #((list 213 -1 4) ""))
    ("glGetQueryivARB" . #((list 213 -1 4 4 104) ""))
    ("glGetQueryObjectivARB" . #((list 213 -1 4 4 104) ""))
    ("glGetQueryObjectuivARB" . #((list 213 -1 4 4 104) ""))
    ("glPointParameterfARB" . #((list 213 -1 4 1) ""))
    ("glPointParameterfvARB" . #((list 213 -1 4 101) ""))
    ("glBindProgramARB" . #((list 213 -1 4 4) ""))
    ("glDeleteProgramsARB" . #((list 213 -1 4 104) ""))
    ("glGenProgramsARB" . #((list 213 -1 4 104) ""))
    ("glProgramEnvParameter4dARB" . #((list 213 -1 4 4 0 0 0 0) ""))
    ("glProgramEnvParameter4dvARB" . #((list 213 -1 4 4 100) ""))
    ("glProgramEnvParameter4fARB" . #((list 213 -1 4 4 1 1 1 1) ""))
    ("glProgramEnvParameter4fvARB" . #((list 213 -1 4 4 101) ""))
    ("glProgramLocalParameter4dARB" . #((list 213 -1 4 4 0 0 0 0) ""))
    ("glProgramLocalParameter4dvARB" . #((list 213 -1 4 4 100) ""))
    ("glProgramLocalParameter4fARB" . #((list 213 -1 4 4 1 1 1 1) ""))
    ("glProgramLocalParameter4fvARB" . #((list 213 -1 4 4 101) ""))
    ("glGetProgramEnvParameterdvARB" . #((list 213 -1 4 4 100) ""))
    ("glGetProgramEnvParameterfvARB" . #((list 213 -1 4 4 101) ""))
    ("glProgramEnvParameters4fvEXT" . #((list 213 -1 4 4 4 101) ""))
    ("glProgramLocalParameters4fvEXT" . #((list 213 -1 4 4 4 101) ""))
    ("glGetProgramLocalParameterdvARB" . #((list 213 -1 4 4 100) ""))
    ("glGetProgramLocalParameterfvARB" . #((list 213 -1 4 4 101) ""))
    ("glProgramStringARB" . #((list 213 -1 4 4 4 108) ""))
    ("glGetProgramStringARB" . #((list 213 -1 4 4 108) ""))
    ("glGetProgramivARB" . #((list 213 -1 4 4 104) ""))
    ("glVertexAttrib1dARB" . #((list 213 -1 4 0) ""))
    ("glVertexAttrib1dvARB" . #((list 213 -1 4 100) ""))
    ("glVertexAttrib1fARB" . #((list 213 -1 4 1) ""))
    ("glVertexAttrib1fvARB" . #((list 213 -1 4 101) ""))
    ("glVertexAttrib1sARB" . #((list 213 -1 4 6) ""))
    ("glVertexAttrib1svARB" . #((list 213 -1 4 106) ""))
    ("glVertexAttrib2dARB" . #((list 213 -1 4 0 0) ""))
    ("glVertexAttrib2dvARB" . #((list 213 -1 4 100) ""))
    ("glVertexAttrib2fARB" . #((list 213 -1 4 1 1) ""))
    ("glVertexAttrib2fvARB" . #((list 213 -1 4 101) ""))
    ("glVertexAttrib2sARB" . #((list 213 -1 4 6 6) ""))
    ("glVertexAttrib2svARB" . #((list 213 -1 4 106) ""))
    ("glVertexAttrib3dARB" . #((list 213 -1 4 0 0 0) ""))
    ("glVertexAttrib3dvARB" . #((list 213 -1 4 100) ""))
    ("glVertexAttrib3fARB" . #((list 213 -1 4 1 1 1) ""))
    ("glVertexAttrib3fvARB" . #((list 213 -1 4 101) ""))
    ("glVertexAttrib3sARB" . #((list 213 -1 4 6 6 6) ""))
    ("glVertexAttrib3svARB" . #((list 213 -1 4 106) ""))
    ("glVertexAttrib4NbvARB" . #((list 213 -1 4 108) ""))
    ("glVertexAttrib4NivARB" . #((list 213 -1 4 104) ""))
    ("glVertexAttrib4NsvARB" . #((list 213 -1 4 106) ""))
    ("glVertexAttrib4NubARB" . #((list 213 -1 4 8 8 8 8) ""))
    ("glVertexAttrib4NubvARB" . #((list 213 -1 4 108) ""))
    ("glVertexAttrib4NuivARB" . #((list 213 -1 4 104) ""))
    ("glVertexAttrib4NusvARB" . #((list 213 -1 4 106) ""))
    ("glVertexAttrib4bvARB" . #((list 213 -1 4 108) ""))
    ("glVertexAttrib4dARB" . #((list 213 -1 4 0 0 0 0) ""))
    ("glVertexAttrib4dvARB" . #((list 213 -1 4 100) ""))
    ("glVertexAttrib4fARB" . #((list 213 -1 4 1 1 1 1) ""))
    ("glVertexAttrib4fvARB" . #((list 213 -1 4 101) ""))
    ("glVertexAttrib4ivARB" . #((list 213 -1 4 104) ""))
    ("glVertexAttrib4sARB" . #((list 213 -1 4 6 6 6 6) ""))
    ("glVertexAttrib4svARB" . #((list 213 -1 4 106) ""))
    ("glVertexAttrib4ubvARB" . #((list 213 -1 4 108) ""))
    ("glVertexAttrib4uivARB" . #((list 213 -1 4 104) ""))
    ("glVertexAttrib4usvARB" . #((list 213 -1 4 106) ""))
    ("glVertexAttribPointerARB" . #((list 213 -1 4 4 4 8 4 108) ""))
    ("glDisableVertexAttribArrayARB" . #((list 213 -1 4) ""))
    ("glEnableVertexAttribArrayARB" . #((list 213 -1 4) ""))
    ("glGetVertexAttribPointervARB" . #((list 213 -1 4 4 208) ""))
    ("glGetVertexAttribdvARB" . #((list 213 -1 4 4 100) ""))
    ("glGetVertexAttribfvARB" . #((list 213 -1 4 4 101) ""))
    ("glGetVertexAttribivARB" . #((list 213 -1 4 4 104) ""))
    ("glDeleteObjectARB" . #((list 213 -1 108) ""))
    ("glDetachObjectARB" . #((list 213 -1 108 108) ""))
    ("glShaderSourceARB" . #((list 213 -1 108 4 208 104) ""))
    ("glCompileShaderARB" . #((list 213 -1 108) ""))
    ("glAttachObjectARB" . #((list 213 -1 108 108) ""))
    ("glLinkProgramARB" . #((list 213 -1 108) ""))
    ("glUseProgramObjectARB" . #((list 213 -1 108) ""))
    ("glValidateProgramARB" . #((list 213 -1 108) ""))
    ("glUniform1fARB" . #((list 213 -1 4 1) ""))
    ("glUniform2fARB" . #((list 213 -1 4 1 1) ""))
    ("glUniform3fARB" . #((list 213 -1 4 1 1 1) ""))
    ("glUniform4fARB" . #((list 213 -1 4 1 1 1 1) ""))
    ("glUniform1iARB" . #((list 213 -1 4 4) ""))
    ("glUniform2iARB" . #((list 213 -1 4 4 4) ""))
    ("glUniform3iARB" . #((list 213 -1 4 4 4 4) ""))
    ("glUniform4iARB" . #((list 213 -1 4 4 4 4 4) ""))
    ("glUniform1fvARB" . #((list 213 -1 4 4 101) ""))
    ("glUniform2fvARB" . #((list 213 -1 4 4 101) ""))
    ("glUniform3fvARB" . #((list 213 -1 4 4 101) ""))
    ("glUniform4fvARB" . #((list 213 -1 4 4 101) ""))
    ("glUniform1ivARB" . #((list 213 -1 4 4 104) ""))
    ("glUniform2ivARB" . #((list 213 -1 4 4 104) ""))
    ("glUniform3ivARB" . #((list 213 -1 4 4 104) ""))
    ("glUniform4ivARB" . #((list 213 -1 4 4 104) ""))
    ("glUniformMatrix2fvARB" . #((list 213 -1 4 4 8 101) ""))
    ("glUniformMatrix3fvARB" . #((list 213 -1 4 4 8 101) ""))
    ("glUniformMatrix4fvARB" . #((list 213 -1 4 4 8 101) ""))
    ("glGetObjectParameterfvARB" . #((list 213 -1 108 4 101) ""))
    ("glGetObjectParameterivARB" . #((list 213 -1 108 4 104) ""))
    ("glGetInfoLogARB" . #((list 213 -1 108 4 104 108) ""))
    ("glGetAttachedObjectsARB" . #((list 213 -1 108 4 104 208) ""))
    ("glGetActiveUniformARB" . #((list 213 -1 108 4 4 104 104 104 108) ""))
    ("glGetUniformfvARB" . #((list 213 -1 108 4 101) ""))
    ("glGetUniformivARB" . #((list 213 -1 108 4 104) ""))
    ("glGetShaderSourceARB" . #((list 213 -1 108 4 104 108) ""))
    ("glBindAttribLocationARB" . #((list 213 -1 108 4 108) ""))
    ("glGetActiveAttribARB" . #((list 213 -1 108 4 4 104 104 104 108) ""))
    ("glBindBufferARB" . #((list 213 -1 4 4) ""))
    ("glDeleteBuffersARB" . #((list 213 -1 4 104) ""))
    ("glGenBuffersARB" . #((list 213 -1 4 104) ""))
    ("glBufferDataARB" . #((list 213 -1 4 4 108 4) ""))
    ("glBufferSubDataARB" . #((list 213 -1 4 4 4 108) ""))
    ("glGetBufferSubDataARB" . #((list 213 -1 4 4 4 108) ""))
    ("glGetBufferParameterivARB" . #((list 213 -1 4 4 104) ""))
    ("glGetBufferPointervARB" . #((list 213 -1 4 4 208) ""))
    ("glDrawBuffersARB" . #((list 213 -1 4 104) ""))
    ("CGLDescribePixelFormat" . #((list 213 4 108 4 4 104) ""))
    ("CGLGetPixelFormat" . #((list 213 108 108) ""))
    ("CGLRetainPixelFormat" . #((list 213 108 108) ""))
    ("CGLReleasePixelFormat" . #((list 213 -1 108) ""))
    ("CGLGetPixelFormatRetainCount" . #((list 213 4 108) ""))
    ("CGLDestroyPixelFormat" . #((list 213 4 108) ""))
    ("CGLCreateContext" . #((list 213 4 108 108 208) ""))
    ("CGLCopyContext" . #((list 213 4 108 108 4) ""))
    ("CGLRetainContext" . #((list 213 108 108) ""))
    ("CGLReleaseContext" . #((list 213 -1 108) ""))
    ("CGLGetContextRetainCount" . #((list 213 4 108) ""))
    ("CGLDestroyContext" . #((list 213 4 108) ""))
    ("CGLGetCurrentContext" . #((list 213 108) ""))
    ("CGLSetCurrentContext" . #((list 213 4 108) ""))
    ("CGLEnable" . #((list 213 4 108 4) ""))
    ("CGLDisable" . #((list 213 4 108 4) ""))
    ("CGLIsEnabled" . #((list 213 4 108 4 104) ""))
    ("CGLSetParameter" . #((list 213 4 108 4 104) ""))
    ("CGLGetParameter" . #((list 213 4 108 4 104) ""))
    ("CGLLockContext" . #((list 213 4 108) ""))
    ("CGLUnlockContext" . #((list 213 4 108) ""))
    ("CGLSetOffScreen" . #((list 213 4 108 4 4 4 108) ""))
    ("CGLGetOffScreen" . #((list 213 4 108 104 104 104 208) ""))
    ("CGLSetFullScreenOnDisplay" . #((list 213 4 108 4) ""))
    ("CGLClearDrawable" . #((list 213 4 108) ""))
    ("CGLFlushDrawable" . #((list 213 4 108) ""))
    ("CGLCreatePBuffer" . #((list 213 4 4 4 4 4 4 208) ""))
    ("CGLDescribePBuffer" . #((list 213 4 108 104 104 104 104 104) ""))
    ("CGLRetainPBuffer" . #((list 213 108 108) ""))
    ("CGLReleasePBuffer" . #((list 213 -1 108) ""))
    ("CGLGetPBufferRetainCount" . #((list 213 4 108) ""))
    ("CGLDestroyPBuffer" . #((list 213 4 108) ""))
    ("CGLGetPBuffer" . #((list 213 4 108 208 104 104 104) ""))
    ("CGLSetPBuffer" . #((list 213 4 108 108 4 4 4) ""))
    ("CGLTexImagePBuffer" . #((list 213 4 108 108 4) ""))
    ("CGLErrorString" . #((list 213 108 4) ""))
    ("CGLSetOption" . #((list 213 4 4 4) ""))
    ("CGLGetOption" . #((list 213 4 4 104) ""))
    ("CGLGetGlobalOption" . #((list 213 4 4 104) ""))
    ("CGLSetGlobalOption" . #((list 213 4 4 104) ""))
    ("CGLGetVersion" . #((list 213 -1 104 104) ""))
    ("CGLDescribeRenderer" . #((list 213 4 108 4 4 104) ""))
    ("CGLDestroyRendererInfo" . #((list 213 4 108) ""))
    ("CGLQueryRendererInfo" . #((list 213 4 4 208 104) ""))
    ("CGLSetVirtualScreen" . #((list 213 4 108 4) ""))
    ("CGLGetVirtualScreen" . #((list 213 4 108 104) ""))
    ("llvm_substring" . #((list 213 108 108 4 4) ""))
    ("llvm_string_cat" . #((list 213 108 108 108) ""))
    ("llvm_string_copy" . #((list 213 108 108) ""))
    ("llvm_string_eq" . #((list 213 4 108 108) ""))
    ("llvm_string_set" . #((list 213 -1 108 4 8) ""))
    ("llvm_string_ref" . #((list 213 8 108 4) ""))
    ("imp_randd" . #((list 213 0) ""))
    ("imp_randf" . #((list 213 1) ""))
    ("imp_rand1_i64" . #((list 213 2 2) ""))
    ("imp_rand2_i64" . #((list 213 2 2 2) ""))
    ("imp_rand1_i32" . #((list 213 4 4) ""))
    ("imp_rand2_i32" . #((list 213 4 4 4) ""))
    ("imp_rand1_f" . #((list 213 1 1) ""))
    ("imp_rand2_f" . #((list 213 1 1 1) ""))
    ("imp_rand1_d" . #((list 213 0 0) ""))
    ("imp_rand2_d" . #((list 213 0 0 0) ""))
    ("llvm_destroy_zone_after_delay" . #((list 213 -1 "%mzone*" 2) ""))
    ("free_after_delay" . #((list 213 -1 108 0) ""))
    ("impc_null" . #((list 113 108) ""))
    ("impc_true" . #((list 113 10) ""))
    ("impc_false" . #((list 113 10) ""))
    ("i1toi64" . #((list 213 2 10) ""))
    ("i1toi32" . #((list 213 4 10) ""))
    ("i1toi16" . #((list 213 6 10) ""))
    ("i1toi8" . #((list 213 8 10) ""))
    ("i64toi1" . #((list 213 10 2) ""))
    ("i32toi1" . #((list 213 10 4) ""))
    ("i16toi1" . #((list 213 10 6) ""))
    ("i8toi1" . #((list 213 10 8) ""))
    ("i8toi64" . #((list 213 2 8) ""))
    ("i8toui64" . #((list 213 2 8) ""))
    ("i8toi32" . #((list 213 4 8) ""))
    ("i8toi16" . #((list 213 6 8) ""))
    ("i8toui32" . #((list 213 4 8) ""))
    ("i64toi8" . #((list 213 8 2) ""))
    ("i32toi8" . #((list 213 8 4) ""))
    ("i16toi8" . #((list 213 8 6) ""))
    ("i16toi64" . #((list 213 2 6) ""))
    ("i16toui64" . #((list 213 2 6) ""))
    ("i16toi32" . #((list 213 4 6) ""))
    ("i16toui32" . #((list 213 4 6) ""))
    ("i64toi16" . #((list 213 6 2) ""))
    ("i32toi16" . #((list 213 6 4) ""))
    ("i32toi64" . #((list 213 2 4) ""))
    ("i32toui64" . #((list 213 2 4) ""))
    ("i64toi32" . #((list 213 4 2) ""))
    ("ftod" . #((list 213 0 1) ""))
    ("dtof" . #((list 213 1 0) ""))
    ("ftoi64" . #((list 213 2 1) ""))
    ("ftoi32" . #((list 213 4 1) ""))
    ("ftoi16" . #((list 213 6 1) ""))
    ("ftoi8" . #((list 213 8 1) ""))
    ("ftoi1" . #((list 213 10 1) ""))
    ("ftoui64" . #((list 213 2 1) ""))
    ("ftoui32" . #((list 213 4 1) ""))
    ("ftoui8" . #((list 213 8 1) ""))
    ("ftoui1" . #((list 213 10 1) ""))
    ("i64tof" . #((list 213 1 2) ""))
    ("i32tof" . #((list 213 1 4) ""))
    ("i16tof" . #((list 213 1 6) ""))
    ("i8tof" . #((list 213 1 8) ""))
    ("i1tof" . #((list 213 1 10) ""))
    ("ui64tof" . #((list 213 1 2) ""))
    ("ui32tof" . #((list 213 1 4) ""))
    ("ui16tof" . #((list 213 1 6) ""))
    ("ui8tof" . #((list 213 1 8) ""))
    ("ui1tof" . #((list 213 1 10) ""))
    ("dtoi64" . #((list 213 2 0) ""))
    ("dtoi32" . #((list 213 4 0) ""))
    ("dtoi16" . #((list 213 6 0) ""))
    ("dtoi8" . #((list 213 8 0) ""))
    ("dtoi1" . #((list 213 10 0) ""))
    ("dtoui64" . #((list 213 2 0) ""))
    ("dtoui32" . #((list 213 4 0) ""))
    ("dtoui8" . #((list 213 8 0) ""))
    ("dtoui1" . #((list 213 10 0) ""))
    ("i64tod" . #((list 213 0 2) ""))
    ("i32tod" . #((list 213 0 4) ""))
    ("i16tod" . #((list 213 0 6) ""))
    ("i8tod" . #((list 213 0 8) ""))
    ("i1tod" . #((list 213 0 10) ""))
    ("ui64tod" . #((list 213 0 2) ""))
    ("ui32tod" . #((list 213 0 4) ""))
    ("ui16tod" . #((list 213 0 6) ""))
    ("ui8tod" . #((list 213 0 8) ""))
    ("ui1tod" . #((list 213 0 10) ""))
    ("ptrtoi64" . #((list 213 2 108) ""))
    ("i64toptr" . #((list 213 108 2) ""))
    ("ptrtoi32" . #((list 213 4 108) ""))
    ("ptrtoi16" . #((list 213 6 108) ""))
    ("i32toptr" . #((list 213 108 4) ""))
    ("i16toptr" . #((list 213 108 6) ""))))

(define impc:ti:print-nativefunc-list
  (lambda ()
    (println '*impc:ti:nativefunc-list*: *impc:ti:nativefunc-list*)))

(define impc:ti:reset-nativefunc-list
  (lambda ()
    (set! *impc:ti:nativefunc-list* '())))

(define impc:ti:register-new-nativefunc
  (lambda (nativefunc-name type docstring)
    ;; check arg types
    (if (not (and (or (string? nativefunc-name) (begin (println 'nativefunc-name: nativefunc-name) #f))
                  (or (list? type) (begin (println 'type: type) #f))
                  (or (string? docstring) (begin (println docstring)))))
        (impc:compiler:print-compiler-error "couldn't register new nativefunc")
        (let ((existing (assoc-strcmp nativefunc-name *impc:ti:nativefunc-list*)))
          (if existing
              ;; update details if it already exists
              (set-cdr! existing (vector type docstring))
              ;; or create a new entry
              (set! *impc:ti:nativefunc-list*
                    (cons (cons nativefunc-name (vector type docstring))
                          *impc:ti:nativefunc-list*)))))))

(define impc:ti:get-nativefunc-type
  (lambda (nativefunc-name)
    (let ((nfunc-list (assoc-strcmp nativefunc-name *impc:ti:nativefunc-list*)))
      ;; (println 'nfunc-list: nfunc-list)
      (if nfunc-list (vector-ref (cdr nfunc-list) 0) #f))))

(define impc:ti:get-nativefunc-arg-types
  (lambda (name)
    (let ((type (impc:ti:get-nativefunc-type name)))
      (if (or (not type) (null? type))
          #f
          (map impc:ir:pretty-print-type (cdr type))))))

(define impc:ti:nativefunc-exists?
  (lambda (nativefunc-name)
    (if (impc:ti:get-nativefunc-type nativefunc-name) #t #f)))

(define impc:ti:set-nativefunc-type
  (lambda (nativefunc-name type)
    (let ((nfunc-list (assoc-strcmp nativefunc-name *impc:ti:nativefunc-list*)))
      (if nfunc-list (vector-set! (cdr nfunc-list) 0 type) #f))))

(define impc:ti:get-nativefunc-docstring
  (lambda (nativefunc-name)
    (let ((nfunc-list (assoc-strcmp nativefunc-name *impc:ti:nativefunc-list*)))
      (if nfunc-list (vector-ref (cdr nfunc-list) 1) #f))))

(define impc:ti:set-nativefunc-docstring
  (lambda (nativefunc-name docstring)
    (let ((nfunc-list (assoc-strcmp nativefunc-name *impc:ti:nativefunc-list*)))
      (if nfunc-list (vector-set! (cdr nfunc-list) 1 docstring) #f))))


;; helpers for dealing with either closures or nativefuncs

(define impc:ti:get-closure-or-nativefunc-type
  (lambda (closure-or-nativefunc-name)
    (or (impc:ti:get-closure-type closure-or-nativefunc-name)
        (impc:ti:get-nativefunc-type closure-or-nativefunc-name))))

(define impc:ti:closure-or-nativefunc-exists?
  (lambda (closure-or-nativefunc-name)
    (or (impc:ti:closure-exists? closure-or-nativefunc-name)
        (impc:ti:nativefunc-exists? closure-or-nativefunc-name))))

(define impc:ti:get-closure-or-nativefunc-arg-types
  (lambda (closure-or-nativefunc-name)
    (or (impc:ti:get-closure-arg-types closure-or-nativefunc-name)
        (impc:ti:get-nativefunc-arg-types closure-or-nativefunc-name))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; global variables (i.e. 'bind-val's)
;; -----------------------------------
;;
;; each element of the list is of the form
;;
;; (name . #(type docstring))
;;
(define *impc:ti:globalvar-list*
  '(("GL_VERSION_1_1" . #("i32" ""))
    ("GL_VERSION_1_3" . #("i32" ""))
    ("GL_VERSION_1_5" . #("i32" ""))
    ("GL_VERSION_2_1" . #("i32" ""))
    ("GL_ACCUM" . #("i32" ""))
    ("GL_RETURN" . #("i32" ""))
    ("GL_ADD" . #("i32" ""))
    ("GL_NEVER" . #("i32" ""))
    ("GL_EQUAL" . #("i32" ""))
    ("GL_GREATER" . #("i32" ""))
    ("GL_GEQUAL" . #("i32" ""))
    ("GL_CURRENT_BIT" . #("i32" ""))
    ("GL_LINE_BIT" . #("i32" ""))
    ("GL_POLYGON_STIPPLE_BIT" . #("i32" ""))
    ("GL_LIGHTING_BIT" . #("i32" ""))
    ("GL_DEPTH_BUFFER_BIT" . #("i32" ""))
    ("GL_STENCIL_BUFFER_BIT" . #("i32" ""))
    ("GL_TRANSFORM_BIT" . #("i32" ""))
    ("GL_COLOR_BUFFER_BIT" . #("i32" ""))
    ("GL_EVAL_BIT" . #("i32" ""))
    ("GL_TEXTURE_BIT" . #("i32" ""))
    ("GL_ALL_ATTRIB_BITS" . #("i32" ""))
    ("GL_POINTS" . #("i32" ""))
    ("GL_LINES" . #("i32" ""))
    ("GL_LINE_LOOP" . #("i32" ""))
    ("GL_LINE_STRIP" . #("i32" ""))
    ("GL_TRIANGLES" . #("i32" ""))
    ("GL_TRIANGLE_STRIP" . #("i32" ""))
    ("GL_TRIANGLE_FAN" . #("i32" ""))
    ("GL_QUADS" . #("i32" ""))
    ("GL_QUAD_STRIP" . #("i32" ""))
    ("GL_POLYGON" . #("i32" ""))
    ("GL_ZERO" . #("i32" ""))
    ("GL_ONE" . #("i32" ""))
    ("GL_SRC_COLOR" . #("i32" ""))
    ("GL_SRC_ALPHA" . #("i32" ""))
    ("GL_DST_ALPHA" . #("i32" ""))
    ("GL_DST_COLOR" . #("i32" ""))
    ("GL_SRC_ALPHA_SATURATE" . #("i32" ""))
    ("GL_FALSE" . #("i8" ""))
    ("GL_TRUE" . #("i8" ""))
    ("GL_CLIP_PLANE0" . #("i32" ""))
    ("GL_CLIP_PLANE2" . #("i32" ""))
    ("GL_CLIP_PLANE4" . #("i32" ""))
    ("GL_BYTE" . #("i32" ""))
    ("GL_SHORT" . #("i32" ""))
    ("GL_INT" . #("i32" ""))
    ("GL_FLOAT" . #("i32" ""))
    ("GL_3_BYTES" . #("i32" ""))
    ("GL_DOUBLE" . #("i32" ""))
    ("GL_NONE" . #("i32" ""))
    ("GL_FRONT_RIGHT" . #("i32" ""))
    ("GL_BACK_RIGHT" . #("i32" ""))
    ("GL_FRONT" . #("i32" ""))
    ("GL_BACK" . #("i32" ""))
    ("GL_RIGHT" . #("i32" ""))
    ("GL_AUX0" . #("i32" ""))
    ("GL_AUX2" . #("i32" ""))
    ("GL_NO_ERROR" . #("i32" ""))
    ("GL_INVALID_ENUM" . #("i32" ""))
    ("GL_INVALID_VALUE" . #("i32" ""))
    ("GL_INVALID_OPERATION" . #("i32" ""))
    ("GL_STACK_OVERFLOW" . #("i32" ""))
    ("GL_STACK_UNDERFLOW" . #("i32" ""))
    ("GL_OUT_OF_MEMORY" . #("i32" ""))
    ("GL_INVALID_FRAMEBUFFER_OPERATION" . #("i32" ""))
    ("GL_TABLE_TOO_LARGE" . #("i32" ""))
    ("GL_2D" . #("i32" ""))
    ("GL_3D_COLOR" . #("i32" ""))
    ("GL_4D_COLOR_TEXTURE" . #("i32" ""))
    ("GL_PASS_THROUGH_TOKEN" . #("i32" ""))
    ("GL_LINE_TOKEN" . #("i32" ""))
    ("GL_BITMAP_TOKEN" . #("i32" ""))
    ("GL_COPY_PIXEL_TOKEN" . #("i32" ""))
    ("GL_EXP" . #("i32" ""))
    ("GL_CW" . #("i32" ""))
    ("GL_COEFF" . #("i32" ""))
    ("GL_DOMAIN" . #("i32" ""))
    ("GL_CURRENT_COLOR" . #("i32" ""))
    ("GL_CURRENT_NORMAL" . #("i32" ""))
    ("GL_CURRENT_RASTER_COLOR" . #("i32" ""))
    ("GL_CURRENT_RASTER_TEXTURE_COORDS" . #("i32" ""))
    ("GL_CURRENT_RASTER_POSITION_VALID" . #("i32" ""))
    ("GL_POINT_SMOOTH" . #("i32" ""))
    ("GL_PROGRAM_POINT_SIZE" . #("i32" ""))
    ("GL_POINT_SIZE_RANGE" . #("i32" ""))
    ("GL_LINE_SMOOTH" . #("i32" ""))
    ("GL_LINE_WIDTH_RANGE" . #("i32" ""))
    ("GL_LINE_STIPPLE" . #("i32" ""))
    ("GL_LINE_STIPPLE_REPEAT" . #("i32" ""))
    ("GL_LIST_MODE" . #("i32" ""))
    ("GL_LIST_BASE" . #("i32" ""))
    ("GL_POLYGON_MODE" . #("i32" ""))
    ("GL_POLYGON_STIPPLE" . #("i32" ""))
    ("GL_CULL_FACE" . #("i32" ""))
    ("GL_FRONT_FACE" . #("i32" ""))
    ("GL_LIGHT_MODEL_LOCAL_VIEWER" . #("i32" ""))
    ("GL_LIGHT_MODEL_AMBIENT" . #("i32" ""))
    ("GL_COLOR_MATERIAL_FACE" . #("i32" ""))
    ("GL_COLOR_MATERIAL" . #("i32" ""))
    ("GL_FOG_INDEX" . #("i32" ""))
    ("GL_FOG_START" . #("i32" ""))
    ("GL_FOG_MODE" . #("i32" ""))
    ("GL_DEPTH_RANGE" . #("i32" ""))
    ("GL_DEPTH_WRITEMASK" . #("i32" ""))
    ("GL_DEPTH_FUNC" . #("i32" ""))
    ("GL_STENCIL_TEST" . #("i32" ""))
    ("GL_STENCIL_FUNC" . #("i32" ""))
    ("GL_STENCIL_FAIL" . #("i32" ""))
    ("GL_STENCIL_PASS_DEPTH_PASS" . #("i32" ""))
    ("GL_STENCIL_WRITEMASK" . #("i32" ""))
    ("GL_NORMALIZE" . #("i32" ""))
    ("GL_MODELVIEW_STACK_DEPTH" . #("i32" ""))
    ("GL_TEXTURE_STACK_DEPTH" . #("i32" ""))
    ("GL_PROJECTION_MATRIX" . #("i32" ""))
    ("GL_ATTRIB_STACK_DEPTH" . #("i32" ""))
    ("GL_ALPHA_TEST" . #("i32" ""))
    ("GL_ALPHA_TEST_REF" . #("i32" ""))
    ("GL_BLEND_DST" . #("i32" ""))
    ("GL_BLEND" . #("i32" ""))
    ("GL_INDEX_LOGIC_OP" . #("i32" ""))
    ("GL_AUX_BUFFERS" . #("i32" ""))
    ("GL_READ_BUFFER" . #("i32" ""))
    ("GL_SCISSOR_TEST" . #("i32" ""))
    ("GL_INDEX_WRITEMASK" . #("i32" ""))
    ("GL_COLOR_WRITEMASK" . #("i32" ""))
    ("GL_RGBA_MODE" . #("i32" ""))
    ("GL_STEREO" . #("i32" ""))
    ("GL_PERSPECTIVE_CORRECTION_HINT" . #("i32" ""))
    ("GL_LINE_SMOOTH_HINT" . #("i32" ""))
    ("GL_FOG_HINT" . #("i32" ""))
    ("GL_TEXTURE_GEN_T" . #("i32" ""))
    ("GL_TEXTURE_GEN_Q" . #("i32" ""))
    ("GL_PIXEL_MAP_S_TO_S" . #("i32" ""))
    ("GL_PIXEL_MAP_I_TO_G" . #("i32" ""))
    ("GL_PIXEL_MAP_I_TO_A" . #("i32" ""))
    ("GL_PIXEL_MAP_G_TO_G" . #("i32" ""))
    ("GL_PIXEL_MAP_A_TO_A" . #("i32" ""))
    ("GL_PIXEL_MAP_S_TO_S_SIZE" . #("i32" ""))
    ("GL_PIXEL_MAP_I_TO_G_SIZE" . #("i32" ""))
    ("GL_PIXEL_MAP_I_TO_A_SIZE" . #("i32" ""))
    ("GL_PIXEL_MAP_G_TO_G_SIZE" . #("i32" ""))
    ("GL_PIXEL_MAP_A_TO_A_SIZE" . #("i32" ""))
    ("GL_UNPACK_LSB_FIRST" . #("i32" ""))
    ("GL_UNPACK_SKIP_ROWS" . #("i32" ""))
    ("GL_UNPACK_ALIGNMENT" . #("i32" ""))
    ("GL_PACK_LSB_FIRST" . #("i32" ""))
    ("GL_PACK_SKIP_ROWS" . #("i32" ""))
    ("GL_PACK_ALIGNMENT" . #("i32" ""))
    ("GL_MAP_STENCIL" . #("i32" ""))
    ("GL_INDEX_OFFSET" . #("i32" ""))
    ("GL_RED_BIAS" . #("i32" ""))
    ("GL_ZOOM_Y" . #("i32" ""))
    ("GL_GREEN_BIAS" . #("i32" ""))
    ("GL_BLUE_BIAS" . #("i32" ""))
    ("GL_ALPHA_BIAS" . #("i32" ""))
    ("GL_DEPTH_BIAS" . #("i32" ""))
    ("GL_MAX_LIGHTS" . #("i32" ""))
    ("GL_MAX_TEXTURE_SIZE" . #("i32" ""))
    ("GL_MAX_ATTRIB_STACK_DEPTH" . #("i32" ""))
    ("GL_MAX_NAME_STACK_DEPTH" . #("i32" ""))
    ("GL_MAX_TEXTURE_STACK_DEPTH" . #("i32" ""))
    ("GL_MAX_CLIENT_ATTRIB_STACK_DEPTH" . #("i32" ""))
    ("GL_INDEX_BITS" . #("i32" ""))
    ("GL_GREEN_BITS" . #("i32" ""))
    ("GL_ALPHA_BITS" . #("i32" ""))
    ("GL_STENCIL_BITS" . #("i32" ""))
    ("GL_ACCUM_GREEN_BITS" . #("i32" ""))
    ("GL_ACCUM_ALPHA_BITS" . #("i32" ""))
    ("GL_AUTO_NORMAL" . #("i32" ""))
    ("GL_MAP1_INDEX" . #("i32" ""))
    ("GL_MAP1_TEXTURE_COORD_1" . #("i32" ""))
    ("GL_MAP1_TEXTURE_COORD_3" . #("i32" ""))
    ("GL_MAP1_VERTEX_3" . #("i32" ""))
    ("GL_MAP2_COLOR_4" . #("i32" ""))
    ("GL_MAP2_NORMAL" . #("i32" ""))
    ("GL_MAP2_TEXTURE_COORD_2" . #("i32" ""))
    ("GL_MAP2_TEXTURE_COORD_4" . #("i32" ""))
    ("GL_MAP2_VERTEX_4" . #("i32" ""))
    ("GL_MAP1_GRID_SEGMENTS" . #("i32" ""))
    ("GL_MAP2_GRID_SEGMENTS" . #("i32" ""))
    ("GL_TEXTURE_2D" . #("i32" ""))
    ("GL_FEEDBACK_BUFFER_SIZE" . #("i32" ""))
    ("GL_SELECTION_BUFFER_POINTER" . #("i32" ""))
    ("GL_TEXTURE_WIDTH" . #("i32" ""))
    ("GL_TEXTURE_INTERNAL_FORMAT" . #("i32" ""))
    ("GL_TEXTURE_BORDER" . #("i32" ""))
    ("GL_DONT_CARE" . #("i32" ""))
    ("GL_NICEST" . #("i32" ""))
    ("GL_LIGHT0" . #("i32" ""))
    ("GL_LIGHT1" . #("i32" ""))
    ("GL_LIGHT2" . #("i32" ""))
    ("GL_LIGHT3" . #("i32" ""))
    ("GL_LIGHT4" . #("i32" ""))
    ("GL_LIGHT5" . #("i32" ""))
    ("GL_LIGHT6" . #("i32" ""))
    ("GL_AMBIENT" . #("i32" ""))
    ("GL_SPECULAR" . #("i32" ""))
    ("GL_SPOT_DIRECTION" . #("i32" ""))
    ("GL_SPOT_CUTOFF" . #("i32" ""))
    ("GL_LINEAR_ATTENUATION" . #("i32" ""))
    ("GL_COMPILE" . #("i32" ""))
    ("GL_CLEAR" . #("i32" ""))
    ("GL_AND_REVERSE" . #("i32" ""))
    ("GL_AND_INVERTED" . #("i32" ""))
    ("GL_XOR" . #("i32" ""))
    ("GL_NOR" . #("i32" ""))
    ("GL_INVERT" . #("i32" ""))
    ("GL_COPY_INVERTED" . #("i32" ""))
    ("GL_NAND" . #("i32" ""))
    ("GL_EMISSION" . #("i32" ""))
    ("GL_AMBIENT_AND_DIFFUSE" . #("i32" ""))
    ("GL_MODELVIEW" . #("i32" ""))
    ("GL_TEXTURE" . #("i32" ""))
    ("GL_COLOR" . #("i32" ""))
    ("GL_STENCIL" . #("i32" ""))
    ("GL_COLOR_INDEX" . #("i32" ""))
    ("GL_DEPTH_COMPONENT" . #("i32" ""))
    ("GL_GREEN" . #("i32" ""))
    ("GL_ALPHA" . #("i32" ""))
    ("GL_RGBA" . #("i32" ""))
    ("GL_LUMINANCE_ALPHA" . #("i32" ""))
    ("GL_BITMAP" . #("i32" ""))
    ("GL_POINT" . #("i32" ""))
    ("GL_FILL" . #("i32" ""))
    ("GL_RENDER" . #("i32" ""))
    ("GL_SELECT" . #("i32" ""))
    ("GL_FLAT" . #("i32" ""))
    ("GL_KEEP" . #("i32" ""))
    ("GL_INCR" . #("i32" ""))
    ("GL_VENDOR" . #("i32" ""))
    ("GL_VERSION" . #("i32" ""))
    ("GL_S" . #("i32" ""))
    ("GL_R" . #("i32" ""))
    ("GL_MODULATE" . #("i32" ""))
    ("GL_TEXTURE_ENV_MODE" . #("i32" ""))
    ("GL_TEXTURE_ENV" . #("i32" ""))
    ("GL_EYE_LINEAR" . #("i32" ""))
    ("GL_SPHERE_MAP" . #("i32" ""))
    ("GL_TEXTURE_GEN_MODE" . #("i32" ""))
    ("GL_EYE_PLANE" . #("i32" ""))
    ("GL_NEAREST" . #("i32" ""))
    ("GL_NEAREST_MIPMAP_NEAREST" . #("i32" ""))
    ("GL_NEAREST_MIPMAP_LINEAR" . #("i32" ""))
    ("GL_TEXTURE_MAG_FILTER" . #("i32" ""))
    ("GL_TEXTURE_WRAP_S" . #("i32" ""))
    ("GL_CLAMP" . #("i32" ""))
    ("GL_CLIENT_PIXEL_STORE_BIT" . #("i32" ""))
    ("GL_CLIENT_ALL_ATTRIB_BITS" . #("i32" ""))
    ("GL_POLYGON_OFFSET_FACTOR" . #("i32" ""))
    ("GL_POLYGON_OFFSET_POINT" . #("i32" ""))
    ("GL_POLYGON_OFFSET_FILL" . #("i32" ""))
    ("GL_ALPHA4" . #("i32" ""))
    ("GL_ALPHA12" . #("i32" ""))
    ("GL_LUMINANCE4" . #("i32" ""))
    ("GL_LUMINANCE12" . #("i32" ""))
    ("GL_LUMINANCE4_ALPHA4" . #("i32" ""))
    ("GL_LUMINANCE8_ALPHA8" . #("i32" ""))
    ("GL_LUMINANCE12_ALPHA12" . #("i32" ""))
    ("GL_INTENSITY" . #("i32" ""))
    ("GL_INTENSITY8" . #("i32" ""))
    ("GL_INTENSITY16" . #("i32" ""))
    ("GL_RGB4" . #("i32" ""))
    ("GL_RGB8" . #("i32" ""))
    ("GL_RGB12" . #("i32" ""))
    ("GL_RGBA2" . #("i32" ""))
    ("GL_RGB5_A1" . #("i32" ""))
    ("GL_RGB10_A2" . #("i32" ""))
    ("GL_RGBA16" . #("i32" ""))
    ("GL_TEXTURE_GREEN_SIZE" . #("i32" ""))
    ("GL_TEXTURE_ALPHA_SIZE" . #("i32" ""))
    ("GL_TEXTURE_INTENSITY_SIZE" . #("i32" ""))
    ("GL_PROXY_TEXTURE_2D" . #("i32" ""))
    ("GL_TEXTURE_PRIORITY" . #("i32" ""))
    ("GL_TEXTURE_BINDING_1D" . #("i32" ""))
    ("GL_TEXTURE_BINDING_3D" . #("i32" ""))
    ("GL_VERTEX_ARRAY" . #("i32" ""))
    ("GL_COLOR_ARRAY" . #("i32" ""))
    ("GL_TEXTURE_COORD_ARRAY" . #("i32" ""))
    ("GL_VERTEX_ARRAY_SIZE" . #("i32" ""))
    ("GL_VERTEX_ARRAY_STRIDE" . #("i32" ""))
    ("GL_NORMAL_ARRAY_STRIDE" . #("i32" ""))
    ("GL_COLOR_ARRAY_TYPE" . #("i32" ""))
    ("GL_INDEX_ARRAY_TYPE" . #("i32" ""))
    ("GL_TEXTURE_COORD_ARRAY_SIZE" . #("i32" ""))
    ("GL_TEXTURE_COORD_ARRAY_STRIDE" . #("i32" ""))
    ("GL_VERTEX_ARRAY_POINTER" . #("i32" ""))
    ("GL_COLOR_ARRAY_POINTER" . #("i32" ""))
    ("GL_TEXTURE_COORD_ARRAY_POINTER" . #("i32" ""))
    ("GL_V2F" . #("i32" ""))
    ("GL_C4UB_V2F" . #("i32" ""))
    ("GL_C3F_V3F" . #("i32" ""))
    ("GL_C4F_N3F_V3F" . #("i32" ""))
    ("GL_T4F_V4F" . #("i32" ""))
    ("GL_T2F_C3F_V3F" . #("i32" ""))
    ("GL_T2F_C4F_N3F_V3F" . #("i32" ""))
    ("GL_BGR" . #("i32" ""))
    ("GL_CONSTANT_COLOR" . #("i32" ""))
    ("GL_CONSTANT_ALPHA" . #("i32" ""))
    ("GL_BLEND_COLOR" . #("i32" ""))
    ("GL_FUNC_ADD" . #("i32" ""))
    ("GL_MAX" . #("i32" ""))
    ("GL_BLEND_EQUATION_RGB" . #("i32" ""))
    ("GL_FUNC_SUBTRACT" . #("i32" ""))
    ("GL_COLOR_MATRIX" . #("i32" ""))
    ("GL_MAX_COLOR_MATRIX_STACK_DEPTH" . #("i32" ""))
    ("GL_POST_COLOR_MATRIX_GREEN_SCALE" . #("i32" ""))
    ("GL_POST_COLOR_MATRIX_ALPHA_SCALE" . #("i32" ""))
    ("GL_POST_COLOR_MATRIX_GREEN_BIAS" . #("i32" ""))
    ("GL_POST_COLOR_MATRIX_ALPHA_BIAS" . #("i32" ""))
    ("GL_COLOR_TABLE" . #("i32" ""))
    ("GL_POST_COLOR_MATRIX_COLOR_TABLE" . #("i32" ""))
    ("GL_PROXY_POST_CONVOLUTION_COLOR_TABLE" . #("i32" ""))
    ("GL_COLOR_TABLE_SCALE" . #("i32" ""))
    ("GL_COLOR_TABLE_FORMAT" . #("i32" ""))
    ("GL_COLOR_TABLE_RED_SIZE" . #("i32" ""))
    ("GL_COLOR_TABLE_BLUE_SIZE" . #("i32" ""))
    ("GL_COLOR_TABLE_LUMINANCE_SIZE" . #("i32" ""))
    ("GL_CONVOLUTION_1D" . #("i32" ""))
    ("GL_SEPARABLE_2D" . #("i32" ""))
    ("GL_CONVOLUTION_FILTER_SCALE" . #("i32" ""))
    ("GL_REDUCE" . #("i32" ""))
    ("GL_CONVOLUTION_WIDTH" . #("i32" ""))
    ("GL_MAX_CONVOLUTION_WIDTH" . #("i32" ""))
    ("GL_POST_CONVOLUTION_RED_SCALE" . #("i32" ""))
    ("GL_POST_CONVOLUTION_BLUE_SCALE" . #("i32" ""))
    ("GL_POST_CONVOLUTION_RED_BIAS" . #("i32" ""))
    ("GL_POST_CONVOLUTION_BLUE_BIAS" . #("i32" ""))
    ("GL_CONSTANT_BORDER" . #("i32" ""))
    ("GL_CONVOLUTION_BORDER_COLOR" . #("i32" ""))
    ("GL_MAX_ELEMENTS_VERTICES" . #("i32" ""))
    ("GL_HISTOGRAM" . #("i32" ""))
    ("GL_HISTOGRAM_WIDTH" . #("i32" ""))
    ("GL_HISTOGRAM_RED_SIZE" . #("i32" ""))
    ("GL_HISTOGRAM_BLUE_SIZE" . #("i32" ""))
    ("GL_HISTOGRAM_LUMINANCE_SIZE" . #("i32" ""))
    ("GL_MINMAX" . #("i32" ""))
    ("GL_MINMAX_SINK" . #("i32" ""))
    ("GL_UNSIGNED_BYTE_3_3_2" . #("i32" ""))
    ("GL_UNSIGNED_SHORT_5_5_5_1" . #("i32" ""))
    ("GL_UNSIGNED_INT_10_10_10_2" . #("i32" ""))
    ("GL_UNSIGNED_SHORT_5_6_5" . #("i32" ""))
    ("GL_UNSIGNED_SHORT_4_4_4_4_REV" . #("i32" ""))
    ("GL_UNSIGNED_INT_8_8_8_8_REV" . #("i32" ""))
    ("GL_RESCALE_NORMAL" . #("i32" ""))
    ("GL_LIGHT_MODEL_COLOR_CONTROL" . #("i32" ""))
    ("GL_SEPARATE_SPECULAR_COLOR" . #("i32" ""))
    ("GL_PACK_SKIP_IMAGES" . #("i32" ""))
    ("GL_UNPACK_SKIP_IMAGES" . #("i32" ""))
    ("GL_TEXTURE_3D" . #("i32" ""))
    ("GL_TEXTURE_DEPTH" . #("i32" ""))
    ("GL_MAX_3D_TEXTURE_SIZE" . #("i32" ""))
    ("GL_CLAMP_TO_EDGE" . #("i32" ""))
    ("GL_TEXTURE_MIN_LOD" . #("i32" ""))
    ("GL_TEXTURE_BASE_LEVEL" . #("i32" ""))
    ("GL_SMOOTH_POINT_SIZE_RANGE" . #("i32" ""))
    ("GL_SMOOTH_LINE_WIDTH_RANGE" . #("i32" ""))
    ("GL_ALIASED_POINT_SIZE_RANGE" . #("i32" ""))
    ("GL_TEXTURE0" . #("i32" ""))
    ("GL_TEXTURE1" . #("i32" ""))
    ("GL_TEXTURE2" . #("i32" ""))
    ("GL_TEXTURE3" . #("i32" ""))
    ("GL_TEXTURE4" . #("i32" ""))
    ("GL_TEXTURE5" . #("i32" ""))
    ("GL_TEXTURE6" . #("i32" ""))
    ("GL_TEXTURE7" . #("i32" ""))
    ("GL_TEXTURE8" . #("i32" ""))
    ("GL_TEXTURE9" . #("i32" ""))
    ("GL_TEXTURE10" . #("i32" ""))
    ("GL_TEXTURE11" . #("i32" ""))
    ("GL_TEXTURE12" . #("i32" ""))
    ("GL_TEXTURE13" . #("i32" ""))
    ("GL_TEXTURE14" . #("i32" ""))
    ("GL_TEXTURE15" . #("i32" ""))
    ("GL_TEXTURE16" . #("i32" ""))
    ("GL_TEXTURE17" . #("i32" ""))
    ("GL_TEXTURE18" . #("i32" ""))
    ("GL_TEXTURE19" . #("i32" ""))
    ("GL_TEXTURE20" . #("i32" ""))
    ("GL_TEXTURE21" . #("i32" ""))
    ("GL_TEXTURE22" . #("i32" ""))
    ("GL_TEXTURE23" . #("i32" ""))
    ("GL_TEXTURE24" . #("i32" ""))
    ("GL_TEXTURE25" . #("i32" ""))
    ("GL_TEXTURE26" . #("i32" ""))
    ("GL_TEXTURE27" . #("i32" ""))
    ("GL_TEXTURE28" . #("i32" ""))
    ("GL_TEXTURE29" . #("i32" ""))
    ("GL_TEXTURE30" . #("i32" ""))
    ("GL_ACTIVE_TEXTURE" . #("i32" ""))
    ("GL_MAX_TEXTURE_UNITS" . #("i32" ""))
    ("GL_COMBINE" . #("i32" ""))
    ("GL_COMBINE_ALPHA" . #("i32" ""))
    ("GL_ADD_SIGNED" . #("i32" ""))
    ("GL_CONSTANT" . #("i32" ""))
    ("GL_PREVIOUS" . #("i32" ""))
    ("GL_SRC0_RGB" . #("i32" ""))
    ("GL_SRC2_RGB" . #("i32" ""))
    ("GL_SRC4_RGB" . #("i32" ""))
    ("GL_SRC6_RGB" . #("i32" ""))
    ("GL_SRC0_ALPHA" . #("i32" ""))
    ("GL_SRC2_ALPHA" . #("i32" ""))
    ("GL_SRC4_ALPHA" . #("i32" ""))
    ("GL_SRC6_ALPHA" . #("i32" ""))
    ("GL_SOURCE0_RGB" . #("i32" ""))
    ("GL_SOURCE2_RGB" . #("i32" ""))
    ("GL_SOURCE4_RGB" . #("i32" ""))
    ("GL_SOURCE6_RGB" . #("i32" ""))
    ("GL_SOURCE0_ALPHA" . #("i32" ""))
    ("GL_SOURCE2_ALPHA" . #("i32" ""))
    ("GL_SOURCE4_ALPHA" . #("i32" ""))
    ("GL_SOURCE6_ALPHA" . #("i32" ""))
    ("GL_OPERAND0_RGB" . #("i32" ""))
    ("GL_OPERAND2_RGB" . #("i32" ""))
    ("GL_OPERAND4_RGB" . #("i32" ""))
    ("GL_OPERAND6_RGB" . #("i32" ""))
    ("GL_OPERAND0_ALPHA" . #("i32" ""))
    ("GL_OPERAND2_ALPHA" . #("i32" ""))
    ("GL_OPERAND4_ALPHA" . #("i32" ""))
    ("GL_OPERAND6_ALPHA" . #("i32" ""))
    ("GL_DOT3_RGB" . #("i32" ""))
    ("GL_TRANSPOSE_MODELVIEW_MATRIX" . #("i32" ""))
    ("GL_TRANSPOSE_TEXTURE_MATRIX" . #("i32" ""))
    ("GL_NORMAL_MAP" . #("i32" ""))
    ("GL_TEXTURE_CUBE_MAP" . #("i32" ""))
    ("GL_TEXTURE_CUBE_MAP_POSITIVE_X" . #("i32" ""))
    ("GL_TEXTURE_CUBE_MAP_POSITIVE_Y" . #("i32" ""))
    ("GL_TEXTURE_CUBE_MAP_POSITIVE_Z" . #("i32" ""))
    ("GL_PROXY_TEXTURE_CUBE_MAP" . #("i32" ""))
    ("GL_COMPRESSED_ALPHA" . #("i32" ""))
    ("GL_COMPRESSED_LUMINANCE_ALPHA" . #("i32" ""))
    ("GL_COMPRESSED_RGB" . #("i32" ""))
    ("GL_TEXTURE_COMPRESSION_HINT" . #("i32" ""))
    ("GL_TEXTURE_COMPRESSED" . #("i32" ""))
    ("GL_COMPRESSED_TEXTURE_FORMATS" . #("i32" ""))
    ("GL_MULTISAMPLE" . #("i32" ""))
    ("GL_SAMPLE_ALPHA_TO_ONE" . #("i32" ""))
    ("GL_SAMPLE_BUFFERS" . #("i32" ""))
    ("GL_SAMPLE_COVERAGE_VALUE" . #("i32" ""))
    ("GL_MULTISAMPLE_BIT" . #("i32" ""))
    ("GL_DEPTH_COMPONENT16" . #("i32" ""))
    ("GL_DEPTH_COMPONENT32" . #("i32" ""))
    ("GL_DEPTH_TEXTURE_MODE" . #("i32" ""))
    ("GL_TEXTURE_COMPARE_MODE" . #("i32" ""))
    ("GL_COMPARE_R_TO_TEXTURE" . #("i32" ""))
    ("GL_QUERY_COUNTER_BITS" . #("i32" ""))
    ("GL_QUERY_RESULT" . #("i32" ""))
    ("GL_SAMPLES_PASSED" . #("i32" ""))
    ("GL_FOG_COORD_SRC" . #("i32" ""))
    ("GL_FRAGMENT_DEPTH" . #("i32" ""))
    ("GL_FOG_COORD_ARRAY_TYPE" . #("i32" ""))
    ("GL_FOG_COORD_ARRAY_POINTER" . #("i32" ""))
    ("GL_FOG_COORDINATE_SOURCE" . #("i32" ""))
    ("GL_CURRENT_FOG_COORDINATE" . #("i32" ""))
    ("GL_FOG_COORDINATE_ARRAY_TYPE" . #("i32" ""))
    ("GL_FOG_COORDINATE_ARRAY_STRIDE" . #("i32" ""))
    ("GL_FOG_COORDINATE_ARRAY" . #("i32" ""))
    ("GL_COLOR_SUM" . #("i32" ""))
    ("GL_SECONDARY_COLOR_ARRAY_SIZE" . #("i32" ""))
    ("GL_SECONDARY_COLOR_ARRAY_STRIDE" . #("i32" ""))
    ("GL_SECONDARY_COLOR_ARRAY" . #("i32" ""))
    ("GL_POINT_SIZE_MIN" . #("i32" ""))
    ("GL_POINT_FADE_THRESHOLD_SIZE" . #("i32" ""))
    ("GL_BLEND_DST_RGB" . #("i32" ""))
    ("GL_BLEND_DST_ALPHA" . #("i32" ""))
    ("GL_GENERATE_MIPMAP" . #("i32" ""))
    ("GL_INCR_WRAP" . #("i32" ""))
    ("GL_MIRRORED_REPEAT" . #("i32" ""))
    ("GL_MAX_TEXTURE_LOD_BIAS" . #("i32" ""))
    ("GL_TEXTURE_LOD_BIAS" . #("i32" ""))
    ("GL_ARRAY_BUFFER" . #("i32" ""))
    ("GL_ARRAY_BUFFER_BINDING" . #("i32" ""))
    ("GL_VERTEX_ARRAY_BUFFER_BINDING" . #("i32" ""))
    ("GL_COLOR_ARRAY_BUFFER_BINDING" . #("i32" ""))
    ("GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING" . #("i32" ""))
    ("GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING" . #("i32" ""))
    ("GL_WEIGHT_ARRAY_BUFFER_BINDING" . #("i32" ""))
    ("GL_STREAM_DRAW" . #("i32" ""))
    ("GL_STREAM_COPY" . #("i32" ""))
    ("GL_STATIC_DRAW" . #("i32" ""))
    ("GL_STATIC_READ" . #("i32" ""))
    ("GL_DYNAMIC_DRAW" . #("i32" ""))
    ("GL_DYNAMIC_COPY" . #("i32" ""))
    ("GL_WRITE_ONLY" . #("i32" ""))
    ("GL_BUFFER_SIZE" . #("i32" ""))
    ("GL_BUFFER_ACCESS" . #("i32" ""))
    ("GL_BUFFER_MAP_POINTER" . #("i32" ""))
    ("GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING" . #("i32" ""))
    ("GL_CURRENT_PROGRAM" . #("i32" ""))
    ("GL_DELETE_STATUS" . #("i32" ""))
    ("GL_LINK_STATUS" . #("i32" ""))
    ("GL_INFO_LOG_LENGTH" . #("i32" ""))
    ("GL_ACTIVE_UNIFORMS" . #("i32" ""))
    ("GL_SHADER_SOURCE_LENGTH" . #("i32" ""))
    ("GL_FLOAT_VEC3" . #("i32" ""))
    ("GL_INT_VEC2" . #("i32" ""))
    ("GL_INT_VEC4" . #("i32" ""))
    ("GL_BOOL_VEC2" . #("i32" ""))
    ("GL_BOOL_VEC4" . #("i32" ""))
    ("GL_FLOAT_MAT3" . #("i32" ""))
    ("GL_SAMPLER_1D" . #("i32" ""))
    ("GL_SAMPLER_3D" . #("i32" ""))
    ("GL_SAMPLER_1D_SHADOW" . #("i32" ""))
    ("GL_SHADING_LANGUAGE_VERSION" . #("i32" ""))
    ("GL_MAX_VERTEX_UNIFORM_COMPONENTS" . #("i32" ""))
    ("GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS" . #("i32" ""))
    ("GL_ACTIVE_ATTRIBUTES" . #("i32" ""))
    ("GL_FRAGMENT_SHADER" . #("i32" ""))
    ("GL_VERTEX_SHADER" . #("i32" ""))
    ("GL_GEOMETRY_SHADER" . #("i32" ""))
    ("GL_FRAGMENT_SHADER_DERIVATIVE_HINT" . #("i32" ""))
    ("GL_VERTEX_ATTRIB_ARRAY_ENABLED" . #("i32" ""))
    ("GL_VERTEX_ATTRIB_ARRAY_STRIDE" . #("i32" ""))
    ("GL_VERTEX_ATTRIB_ARRAY_NORMALIZED" . #("i32" ""))
    ("GL_VERTEX_ATTRIB_ARRAY_POINTER" . #("i32" ""))
    ("GL_VERTEX_PROGRAM_TWO_SIDE" . #("i32" ""))
    ("GL_MAX_TEXTURE_IMAGE_UNITS" . #("i32" ""))
    ("GL_DRAW_BUFFER0" . #("i32" ""))
    ("GL_DRAW_BUFFER2" . #("i32" ""))
    ("GL_DRAW_BUFFER4" . #("i32" ""))
    ("GL_DRAW_BUFFER6" . #("i32" ""))
    ("GL_DRAW_BUFFER8" . #("i32" ""))
    ("GL_DRAW_BUFFER10" . #("i32" ""))
    ("GL_DRAW_BUFFER12" . #("i32" ""))
    ("GL_DRAW_BUFFER14" . #("i32" ""))
    ("GL_POINT_SPRITE" . #("i32" ""))
    ("GL_POINT_SPRITE_COORD_ORIGIN" . #("i32" ""))
    ("GL_UPPER_LEFT" . #("i32" ""))
    ("GL_STENCIL_BACK_VALUE_MASK" . #("i32" ""))
    ("GL_STENCIL_BACK_FAIL" . #("i32" ""))
    ("GL_STENCIL_BACK_PASS_DEPTH_PASS" . #("i32" ""))
    ("GL_CURRENT_RASTER_SECONDARY_COLOR" . #("i32" ""))
    ("GL_PIXEL_UNPACK_BUFFER" . #("i32" ""))
    ("GL_PIXEL_UNPACK_BUFFER_BINDING" . #("i32" ""))
    ("GL_FLOAT_MAT2x4" . #("i32" ""))
    ("GL_FLOAT_MAT3x4" . #("i32" ""))
    ("GL_FLOAT_MAT4x3" . #("i32" ""))
    ("GL_SRGB8" . #("i32" ""))
    ("GL_SRGB8_ALPHA8" . #("i32" ""))
    ("GL_SLUMINANCE8_ALPHA8" . #("i32" ""))
    ("GL_SLUMINANCE8" . #("i32" ""))
    ("GL_COMPRESSED_SRGB_ALPHA" . #("i32" ""))
    ("GL_COMPRESSED_SLUMINANCE_ALPHA" . #("i32" ""))
    ("GL_DEPTH_TEST" . #("i32" ""))
    ("GL_LIGHTING" . #("i32" ""))
    ("GL_POSITION" . #("i32" ""))
    ("GL_DIFFUSE" . #("i32" ""))
    ("GL_PROJECTION" . #("i32" ""))
    ("GL_SHININESS" . #("i32" ""))
    ("GL_UNPACK_ROW_LENGTH" . #("i32" ""))
    ("GL_TEXTURE_MIN_FILTER" . #("i32" ""))
    ("GL_TEXTURE_WRAP_T" . #("i32" ""))
    ("GL_REPEAT" . #("i32" ""))
    ("GL_RGB" . #("i32" ""))
    ("GL_UNSIGNED_BYTE" . #("i32" ""))
    ("GL_REPLACE" . #("i32" ""))
    ("GL_LINEAR" . #("i32" ""))
    ("GL_TEXTURE_RECTANGLE_ARB" . #("i32" ""))
    ("GL_RGB16" . #("i32" ""))
    ("GL_TEXTURE_HEIGHT" . #("i32" ""))
    ("GL_FRONT_AND_BACK" . #("i32" ""))
    ("GL_LINE" . #("i32" ""))
    ("GL_LIGHT_MODEL_TWO_SIDE" . #("i32" ""))
    ("GL_SMOOTH" . #("i32" ""))))

(define impc:ti:print-globalvar-list
  (lambda ()
    (println '*impc:ti:globalvar-list*: *impc:ti:globalvar-list*)))

(define impc:ti:reset-globalvar-list
  (lambda ()
    (set! *impc:ti:globalvar-list* '())))

;; type is immutable, doesn't need a setter
(define impc:ti:get-globalvar-type
  (lambda (globalvar-name)
    (let ((cls-list (assoc-strcmp globalvar-name *impc:ti:globalvar-list*)))
      (if cls-list
          (vector-ref (cdr cls-list) 0)
          #f))))

(define impc:ti:globalvar-exists?
  (lambda (globalvar-name)
    (if (impc:ti:get-globalvar-type globalvar-name) #t #f)))

(define impc:ti:register-new-globalvar
  (lambda (globalvar-name type docstring)
    (if (impc:ti:globalvar-exists? globalvar-name)
        (impc:compiler:print-already-bound-error globalvar-name type)
        ;; check arg types
        (if (not (and (or (string? globalvar-name) (begin (println 'globalvar-name: globalvar-name) #f))
                      (or (or (list? type) (integer? type)) (begin (println 'type: type) #f))
                      (or (string? docstring) (begin (println docstring) #f))))
            (impc:compiler:print-compiler-error "couldn't register new globalvar")
            (begin
              (set! *impc:ti:globalvar-list*
                    ;; the old llvm:get-global-variable-type returned
                    ;; an extra level of pointerness from the bind-val
                    ;; declaration (e.g. (bind-val mytype i64) would
                    ;; return type "i64*"), so we increment the
                    ;; "pointerlyness" by one level here to mimic this
                    ;; behaviour
                    (cons (cons globalvar-name (vector (impc:ir:pointer++ type) docstring))
                          *impc:ti:globalvar-list*))
              (impc:compiler:print-binding-details-to-log "SetValue:" globalvar-name (impc:ir:pretty-print-type type)))))))

(define impc:ti:get-globalvar-docstring
  (lambda (globalvar-name)
    (let ((cls-list (assoc-strcmp *impc:ti:globalvar-list*)))
      (if cls-list (vector-ref (cdr cls-list) 1) #f))))

(define impc:ti:set-globalvar-docstring
  (lambda (globalvar-name docstring)
    (let ((cls-list (assoc-strcmp globalvar-name *impc:ti:globalvar-list*)))
      (if cls-list (vector-set! (cdr cls-list) 1 docstring) #f))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; flags for printing debug info ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define *impc:ti:print-sub-checks* #f)
(define *impc:ti:print-main-check* #f)
(define *impc:ti:print-unifications* #f)

(define *impc:ti:print-full-generic-types* #f)
(define *impc:ti:print-code-specialization-compiles* #f)

(define *impc:compile* #t)
(define *impc:compiler:print* #f)
(define *impc:compiler:print-ast* #f)
(define *impc:compiler:verbose* #f)

(define *impc:compiler:print-raw-llvm* #f)

(define *impc:compiler:allow-structural-calls #f)

(define *impc:compiler:process* (ipc:get-process-name))
;;(define *impc:compiler:process* "utility")

(define *impc:ti:bound-lambdas* '())

(define *impc:zone* (sys:default-mzone))

(define *impc:default-zone-size* (* 8 1024))

(define *impc:compiler:message:level* 'high)
(define *sys:precomp:prev-compiler-message-level* *impc:compiler:message:level*)

(define *impc:alphabetlist* '(a b c d e f g h i j k l m n o p q r s t u v w x y z))
(define *impc:alphabetidxlist* '(0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25))

(define suppress-compiler-messages
  (lambda (bool)
    (if bool
        (set! *impc:compiler:message:level* 'low)
        (set! *impc:compiler:message:level* 'high))))

(define-macro (sys:with-quiet-compiler . form)
  `(let ((msglvl *impc:compiler:message:level*))
     (set! *impc:compiler:message:level* 'low)
     (let ((res (catch #f ,@form)))
       (set! *impc:compiler:message:level* msglvl)
       res)))

(define-macro (sys:with-noisy-compiler . form)
  `(let ((msglvl *impc:compiler:message:level*))
     (set! *impc:compiler:message:level* 'high)
     (let ((res (catch #f ,@form)))
       (set! *impc:compiler:message:level* msglvl)
       res)))

(define icr:new-zone
  (lambda args
    (if (null? args)
        (sys:create-mzone *impc:default-zone-size*)
        (sys:create-mzone (car args)))))

(define icr:destroy-zone
  (lambda (zone)
    (if (equal? *impc:zone* zone)
        (set! *impc:zone* (sys:default-mzone)))
    (if (equal? zone (sys:default-mzone))
        (print-notification "You are not allowed to destroy the default zone")
        (sys:destrop-mzone zone))))

(define icr:set-zone
  (lambda (zone)
    (set! *impc:zone* zone)))

(define icr:set-zone-default
  (lambda ()
    (set! *impc:zone* (sys:default-mzone))))

;; regex:type-split pair is like regex split
;; but only splits on 'first' occurence
(define regex:type-split
  (lambda (str char)
    (let ((p (regex:split str char)))
      (if (and (> (length p) 1)
               (> (length (cdr p)) 1))
          (list (car p) (apply string-append (cadr p)
                               (map (lambda (k) (string-append ":" k)) (cddr p))))
          p))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; strips pretty-types from source code
;; returns a cons of (the-new-ast any-explicit-types)
;;
(define impc:ti:get-var-types
  (lambda (ast)
    (let* ((types '())
           (f (lambda (ast)
                ;;(print 'ast: ast 'types: types)
                (cond ((null? ast) '())
                      ((atom? ast) ast)
                      ((member (car ast) *impc:lambdaslist*)
                       (list* (car ast) ;; 'lambda
                              (map (lambda (a)
                                     (if (and (list? a)
                                              (eq? (car a) '*colon-hook*))
                                         (impc:compiler:print-double-colon-error (caddr a)))
                                     (if (regex:match? (symbol->string a) ":")
                                         (let ((t (regex:type-split (symbol->string a) ":")))
                                           (if (regex:match? (cadr t) "^\\<|\\[")
                                               (if (not (regex:match? (cadr t) "\\>|\\]"))
                                                   (impc:compiler:print-bad-type-error (cadr t))))
                                           (set! types (cons (cons (string->symbol (car t)) (string->symbol (cadr t))) types))
                                           (string->symbol (car t)))
                                         a))
                                   (cadr ast))
                              (f (cddr ast))))
                      ((member (car ast) *impc:letslist*)
                       (list* (car ast)
                              (map (lambda (a)
                                     (if (or (atom? a)
                                             (null? (cdr a))
                                             (list? (car a))
                                             (> (length (cdr a)) 1))
                                         (impc:compiler:print-badly-formed-expression-error 'let a))
                                     (if (and (list? (car a))
                                              (eq? (car (car a)) '*colon-hook*))
                                         (impc:compiler:print-double-colon-error (caddr (car a))))
                                     (if (regex:match? (symbol->string (car a)) ":")
                                         (let ((t (regex:type-split (symbol->string (car a)) ":")))
                                           (if (regex:match? (cadr t) "^\\<|\\[")
                                               (if (not (regex:match? (cadr t) "\\>|\\]"))
                                                   (impc:compiler:print-bad-type-error (cadr t))))
                                           (set! types (cons (cons (string->symbol (car t)) (string->symbol (cadr t))) types))
                                           (list (string->symbol (car t)) (car (f (cdr a)))))
                                         (list (car a) (car (f (cdr a))))))
                                   (cadr ast))
                              (f (cddr ast))))
                      ((pair? ast)
                       (cons (f (car ast))
                             (f (cdr ast))))))))
      (cons (f ast) types))))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; expand types
;;
;; takes and {...} types and should fully expand
;; types must be generic
;;

(define impc:ti:expand-generic-type-func-gpoly-arity
  (lambda (name xvararity)
    (let* ((all-gpolys (cl:remove-if-not (lambda (x) (equal? (car x) name)) *impc:ir:gpolys*))
           (all-gtypes (map (lambda (x) (caddr x)) all-gpolys))
           (all-type-arity (map (lambda (x) (length
                                             (cl:remove-duplicates
                                              (regex:match-all (symbol->string x)
                                                               "(![A-Za-z0-9_]*)"))))
                                all-gtypes))
           (res (cl:remove #f (map (lambda (x y) (if (= x xvararity) y #f)) all-type-arity all-gtypes))))
      (if (<> (length res) 1)
          (impc:compiler:print-expansion-arity-error name (string->symbol (string-append "no_valid_arity_for_" (atom->string xvararity) "_gvar")))
          res))))


(define impc:ti:expand-generic-type
  (lambda (t)
    (let* ((t2 (symbol->string t))
           (p (regex:type-split t2 ":"))
           (name (car p)))
      (if (or (null? (cdr p))
              (not (char=? #\$ (string-ref (cadr p) 0))))
          t
          (let* ((func? (char=? #\[ (string-ref (cadr p) 1)))
                 (xtype (substring (cadr p) 1 (string-length (cadr p))))
                 (ptrdepth (impc:ir:get-ptr-depth xtype))
                 (base (impc:ir:get-base-type xtype))
                 (xvars (if func?
                            (impc:ir:get-pretty-closure-arg-strings base)
                            (impc:ir:get-pretty-tuple-arg-strings base)))
                 (gtt (if func?
                          (impc:ti:expand-generic-type-func-gpoly-arity (string->symbol name) (length xvars))
                          (assoc-strcmp (string->symbol name) *impc:ir:gpolytypes*)))
                 (gtype (if gtt
                            (symbol->string (if func? (car gtt) (cdr gtt)))
                            (impc:compiler:print-cannot-expand-non-generic-error name)))
                 (_gvars (regex:match-all gtype "(![A-Za-z0-9_]*)"))
                 (gvars (cl:remove-duplicates _gvars)))
            (if (<> (length gvars) (length xvars))
                (impc:compiler:print-expansion-arity-error (cdr t) (string->symbol (string-append (car p) ":" gtype))))
            (for-each (lambda (x y)
                        (set! gtype (regex:replace-all gtype x y)))
                      gvars xvars)
            (if func?
                (string->symbol (apply string-append (car p) "_poly_" (cname-encode gtype) (make-list (- ptrdepth 1) "*")))
                (string->symbol (apply string-append (car p) ":" gtype (make-list ptrdepth "*")))))))))


(define impc:ti:expand-generic-types
  (lambda (types)
    (map (lambda (t)
           (cons (car t) (impc:ti:expand-generic-type (cdr t)))) types)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Rename any shadow variables in code
;;
;; return new 'renamed' ast
;;

(define impc:ti:gen-shadow
  (let ((n 0))
    (lambda (x)
      (set! n (+ n 1))
      (string->symbol (string-append (symbol->string x) "_s_" (number->string n))))))

(define *impc:letslist* '(let let* letrec))

;; this code expects that all pretty types
;; have already been removed from the ast!
(define impc:ti:rename-all-shadow-vars
  (lambda (full-ast syms)
    (letrec ((f (lambda (ast fname)
                  (cond ((atom? ast) ast)
                        ((null? ast) ast)
                        ((list? ast)
                         (cond ((member (car ast) *impc:letslist*)
                                ;; first find and replace all shadow vars
                                (let* ((replace-pairs
                                        (cl:remove
                                         #f
                                         (flatten
                                          (map (lambda (x)
                                                 (let* ((pair (regex:type-split (symbol->string (car x)) ":"))
                                                        (sym (string->symbol (car pair))))
                                                   (if (or (member sym syms)
                                                           (impc:ir:gpoly-exists? sym)
                                                           (and (not (equal? sym fname))
                                                                (impc:ti:closure-exists? (symbol->string sym)))
                                                           (impc:ti:globalvar-exists? (symbol->string sym)))
                                                       (let ((shadow (impc:ti:gen-shadow sym)))
                                                         (set! syms (cons shadow syms))
                                                         (if (null? (cdr pair))
                                                             (cons sym shadow)
                                                             (list (cons sym shadow)
                                                                   (cons (car x)
                                                                         (string->symbol
                                                                          (string-append
                                                                           (symbol->string shadow) ":" (cadr pair)))))))
                                                       (begin
                                                         (set! syms (cons sym syms))
                                                         #f))))
                                               (cadr ast)))))
                                       (newast (replace-all ast replace-pairs)))
                                  ;; now make sure we have code coverage!
                                  (cons (car newast)
                                        (cons (map (lambda (x) (cons (car x) (f (cdr x) fname))) (cadr newast))
                                              (f (cddr newast) fname)))))
                               ((member (car ast) *impc:lambdaslist*)
                                (let* ((replace-pairs
                                        (cl:remove
                                         #f
                                         (flatten
                                          (map (lambda (x)
                                                 (let* ((pair (regex:type-split (symbol->string x) ":"))
                                                        (sym (string->symbol (car pair))))
                                                   (if (or (member sym syms)
                                                           (and (not (equal? sym fname))
                                                                (impc:ti:closure-exists? (symbol->string sym)))
                                                           (impc:ti:globalvar-exists? (symbol->string sym)))
                                                       (let ((shadow (impc:ti:gen-shadow sym)))
                                                         (set! syms (cons shadow syms))
                                                         (if (null? (cdr pair))
                                                             (cons x shadow)
                                                             (list (cons sym shadow)
                                                                   (cons x
                                                                         (string->symbol
                                                                          (string-append
                                                                           (symbol->string shadow) ":" (cadr pair)))))))
                                                       (begin
                                                         (set! syms (cons sym syms))
                                                         #f))))
                                               (cadr ast)))))
                                       (newast (replace-all ast replace-pairs)))
                                  (cons (car ast)
                                        (cons (cadr newast)
                                              (f (cddr newast) fname)))))
                               ((pair? ast)
                                (cons (f (car ast) fname)
                                      (f (cdr ast) fname)))
                               (else ast)))))))
      (if (equal? (car full-ast) 'let)
          (f full-ast (caaadr full-ast))
          (f full-ast '___no_sym___)))))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Simple Compile Time Generics using type classes
;;

(define *impc:ti:vtypes* (list))

(define impc:ti:add-vtype
  (lambda (name type)
    (if (string? type)
        (set! type (impc:ir:get-type-from-pretty-str type)))
    (if (string? name)
        (set! name (string->symbol name)))
    (let ((v (assoc-strcmp name *impc:ti:vtypes*)))
      (if v
          (if (member type v) #t
              (set-cdr! v (cons type (cdr v))))
          (set! *impc:ti:vtypes* (cons (list name type) *impc:ti:vtypes*)))
      (impc:compiler:print-binding-details-to-log "Appended type variable " name type)
      #t)))


(define impc:ti:vtypes
  (lambda (name)
    (let ((res (assoc-strcmp name *impc:ti:vtypes*)))
      (if res (cdr res)
          #f))))

(define impc:ti:vtype-match?
  (lambda (name type)
    (let ((res (assoc-strcmp name *impc:ti:vtypes*)))
      (if (list? res) (if (member type res) #t #f)
          #f))))


(define impc:ti:check-for-vtypes
  (lambda (ast)
    (let* ((atypes (cdr (impc:ti:get-var-types ast)))
           (types (map (lambda (v) (impc:ti:vtypes (cdr v))) atypes))
           (rest (cl:remove #f types)))
                                        ;(println 'atypes: atypes 'types: types 'rest: rest)
      (if (> (length rest) 0) #t #f))))

(define impc:ti:force-vtypes
  (lambda (ast)
    (replace-all ast '((y:num . y:double)))))



(define impc:ti:vtype-transforms
  (lambda (name ast)
    (if (symbol? name) (set! name (symbol->string name)))
    (let* ((stripped (impc:ti:get-var-types ast))
           (args (cadr (caddr (car stripped))))
           (atypes (reverse (cdr stripped))) ;; statically bound types
           (tvar-lists (map (lambda (v) (impc:ti:vtypes (cdr v))) atypes))
           (tlists (cl:remove #f tvar-lists))
           (combinations (if (= (length tlists) 1)
                             (map (lambda (x) (list x)) (car tlists))
                             (apply multi-list-combination tlists)))
           (fixedtype-lists (map (lambda (comb)
                                   (map (lambda (at c)
                                          (let ((findstr (string-append (symbol->string (car at))
                                                                        ":"
                                                                        (symbol->string (cdr at))))
                                                (replacestr (string-append (symbol->string (car at))
                                                                           ":"
                                                                           (symbol->string c))))
                                            (cons (string->symbol findstr)
                                                  (string->symbol replacestr))))
                                        atypes
                                        comb))
                                 combinations))
           (fixedtype-lists2 (map (lambda (comb)
                                    (map (lambda (at c)
                                           (let ((findstr (string-append ":" (symbol->string (cdr at))))
                                                 (replacestr (impc:ir:get-base-type (symbol->string c))))
                                             (cons (string->symbol findstr)
                                                   (string->symbol replacestr))))
                                         atypes
                                         comb))
                                  combinations))
           (newnames (map (lambda (r)
                            (let* ((ctype (cname_encode (apply string-append
                                                               (map (lambda (t)
                                                                      (symbol->string t))
                                                                    r))))
                                   (nameandtype (string-append name "_poly_" ctype)))
                              (cons (string->symbol name) (string->symbol nameandtype))))
                          combinations)))
      (list (map (lambda (n) (cdr n)) newnames)
            (map (lambda (n r r2)
                                        ;(println '-> (cons n (append r r2)))
                   (replace-all (cl:copy-list ast) (cons n (append r r2))))
                 newnames
                 fixedtype-lists
                 fixedtype-lists2)))))


(define impc:ti:parametric-poly-pass
  (lambda (ast)
    ;; (println 'impc:ti:parametric-poly-pass ast)
    (if (not (impc:ti:check-for-vtypes ast))
        (eval ast (interaction-environment)) ;; if not generic func compile normally
        (let* ((storeprint print) ;; set print to nothing but store original as storeprint
               (name (cadr ast)) ;; otherwise compile all required templates
               (dat (impc:ti:vtype-transforms name ast))
               (_ (set! print (lambda args (storeprint "")))) ;;setting print to suppress compiler output
               (res (map (lambda (fname nast)
                                        ;(println 'fname: fname)
                           (let ((val (call/cc (lambda (k)
                                                 (set! print-error (lambda args
                                                                     ;; (println "andrew world")
                                                                     ;;(apply pprint-error args)
                                                                     (k #f)))
                                                 #t))))
                                        ;(println 'bingo: val 'fname: fname)
                             (if (equal? val #t)
                                 (let* ((rr (eval nast (interaction-environment)))
                                        (strtype (impc:ti:get-closure-or-nativefunc-type (symbol->string fname)))
                                        (type (impc:ir:get-type-from-pretty-str strtype)))
                                   (and type
                                        (begin
                                          (eval `(bind-poly ,name ,fname ,(string->symbol strtype))
                                                (interaction-environment))
                                          type))))))
                         (car dat)
                         (cadr dat))))
          ;; restore print-error and print
          (set! print-error (lambda args (apply pprint-error args) (throw "")))
          (set! print storeprint)
          (print)
          (if (> (length (cl:remove '() (cl:remove #f res))) 0)
              (begin
                (print "Compiled generic function")
                (print-with-colors 'green 'default #t name)
                (print-with-colors 'blue 'default #t
                                   (for-each (lambda (k)
                                               (print " " (impc:ir:pretty-print-type k)))
                                             (cl:remove '() (cl:remove #f res))))
                #t)
              (begin (impc:compiler:print-no-valid-forms-for-generic-error name)
                     #f))))))



;;
;; TRANSFORM CODE
;;
;; Transform straight R5RS code into
;; a simpler but still valid R5RS scheme code
;;

(define impc:ti:and
  (lambda (ast)
    (if (pair? ast)
        (list 'if (car ast)
              (if (null? (cdr ast))
                  (car ast)
                  (impc:ti:and (cdr ast)))
              #f))))

(define impc:ti:or
  (lambda (ast)
    (if (pair? ast)
        (list 'if (car ast)
              (car ast)
              (if (null? (cdr ast))
                  #f
                  (impc:ti:or (cdr ast)))))))

(define impc:ti:cond
  (lambda (ast)
    (if (null? ast) '()
	      (list 'if (caar ast)
              (if (null? (cdar ast))
                  '()
                  (apply list 'begin (cdar ast)))
              (impc:ti:cond (cdr ast))))))

(define impc:ti:cond
  (lambda (ast)
    (cl:remove '()
               (if (null? ast) '()
                   (list 'if (caar ast)
                         (if (null? (cdar ast))
                             (impc:compiler:print-badly-formed-expression-error 'cond ast)
                             (apply list 'begin (cdar ast)))
                         (if (and
                              (not (null? (cdr ast)))
                              (eq? (caadr ast) 'else))
                             (apply list 'begin (cdadr ast))
                             (if (not (null? (cdr ast)))
                                 (impc:ti:cond (cdr ast)))))))))


(define impc:ti:list
  (lambda (ast)
    (if (null? ast) 'null
        (list 'cons
              (car ast)
              (impc:ti:list (cdr ast))))))


(define impc:ti:println
  (lambda (ast)
    (if (null? ast)
        `(print_return)
        `(begin
           ,(if (string? (car ast))
                (list 'llvm_printf "%s" (car ast))
                (list 'print (car ast)))
           ,@(flatten-1 (map (lambda (x)
                               (if (string? x)
                                   (list
                                    (list 'print_space)
                                    (list 'llvm_printf "%s" x))
                                   (list
                                    (list 'print_space)
                                    (list 'print x))))
                             (cdr ast)))
           (print_return)))))

(define impc:ti:println2
  (lambda (ast)
    (if (null? ast)
        `(print_return)
        `(begin
           ,(if (string? (car ast))
                (list 'llvm_printf "%s" (car ast))
                (list 'print (car ast)))
           ,@(flatten-1 (map (lambda (x)
                               (if (string? x)
                                   (list
                                    ;; (list 'print_space)
                                    (list 'llvm_printf "%s" x))
                                   (list
                                    ;; (list 'print_space)
                                    (list 'print x))))
                             (cdr ast)))))))

(define impc:ti:sprintln
  (lambda (ast)
    (if (null? ast)
        (Str "")
        `(memzone 1024
           (string_cat
            ,(if (string? (car ast))
                 `(let ((x_t_mst:i8* (salloc 1024)))
                    (llvm_sprintf x_t_mst "%s" ,(car ast))
                    (Str x_t_mst))
                 (list 'tostring (car ast)))
            ,@(flatten-1 (map (lambda (x)
                                (if (string? x)
                                    (list `(let ((x_t_mst:i8* (salloc 1024)))
                                             (llvm_sprintf x_t_mst " %s" ,x)
                                             (Str x_t_mst)))
                                    (list
                                     (list 'tostring_space)
                                     (list 'tostring x))))
                              (cdr ast))))))))


(define impc:ti:sprintln2
  (lambda (ast)
    (if (null? ast)
        (Str "")
        `(memzone 1024
           (string_cat
            ,@(map (lambda (x)
                     (if (string? x)
                         `(let ((xx_t_mst:i8* (salloc 1024)))
                            (llvm_sprintf xx_t_mst "%s" ,x)
                            (Str xx_t_mst))
                         (list 'tostring x)))
                   ast))))))


(define impc:ti:format
  (lambda (ast)
    (if (null? ast) 'null
        (list 'string_cat
              (if (string? (car ast))
                  (list 'Str (car ast))
                  (list 'str_format (car ast)))
              (impc:ti:format (cdr ast))))))



;; (define impc:ti:map
;;    (lambda (ast)
;;       (list 'let 'maplloop (append (map (lambda (p l)
;;                                        (cons l (list p)))
;;                                     (cdr ast)
;;                                     (list 'l1 'l2 'l3 'l4 'l5 'l6 'l7 'l8 'l9))
;;                                (list (list 'll '(list))))
;;             (list 'if '(null? l1) '(reverse ll)
;;                   (append '(maplloop)
;;                         (map (lambda (p l)
;;                                 (list 'cdr l))
;;                              (cdr ast)
;;                              (list 'l1 'l2 'l3 'l4 'l5 'l6 'l7 'l8 'l9))
;;                         (list (list 'cons (append (list (car ast))
;;                                                   (map (lambda (p l)
;;                                                           (list 'car l))
;;                                                        (cdr ast)
;;                                                        (list 'l1 'l2 'l3 'l4 'l5 'l6 'l7 'l8 'l9)))
;;                                     'll)))))))

(define impc:ti:not
  (lambda (ast)
    (list 'if ast #f #t)))

;; (define impc:ti:case
;;   (lambda (expr body)
;;     (if (null? body)
;;         '(list)
;;         `(if ,(if (eq? 'else (caar body))
;;                   #t
;;                   (list 'member expr (cons 'list (caar body))))
;;              ,@(cdar body)
;;              ,(impc:ti:case expr (cdr body))))))


(define impc:ti:quote
  (lambda (ast)
    (cond ((null? ast) '(impc_null)) ;(list))
          ((symbol? ast) `(llvm_make_symbol ,(symbol->string ast)))
          ((list? ast)
           (cons 'list (map (lambda (a)
                              (if (or (eq? 'NIL a)
                                      (null? a))
                                  '(list)
                                  a))
                            ast)))
          (else ast))))


;; (define impc:ti:random
;;    (lambda (ast)
;;       (case (length ast)
;;             ((0) (append (list 'imp_randd) ast))
;;             ((1) (append (list 'imp_rand1) ast))
;;             ((2) (append (list 'imp_rand2) ast)))))


(define *anonlambdanum* 0)

;; no anonymous lambdas !!!
(define impc:ti:lambda
  (lambda (ast)
    (set! *anonlambdanum* (+ 1 *anonlambdanum*))
    (let* ((fname (string->symbol (string-append "_anon_lambda_" (number->string *anonlambdanum*))))
           (rest (cons (impc:ti:first-transform (cadr ast) #t)
                       (list (cons 'begin (impc:ti:first-transform (cddr ast) #t)))))
           ;;(expr (cons 'lambda rest)))
           (expr (cons (car ast) rest)))
      `(let ((,fname ,expr))
         (begin ,fname)))))


;; replace (* 2 3 4 5) or (+ 2 3 4 5)
;; with (* 2 (* 3 (* 4 5))) etc..
(define impc:ti:binary-arity
  (lambda (ast inbody?)
    (let ((op (car ast))
          (inlst (reverse (cdr ast))))
      (let loop ((rest (cdr inlst))
                 (lst (car inlst)))
        (if (null? rest) lst
            (loop (cdr rest) (cons op (cons (impc:ti:first-transform (car rest) inbody?) (list lst)))))))))


(define impc:ti:binary-arity
  (lambda (ast inbody?)
    (let ((op (car ast))
          (inlst (cdr ast)))
      (if (< (length inlst) 2)
          (impc:compiler:print-bad-arity-error ast))
      (let loop ((rest (cddr inlst))
                 (lst (list op
                            (impc:ti:first-transform (car inlst) inbody?)
                            (impc:ti:first-transform (cadr inlst) inbody?))))
        (if (null? rest) lst
            (loop (cdr rest) (list op lst (impc:ti:first-transform (car rest) inbody?))))))))


(define impc:ti:bitwise-not-to-eor
  (lambda (ast inbody?)
    (list 'bitwise-eor (cadr ast) -1)))


(define impc:ti:afill!
  (lambda (ast)
    (append '(begin)
            (map (lambda (arg idx)
                   (list 'aset! (car ast) idx arg))
                 (cdr ast)
                 (make-list-with-proc (length ast) (lambda (i) i))))))


(define impc:ti:pfill!
  (lambda (ast)
    (append '(begin)
            (map (lambda (arg idx)
                   (list 'pset! (car ast) idx arg))
                 (cdr ast)
                 (make-list-with-proc (length ast) (lambda (i) i))))))


(define impc:ti:tfill!
  (lambda (ast)
    (append '(begin)
            (map (lambda (arg idx)
                   (list 'tset! (car ast) idx arg))
                 (cdr ast)
                 (make-list-with-proc (length ast) (lambda (i) i))))))

(define impc:ti:vfill!
  (lambda (ast)
    (append '(begin)
            (map (lambda (arg idx)
                   (list 'vset! (car ast) idx arg))
                 (cdr ast)
                 (make-list-with-proc (length ast) (lambda (i) i))))))

;; simple tuple binding
;; (let ((tuple:<i32,double,i32,i64>* (alloc))
;;       ((var1 0) (var2 0.0)))
;;   (tbind tuple _ var2 _ var1)
;;
;;   would match var2 to the double
;;   and var1 to the i64
;;
(define-macro (tbind data . args)
  (cons 'begin
        (map (lambda (x n)
               (if (not (eq? x '_))
                   `(set! ,x (tref ,data ,n))))
             args
             (make-list-with-proc (length args) (lambda (i) (real->integer i))))))

(define *xtm_mz_num* 0)

(define impc:ti:check-memzone-void?
  (lambda (ast)
    (if (atom? ast)
        (if (equal? ast 'void) #t #f)
        (if (list? ast)
            (if (null? ast)
                #f
                (impc:ti:check-memzone-void? (car (reverse ast))))
            #f))))

(define impc:ti:memzone
  (lambda (ast)
    (define zone_returns_void? (impc:ti:check-memzone-void? ast))
    (if zone_returns_void?
        `(begin (push_new_zone ,(cadr ast))
                ,(if (= (length ast) 3) (caddr ast) (cadddr ast))
                (pop_zone)
                void)
        (begin
          (define resname (string->symbol (string-append "res" (number->string (modulo *xtm_mz_num* 100)))))
          (define zonename (string->symbol (string-append "zone" (number->string (modulo *xtm_mz_num* 100)))))
          (define newzname (string->symbol (string-append "newz" (number->string (modulo *xtm_mz_num* 100)))))
          (define rescopyname (string->symbol (string-append "rescopy" (number->string (modulo *xtm_mz_num* 100)))))
          (set! *xtm_mz_num* (+ *xtm_mz_num* 1))
          (if (or (> (length ast) 4)
                  (< (length ast) 3))
              (impc:compiler:print-bad-arity-error ast))
          `(begin (push_new_zone ,(cadr ast))
                  (let ((,resname ,(if (= (length ast) 3) (caddr ast) (cadddr ast)))
                        (,zonename (pop_zone))
                        (,newzname (llvm_peek_zone_stack)))
                    ;; this extra let seems reduentant! BUT is needed
                    ;; because rescopyname should go in newzone not zonename
                    ;; i.e. needs to go into a *new* let after pop_zone is called
                    (let ((,rescopyname (zcopy ,resname ,zonename ,newzname)))
                      ,(if (= (length ast) 3)
                           `(llvm_zone_destroy ,zonename)
                           `(llvm_destroy_zone_after_delay ,zonename ,(caddr ast)))
                      ,rescopyname)))))))

(define impc:ti:letz
  (lambda (ast)
    ;; (if (not (number? (eval (cadr ast))))
    ;;     (impc:compiler:print-needs-zone-size-error 'letz)
    (if (list? (caadr ast))
        (impc:ti:memzone `(memzone ,(* 1024 8)
                                   (let ,(cadr ast) ,@(cddr ast))))
        (impc:ti:memzone `(memzone ,(cadr ast)
                                   (let ,(caddr ast) ,@(cdddr ast)))))))


(define impc:ti:callback
  (lambda (ast)
    `(let ((zold (llvm_peek_zone_stack))
           (znew (push_new_zone (* 1024 8))))
       (llvm_callback ,(car ast)
                      ,(cadr ast)
                      ,@(map (lambda (x)
                               (impc:ti:first-transform `(zcopy ,x zold znew) #t))
                             (cddr ast)))
       (pop_zone)
       (llvm_destroy_zone_after_delay znew
                                      (+ (- ,(car ast) (llvm_now))
                                         (* ,*au:samplerate* 10)))
       #t)))

(define impc:ti:gteq
  (lambda (ast)
    `(or (> ,(cadr ast) ,(caddr ast))
         (= ,(cadr ast) ,(caddr ast)))))

(define impc:ti:lteq
  (lambda (ast)
    `(or (< ,(cadr ast) ,(caddr ast))
         (= ,(cadr ast) ,(caddr ast)))))


;; This to auto surround dotimes with a let
(define impc:ti:doloop
  (lambda (ast inbody?)
    (let* ((pair (regex:type-split (symbol->string (caadr ast)) ":"))
           (sym (string->symbol (car pair))))
      `(let ((,(caadr ast) (bitconvert 0)))
         (begin
           (dotimes (,sym ,(impc:ti:first-transform (cadr (cadr ast)) inbody?))
             (begin ,@(impc:ti:first-transform (cddr ast) inbody?))))))))

(define impc:ti:dotimes
  (lambda (ast inbody?)
    (list 'dotimes
          (impc:ti:first-transform (cadr ast) inbody?)
          (cons 'begin (impc:ti:first-transform (cddr ast) inbody?)))))

(define impc:ti:while
  (lambda (ast inbody?)
    (list 'while
          (impc:ti:first-transform (cadr ast) inbody?)
          (cons 'begin (impc:ti:first-transform (cddr ast) inbody?)))))

(define *unique-polynum* 0)

(define *impc:mathintrinsicslist* '(sin cos ceil floor exp fmod pow log log2 log10 sqrt fabs round trunc nearbyint fma exp2 powi))
(define *impc:mathbinaryaritylist* '(* - / + % modulo bitwise-and bitwise-or bitwise-eor bitwise-shift-left bitwise-shift-right))
(define *impc:lambdaslist* '(lambda lambdas lambdaz lambdah))

(define impc:ti:first-transform
  (lambda (ast inbody?)
    (if (null? ast) '()
        (cond ((list? ast)
               (cond ((or (impc:ir:poly-types (car ast))
                          (impc:ir:gpoly-exists? (car ast)))
                      (set! *unique-polynum* (+ 1 *unique-polynum*))
                      (cons (string->symbol (string-append (symbol->string (car ast))
                                                           "##" ;"$$$"
                                                           (number->string *unique-polynum*)))
                            (impc:ti:first-transform (cdr ast) inbody?)))
                     ((and
                       (symbol? (car ast))
                       (regex:match? (symbol->string (car ast)) ":\\[")
                       (impc:ir:gpoly-exists? (car (regex:type-split (symbol->string (car ast)) ":"))))
                      (let* ((p (regex:type-split (symbol->string (car ast)) ":"))
                             (ptrdepth (impc:ir:get-ptr-depth (cadr p)))
                             (base (impc:ir:get-base-type (cadr p))))
                        (_specialize-generic (car p) (cadr p))
                        (cons
                         (string->symbol (apply string-append (car p) "_poly_" (cname-encode (cadr p)) (make-list (- ptrdepth 1) "*")))
                         (impc:ti:first-transform (cdr ast) inbody?))))
                     ((eq? (car ast) 'letz)
                      (impc:ti:first-transform (impc:ti:letz ast) inbody?))
                     ((eq? (car ast) 'memzone)
                      (impc:ti:first-transform (impc:ti:memzone ast) inbody?))
                     ((eq? (car ast) '>=)
                      (impc:ti:first-transform (impc:ti:gteq ast) inbody?))
                     ((eq? (car ast) '<=)
                      (impc:ti:first-transform (impc:ti:lteq ast) inbody?))
                     ((eq? (car ast) 'and)
                      (impc:ti:first-transform (impc:ti:and (cdr ast)) inbody?))
                     ;; ((eq? (car ast) 'random)
                     ;;  (impc:ti:first-transform (impc:ti:random (cdr ast)) inbody?))
                     ((eq? (car ast) 'quote)
                      (impc:ti:first-transform (impc:ti:quote (cadr ast)) inbody?))
                     ((eq? (car ast) 'list)
                      (impc:ti:first-transform (impc:ti:list (cdr ast)) inbody?))
                     ((or (eq? (car ast) 'strln)
                          (eq? (car ast) 'strj))
                      (impc:ti:first-transform (impc:ti:format (cdr ast)) inbody?))
                     ((eq? (car ast) 'sprintln)
                      (impc:ti:first-transform (impc:ti:sprintln (cdr ast)) inbody?))
                     ((eq? (car ast) 'sprintout)
                      (impc:ti:first-transform (impc:ti:sprintln2 (cdr ast)) inbody?))
                     ((eq? (car ast) 'println)
                      (impc:ti:first-transform (impc:ti:println (cdr ast)) inbody?))
                     ((eq? (car ast) 'printout)
                      (impc:ti:first-transform (impc:ti:println2 (cdr ast)) inbody?))
                     ((eq? (car ast) 'afill!)
                      (impc:ti:first-transform (impc:ti:afill! (cdr ast)) inbody?))
                     ((eq? (car ast) 'pfill!)
                      (impc:ti:first-transform (impc:ti:pfill! (cdr ast)) inbody?))
                     ((eq? (car ast) 'tfill!)
                      (impc:ti:first-transform (impc:ti:tfill! (cdr ast)) inbody?))
                     ((eq? (car ast) 'vfill!)
                      (impc:ti:first-transform (impc:ti:vfill! (cdr ast)) inbody?))
                     ((eq? (car ast) 'or)
                      (impc:ti:first-transform (impc:ti:or (cdr ast)) inbody?))
                     ((eq? (car ast) 'free)
                      (list 'free (list 'bitcast (impc:ti:first-transform (cadr ast) inbody?)
                                        'i8*)))
                     ((member (car ast) '(array))
                      (impc:ti:first-transform (impc:ti:array ast) inbody?))
                     ((member (car ast) '(tuple))
                      (impc:ti:first-transform (impc:ti:tuple ast) inbody?))
                     ((eq? (car ast) 'not)
                      (impc:ti:first-transform (impc:ti:not (cadr ast)) inbody?))
                     ((member (car ast) '(callback schedule))
                      (impc:ti:first-transform (impc:ti:callback (impc:ti:first-transform (cdr ast) inbody?)) inbody?))
                     ((and (member (car ast) *impc:mathbinaryaritylist*) ;; '(* - / + % modulo bitwise-and bitwise-or bitwise-eor bitwise-shift-left bitwise-shift-right))
                           (<> (length ast) 3))
                      (impc:ti:first-transform (impc:ti:binary-arity ast inbody?) inbody?))
                     ((member (car ast) '(bitwise-not ~))
                      (impc:ti:bitwise-not-to-eor ast inbody?))
                     ((member (car ast) *impc:lambdaslist*)
                      (if inbody?
                          (impc:ti:lambda ast)
                          (cons (impc:ti:first-transform (car ast) inbody?)
                                (cons (impc:ti:first-transform (cadr ast) #t)
                                      (list (cons 'begin (impc:ti:first-transform (cddr ast) #t)))))))
                     ((eq? (car ast) 'cond)
                      (impc:ti:first-transform (impc:ti:cond (cdr ast)) inbody?))
                     ((eq? (car ast) 'cset!)
                      (list 'closure-set!
                            (impc:ti:first-transform (cadr ast) inbody?)
                            (symbol->string (caddr ast))
                            (impc:ti:first-transform (cadddr ast) inbody?)
                            (if (not (null? (cddddr ast)))
                                (impc:ir:get-type-str (impc:ir:convert-from-pretty-types (car (cddddr ast)))))))
                     ((eq? (car ast) 'cref)
                      (list 'closure-ref
                            (impc:ti:first-transform (cadr ast) inbody?)
                            (symbol->string (caddr ast))
                            (if (not (null? (cdddr ast)))
                                (impc:ir:get-type-str (impc:ir:convert-from-pretty-types (cadddr ast))))))
                     ((eq? (car ast) 'refcheck)
                      (list 'closure-refcheck
                            (impc:ti:first-transform (cadr ast) inbody?)
                            (symbol->string (caddr ast))))
                     ((member (car ast) '(cast convert))
                      (if (= (length ast) 2)
                          (impc:ti:first-transform (list (if (eq? (car ast) 'cast)
                                                             'bitcast
                                                             'bitconvert)
                                                         (cadr ast)) inbody?)
                          (let* ((p (regex:type-split (symbol->string (caddr ast)) ":"))
                                 (ptrdepth (impc:ir:get-ptr-depth (caddr ast)))
                                 (basetype (if (null? (cdr p)) #f (impc:ir:get-base-type (cadr p))))
                                 (etype (if (null? (cdr p)) #f (cname-encode basetype))))
                            (impc:ti:first-transform
                             (list (if (eq? (car ast) 'cast)
                                       'bitcast
                                       'bitconvert)
                                   (cadr ast)
                                   (if etype
                                       (string->symbol
                                        (apply string-append "%" (car p) "_poly_" etype
                                               (make-list ptrdepth "*")))
                                       (string->symbol (car p))))
                             inbody?))))
                     ((eq? (car ast) 'doloop) (impc:ti:doloop ast inbody?))
                     ((eq? (car ast) 'dotimes) (impc:ti:dotimes ast inbody?))
                     ((eq? (car ast) 'while) (impc:ti:while ast inbody?))
                     ((member (car ast) *impc:letslist*)
                      (cons (impc:ti:first-transform (car ast) inbody?)
                            (cons (map (lambda (p)
                                         (list (impc:ti:first-transform (car p) #f)
                                               (impc:ti:first-transform (cadr p) #f))
                                         )
                                       (cadr ast))
                                  (list (cons 'begin (impc:ti:first-transform (cddr ast) #t))))))
                     ((and (symbol? (car ast))
                           (regex:match? (symbol->string (car ast)) ".*\\..*")
                           (not (regex:match? (symbol->string (car ast)) "\\.[0-9]*i$"))
                           ;; this last case here to catch of '.' in
                           ;; floating point numbers of type 1.000:float etc..
                           (not (number? (string->atom (car (regex:type-split (symbol->string (car ast)) ":"))))))
                      (if (regex:match? (symbol->string (car ast)) ".*\\..*:.*")
                          (let* ((subs (regex:split (symbol->string (car ast)) "\\."))
                                 (a (string->symbol (car subs)))
                                 (subs2 (regex:type-split (cadr subs) ":"))
                                 (b (string->symbol (car subs2)))
                                 (c (string->symbol (cadr subs2))))
                            (if (= (length ast) 1)
                                (impc:ti:first-transform (list 'cref a b c) inbody?)
                                (impc:ti:first-transform (list 'cset! a b (cadr ast) c) inbody?)))
                          (let* ((subs (regex:split (symbol->string (car ast)) "\\."))
                                 (a (string->symbol (car subs)))
                                 (b (string->symbol (cadr subs))))
                            (if (= (length ast) 1)
                                (impc:ti:first-transform (list 'cref a b) inbody?)
                                (impc:ti:first-transform (list 'cset! a b (cadr ast)) inbody?)))))
                     ((and (atom? (car ast))
                           (symbol? (car ast))
                           (not (eq? 'dotimes (car ast)))
                           (defined? (car ast))
                           (macro? (eval (car ast))))
                      (impc:ti:first-transform (macro-expand ast) 'inbody?))
                     (else
                      (cons ;(impc:ti:first-transform (car ast) inbody?)
                       (impc:ti:first-transform (car ast) #t)
                                        ;(impc:ti:first-transform (cdr ast) inbody?)))))
                       (impc:ti:first-transform (cdr ast) #t)))))
              (else
               ;; (println 'atom: ast)
               (cond ((rational? ast) `(Rat ,(rational->n ast) ,(rational->d ast)))
                     ((eq? ast #f) '(impc_false))
                     ((eq? ast #t) '(impc_true))
                     ((eq? ast '&) 'bitwise-and)
                     ((eq? ast 'bor) 'bitwise-or) ; can't use a pipe
                     ((eq? ast '^) 'bitwise-eor)
                     ((eq? ast '<<) 'bitwise-shift-left)
                     ((eq? ast '>>) 'bitwise-shift-right)
                     ((eq? ast '~) 'bitwise-not)
                     ((eq? ast 'else) '(impc_true))
                     ((eq? ast 'printf) 'llvm_printf)
                     ((eq? ast 'fprintf) 'llvm_fprintf)
                     ((eq? ast 'sprintf) 'llvm_sprintf)
                     ((eq? ast 'sscanf) 'llvm_sscanf)
                     ((eq? ast 'fscanf) 'llvm_fscanf)
                     ((eq? ast 'null) '(impc_null))
                     ((eq? ast 'now) 'llvm_now)
                     ((eq? ast 'pset!) 'pointer-set!)
                     ((eq? ast 'pref) 'pointer-ref)
                     ((eq? ast 'pref-ptr) 'pointer-ref-ptr)
                     ((eq? ast 'vset!) 'vector-set!)
                     ((eq? ast 'vref) 'vector-ref)
                     ((eq? ast 'vshuffle) 'vector-shuffle)
                     ((eq? ast 'aset!) 'array-set!)
                     ((eq? ast 'aref) 'array-ref)
                     ((eq? ast 'aref-ptr) 'array-ref-ptr)
                     ((eq? ast 'tset!) 'tuple-set!)
                     ((eq? ast 'tref) 'tuple-ref)
                     ((eq? ast 'tref-ptr) 'tuple-ref-ptr)
                     ((eq? ast 'salloc) 'stack-alloc)
                     ((eq? ast 'halloc) 'heap-alloc)
                     ((eq? ast 'zalloc) 'zone-alloc)
                     ((eq? ast 'alloc) 'zone-alloc)
                     ;; ((eq? ast 'schedule) 'callback)
                     ((eq? ast 'randomf) 'imp_randf)
                     ((eq? ast 'void) '(void))
                     ((and (symbol? ast)
                           (regex:match? (symbol->string ast) "^[+-]?[0-9]*\\.?[0-9]*[+-][0-9]*\\.?[0-9]*i$"))
                      (let ((p (regex:matched (symbol->string ast) "^([+-]?[0-9]*\\.?[0-9]*)([+-][0-9]*\\.?[0-9]*)i$")))
                        `(Cpxd ,(* 1.0 (string->number (cadr p))) ,(* 1.0 (string->number (caddr p))))))
                     ((and (symbol? ast)
                           (regex:match? (symbol->string ast) ":\\$(\\[|<)"))
                      (let ((t (impc:ti:expand-generic-type ast)))
                        (if (impc:ti:closure-exists? (symbol->string t))
                            t
                            (let ((p (regex:type-split (symbol->string t) "_poly_")))
                              (_specialize-generic (car p) (cname-decode (cadr p)))
                              t))))
                     ((and (symbol? ast)
                           (regex:match? (symbol->string ast) ":(f)|(i)|(float)|(double)|(i1)|(i8)|(i64)|(i32)|(i64)"))
                      (let ((p (regex:type-split (symbol->string ast) ":")))
                        (if (not (number? (string->atom (car p))))
                            ast
                            ;; otherwise do a convert
                            (if (string=? (cadr p) "f")
                                (list 'bitconvert (string->atom (car p)) 'float)
                                (if (string=? (cadr p) "i")
                                    (list 'bitconvert (string->atom (car p)) 'i32)
                                    (list 'bitconvert (string->atom (car p)) (string->symbol (cadr p))))))))
                     (else ast)))))))


;;
;; TYPE INFERENCE CODE
;;
;; request? can be a type - or a symbol if it's a symbol it must be a free variable available in vars
;;
;;

;; is 't' a complex type?
(define impc:ti:complex-type?
  (lambda (t)
    (if (and (atom? t)
             (not (string? t)))
        #f
        (if (string? t) #t
            (if (and (number? (car t))           ;; if list starts with a number (i.e. not a symbol)
                     (<> (car t) *impc:ir:void*) ;; if not void
                     ;; if proper complex type (tuple,array,closure)
                     (member (modulo (car t) *impc:ir:pointer*)
                             (list *impc:ir:tuple* *impc:ir:array* *impc:ir:vector* *impc:ir:closure*)))
                #t
                #f)))))



;; newname mappings is an assoc list
;; containing xlist*##105 -> "xlist--3823948324392" mappings
;; it is reset by llvm:ti:run
(define *impc:ti:generic-type-mappings* '())


(define regex:replace-all
  (lambda (str replace with)
    (if (regex:match? str replace)
        (regex:replace-all (regex:replace str replace with) replace with)
        str)))


;; takes a gpolytype (i.e. <!head,xlist*> )
;; and tries to expand on all !bang types ...
;; in other words try to change
;; this <!head,xlist*> into <i64,xlist*>
;; return #f or an expanded
(define impc:ti:reify-generic-type-expand
  (lambda (type gnum spec vars)
    ;; (println 'reifyin: type 'gnum: gnum 'spec: spec 'vars: vars)
    (for-each (lambda (v)
                ;; (println 'v: v)
                (if (and (regex:match? (symbol->string (car v)) "!")
                                        ;(if (not spec) #t
                                        ;    (regex:match? (symbol->string (car v)) (string-append "%" spec)))
                         (if (not gnum) #t
                             (regex:match? (symbol->string (car v)) (string-append "##" gnum)))
                         (regex:match? type (car (regex:split (symbol->string (car v)) "(##)|(%)")))
                         (not (null? (cdr v))))
                    (let* ((t (impc:ti:type-normalize (impc:ti:type-unify (cdr v) vars)))
                           ;; (llllll (println 't: t))
                           (tl (if (impc:ir:type? t)
                                   (impc:ir:pretty-print-type t)
                                   '())))
                      ;; (println 'v: v 't: t 'tl: tl)
                      (if (not (null? tl))
                          (let* ((xx (car (regex:type-split (symbol->string (car v)) "##")))
                                 (base (impc:ir:get-base-type xx))
                                 (xxx (string-append base "[*]*")))
                            (set! type (regex:replace-all type xxx tl)))))
                    #f))
              vars)
    ;; (println 'reifyout: type 'gnum: gnum)
    type))



;; this will basically try to turn xlist*##664 into "%xlist--adoOmdroIRU*"
;;
;; 1. try to reify the generic type (vs) using (vars)
;; 2. check against specifications of the polytype that may already exist
;; 3. if 2. exists then return the typename of the specification of the generic type
;; 4. if 2. does not exist then create specific type, add it to type polys and return it
;; 5. if type cannot be unified throw compiler error.
(define impc:ti:reify-generic-type
  (lambda (vs vars all-vs)
    ;; (println 'reify-generic-type: vs) ;; (symbol? vs))
    ;; (println 'vars: vars)
    ;; (println 'all-vs: all-vs)
    ;; (println 'gtype: vs 'vars: vars 'allvs: all-vs)
    (if (and (symbol? vs)
             (regex:match? (symbol->string vs) "##")
             (not (regex:match? (symbol->string vs) "^!")))
        (let* ((rsplit1 (regex:split (symbol->string vs) "##")) ;\\$\\$\\$"))
               (gnum (if (> (length rsplit1) 1) (cadr rsplit1) #f))
               (rsplit2 (regex:type-split (car rsplit1) ":")) ;; (regex:split (car rsplit1) "(%)|(\\*)"))
               (gpolyname (car rsplit2))
               (gtype-explicit (if (null? (cdr rsplit2)) '()
                                   (impc:ir:get-base-type (cadr rsplit2))))
               ;; (llllll (println 'gpolyname: gpolyname 'gtype: gtype-explicit))
               (spec (if (> (length rsplit2) 1) (cadr rsplit2) #f))
               (ptrdepth (impc:ir:get-ptr-depth (car rsplit1)))
               (elements '())
               (validelements? #f)
               (t1 (symbol->string (impc:ir:gpolytype-types (string->symbol (impc:ir:get-base-type gpolyname)))))
               (gtype t1))
          ;; (println 'reifyts gtype 'vs gtype-explicit)
          (if (and (not (null? gtype-explicit))
                   (regex:match? gtype-explicit "!"))
              (set! t1 gtype-explicit))
          ;; go through and check that there are NO non-explicit gpoly's at top level of type
          ;; (println '%%%%%%%%%%%%%%%%%%%%%%%% gnum)
          ;; (println '->A: t1 'explict: gtype-explicit 'ptrdepth: ptrdepth 'gpoly: gpolyname 'gnum: gnum)
          ;; (println '->VARS: vars 'all-vs all-vs)
          ;; attempt to expand any <!head,xlist*> into <i64,xlist*>
          (set! t1 (impc:ti:reify-generic-type-expand t1 gnum spec vars))
          ;; (println '->B: t1 'ptrdepth: ptrdepth 'gpoly: gpolyname)
          (let* ((s1 (regex:replace t1 "\\<(.*)\\>?.*" "$1"))
                 (es2 (impc:ir:get-type-joiner
                       (cl:remove-if (lambda (x) (string=? x ""))
                                     ;;  (regex:match? x gpolyname)))
                                     (regex:match-all s1 impc:ir:regex-tc-or-a))))
                 (es (map (lambda (x) (if (string? (impc:ir:get-type-from-pretty-str x))
                                          (impc:ir:get-type-from-pretty-str x) x))
                          es2))
                 (tr (cl:remove-if (lambda (x)
                                     ;; (println 'x: x 'gpolyname: gpolyname)
                                     (if (and (not (regex:match? x "^(<|\\[)"))
                                              (regex:match? x ":"))
                                         (let ((p (regex:type-split x ":")))
                                           (or (regex:match? x gpolyname)
                                               (impc:ir:type? (impc:ir:get-type-from-pretty-str (cadr p)))))
                                         (if (regex:match? x "^!")
                                             #f
                                             (or (regex:match? x gpolyname)
                                                 (impc:ir:type? (impc:ir:get-type-from-pretty-str x))))))
                                   ;; (impc:ir:type? x)))))
                                   es)))
            (if (null? tr) (set! validelements? #t))
            (set! elements es))
          ;; (println '->C: t1 (impc:ti:type-normalize t1))
          ;; (println 'elements: elements 'tr: validelements? 't1: t1)
          (if validelements? ;;(impc:ir:type? (impc:ir:get-type-from-pretty-str (symbol->string t1))) ;;(regex:replace (symbol->string t1) (string-append gpolyname "([^-][^-])") "$1")))
              (let* ((base (impc:ir:get-base-type gpolyname)) ;(symbol->string vs)))
                     (newname (string-append base "_poly_" (cname-encode t1)))
                     (newtype1 t1) ;;(regex:replace t2 (string-append base "([^-][^-])") (string-append newname "$1")))
                     (newtype2 (cons 14 (map (lambda (x)
                                               (if (string? (impc:ir:get-type-from-pretty-str x))
                                                   (impc:ir:get-type-from-pretty-str x)
                                                   (if (regex:match? x gpolyname)
                                                       (apply string-append "%" newname (make-list (impc:ir:get-ptr-depth x) "*"))
                                                       (impc:ir:get-type-from-pretty-str x))))
                                             elements)))
                     (newtype3 (impc:ir:get-type-str newtype2)))
                ;; (println 'nt1 newtype1 'nt2 newtype2 'nt3 newtype3)
                ;; ok now we have a type we need to add it to llvm and
                ;; polytype
                ;;(println 'newtype! newname 'totype: newtype3)
                (if (not (impc:ti:namedtype-exists? newname))
                    (begin ;; if this is a new reification of a generic type then ...
                      (llvm:compile-ir (string-append "%" newname " = type " newtype3))
                      ;; we should probably also build dataconstructors for the new
                      ;; concrete type?? (at least for printing reasons)
                      ;; because build-type-dataconstructor needs to be called from
                      ;; the top level, we should call use callback to add to queue
                      (callback (now) 'build-type-dataconstructor (string->symbol newname) newtype1 #f)
                      'done))
                (let ((rettype (apply string-append "%" newname (make-list ptrdepth "*"))))
                  ;; (println 'oldvs: vs)
                  ;; (set! vs (string->symbol
                  ;;           (string-append base ":" gtype
                  ;;                          (apply string-append (make-list ptrdepth "*"))
                  ;;                          "##" gnum)))
                  ;; (println 'updatevar: vs 'with rettype)
                  (impc:ti:update-var vs vars '() rettype)
                  (impc:ir:add-polytype (string->symbol base)
                                        (string->symbol newname)
                                        (impc:ir:get-type-from-str newtype3))
                  rettype))
              vs))
        vs)))



;; trys to type unify vs against any other
;; choices available in all-vs
(define impc:ti:symbol-expand-reverse-check
  (lambda (vs vars all-vs)
    ;; (println 'vs vs 'all-vs all-vs 'vars vars)
    (impc:ti:type-unify all-vs vars)
    ;; (println 'vs: vs 'vars: vars)
    (if (not (null? (cdr (assoc-strcmp vs vars))))
        (cdr (assoc-strcmp vs vars))
        vs)))


;; takes types with symbols and expands them
;; using types associated with symbols in vars
;; if a particular var doesn't have a type yet
;; then we try to reverse expand
;; (i.e. look at other closure options that may include type values
;; and assign those values into vars)
(define impc:ti:symbol-expand
  (lambda (vs vars all-vs)
    ;; (println 'symbol-expand: vs 'allvs: all-vs) ; 'vars: vars)
    ;; (println 'vars: vars)
    ;; (println 'all-vs: all-vs)
    (if (atom? vs)
        (if (symbol? vs)
            (if (or (impc:ir:gpolytype-types (string->symbol (impc:ir:get-base-type (car (regex:split (car (regex:split (symbol->string vs) "##")) "%"))))) ;"\\$\\$\\$")) "%")))))
                    (if (and (regex:match? (symbol->string vs) ":")
                             (impc:ir:gpolytype-types
                              (string->symbol (car (regex:type-split (symbol->string vs) ":")))))
                        #t #f))
                (impc:ti:reify-generic-type vs vars all-vs)
                (if (not (assoc-strcmp vs vars)) ;; if not in vars
                    (if (regex:match? (symbol->string vs) "^![^#]*$") ;; then check to see if symbol is a !gvar
                        vs
                        ;; (impc:compiler:print-variable-not-marked-as-free-error vs))
                        vs)
                    ;; check to see a type has been defined
                    ;; otherwise return null
                    (let ((t (cdr (assoc-strcmp vs vars))))
                      ;; first check to see if the symbol vs has a value
                      (if (null? t) ;; if it doesn't we might need to reverse match!
                          (impc:ti:symbol-expand-reverse-check vs vars all-vs)
                          t))))
            (begin ;(println 'ccc: vs)
              vs))
        (cons (impc:ti:symbol-expand (car vs) vars all-vs)
              (impc:ti:symbol-expand (cdr vs) vars all-vs)))))


;; impc:ti:intersection* is cl:intersection for
;; an arbirary number of sets (i.e. args)
;; also handles *impc:ir:other* which we want
;; to match against anything.
(define impc:ti:intersection*
  (lambda args
    (let loop ((a args)
               (res '()))
      (if (null? a)
          res
          (loop (cdr a)
                (if (null? res)
                    (car a)
                    (if (null? (car a))
                        res
                        (cl:intersection (car a) res))))))))




(define impc:ti:complex-unify
  (lambda (sym types vars)
    ;; (println 1 'sym: sym 'types: types)

    (set! types (cl:remove-duplicates types))

    ;; (println 2 'sym: sym 'types: types)

    ;; this is here to catch any trailing complex types
    ;; i.e. ((211 2 106) (211 2 106) 211 2 106)
    ;; we turn them into
    ;; ((211 2 106) (211 2 106) (211 2 106))
    (set! types
          (let loop ((lst types))
            (if (null? lst) '()
                (if (or (list? (car lst))
                        (string? (car lst)))
                    (cons (car lst) (loop (cdr lst)))
                    (list lst)))))

    ;; (println 3 'sym: sym 'types: types)

    (set! types (impc:ti:type-unify types vars))

    ;; (println 4 'sym: sym 'types: types)

    types))


;; this goes through IN ORDER and returns either:
;; NULL if the lists don't match
;; or
(define impc:ti:unify-lists
  (lambda args
                                        ;(println 'unify: args 'norm: (impc:ti:type-normalize args))
    (if (null? args)
        args
        (let ((lgths (map (lambda (k) (length k)) args)))
          (if (not (null? (cl:remove (car lgths) lgths)))
              '()
              (let ((result
                     (apply map (lambda args
                                  (let ((l1 (cl:remove '() args)))
                                    (if (null? l1) l1
                                        (let ((l2 (cl:remove-duplicates l1)))
                                          (if (null? l2)
                                              l2
                                              ;;(car l2))))))
                                              (if (= 1 (length l2))
                                                  (car l2)
                                                  '()))))))
                            args)))
                                        ;(println 'result: result)
                (if (member '() result)
                    '()
                    result)))))))



;; this is here to normalize any recursive tuples
;; i.e. put them in their simplist "named" form
;; you can pass in a a complete list of types
;; at the end and have this normalize them
(define impc:ti:type-normalize
  (lambda (t)
    (cond ((atom? t) t)
          ((and (list? t)
                (not (null? t))
                (number? (car t))
                ;;(= *impc:ir:tuple* (modulo (car t) *impc:ir:pointer*)))
                (impc:ir:tuple? (car t)))
           ;; first check all sub tuples for possible normalization!
           (set! t (map (lambda (a) (impc:ti:type-normalize a)) t))
           (let ((named-types (cl:remove-if-not string? t)))
             (if (null? named-types)
                 t
                 (let ((res (map (lambda (k)
                                   ;; (println 'k: k)
                                   (let* ((split (regex:split k "%|(_poly_)"))
                                          (gen-type (if (impc:ir:gpolytype-types (cadr split))
                                                        (symbol->string (impc:ir:gpolytype-types (cadr split)))
                                                        ""))
                                          ;; (gen-type (symbol->string (impc:ir:gpolytype-types (cadr split))))
                                          (named-type (impc:ti:get-namedtype-type k))
                                          (domatch? (if (and (list? named-type)
                                                             (= (length named-type) (length t)))
                                                        #t #f))
                                          (match (if domatch?
                                                     (map (lambda (a b)
                                                            ;; (println 'aa a 'bb b)
                                                            (if (equal? a b) #t
                                                                (if (and (symbol? a)
                                                                         (regex:match? gen-type (symbol->string a)))
                                                                    #t
                                                                    #f)))
                                                          t ;; type coming in
                                                          named-type)
                                                     (list k))))
                                     (if (member #f match) #f k)))
                                 named-types)))
                   (set! res (cl:remove-if-not string? res))
                   (if (null? res)
                       (impc:ti:type-normalize (cdr t))
                       (if (car res)
                           (car res)
                           t))))))
          ((pair? t)
           (cons (impc:ti:type-normalize (car t))
                 (impc:ti:type-normalize (cdr t)))))))


;; this function is here to support type-unify
;; in the following way:
;;
;; when going through type-unify it is possible
;; for a situation to arrise where a unification
;; over something like this may occur:
;; (("%list--3834748* (112 !head##829 list*##829"))
;;
;; the result for the unification will be "%list-3834748*"
;; check-to-update-generic-vars is here to do a quick
;; check of the (112 !head##829 list*##829) to update
;; any possible vars (such as !head##829) which could get
;; useful information from the "%list--3834748*" before
;; they get thrown away.
(define impc:ti:check-to-update-generic-vars
  (lambda (atom lists vars)
    ;; (println 'checktoupdategenericvars: atom 'lists lists 'vars: vars)
    (let ((atom-type (if (string? atom)
                         (impc:ti:get-namedtype-type atom)
                         atom)))
      ;; (println 'atom: atom 'atom-type atom-type 'lists lists)
      (if (list? atom-type)
          (map (lambda (e)
                 ;; (println 'type-match: atom-type 'against e)
                 (if (and (list? e)
                          (= (length e) (length atom-type)))
                     (if (and (number? (car e))
                              (number? (car atom-type))
                              (= (car e) (car atom-type)))
                         (map (lambda (a b)
                                (if (and (symbol? a)
                                         (assoc-strcmp a vars))
                                    (begin
                                      (impc:ti:update-var a vars '() b))))
                              (cdr e)
                              (cdr atom-type)))))
               lists))
      #t)))


;;
;; IF TYPE CANNOT BE UNIFIED SUCCESSFULLY THEN WE SHOULD RETURN NULL '()
;; i.e. if we have ((114 0 0) (14 0 0)) don't return this -> return '()
;;
(define impc:ti:type-unify
  (lambda (t vars)
    ;; (println 't: t 'vars: vars)
    (cond ((atom? t)
           (if (and (symbol? t)
                    #t
                    (or (impc:ir:gpolytype-types
                         (string->symbol
                          (impc:ir:get-base-type
                           (car (regex:split (car (regex:split (symbol->string t) "##")) "%")))))
                        (if (and (regex:match? (symbol->string t) ":")
                                 (impc:ir:gpolytype-types
                                  (string->symbol (car (regex:type-split (symbol->string t) ":")))))
                            #t
                            #f)))
               (impc:ti:reify-generic-type t vars '())
               (if (and (symbol? t) (assoc-strcmp t vars))
                   (let ((r (impc:ti:type-unify (cdr (assoc-strcmp t vars)) vars)))
                     (if (null? r) t r)) ;; if r is NULL or false return t

                   t)))
          ((list? t)
           (cond ((impc:ti:complex-type? t)
                  (map (lambda (v) (impc:ti:type-unify v vars)) t))
                 ((= (length t) 1)
                  (impc:ti:type-unify (car t) vars))
                 (else
                  (let* ((ts (impc:ti:type-normalize
                              (map (lambda (v)
                                     (let ((vvv (impc:ti:type-unify v vars)))
                                       ;; (println 'vvv: vvv)
                                       (impc:ti:type-clean vvv)))
                                   t)))
                         (ts2 (cl:remove-duplicates ts))
                         (result ts2))
                    ;; (println 1 'unified: result)
                    ;; first check result to see if we have a valid named-type (i.e. "%string")
                    (if (and #f
                             (= (length result) 2) ;; find all occurences of ((112 0 1) "%string--38293482")
                             (cl:find-if string? result)
                             (cl:find-if (lambda (k) (not (string? k))) result))
                        (set! result (list (cl:find-if string? result))))

                    ;; (println 2 'unified: result)
                    ;; this is here for cases like
                    ;; (!head%a##287 0 1) ;; which should resolve to (0 1) if !head%a##287 has no type
                    (if (and (not (cl:find-if impc:ti:complex-type? result))
                             (not (cl:find-if string? result))
                             (cl:find-if symbol? result))
                        (set! result (cl:remove-if symbol? result)))

                    ;; (println 3 t 'unified: result)
                    ;; next check to see if we need to do some number crunching
                    ;; basically checking to solve things like
                    ;; ((0 1) 1) which should resolve to 1
                    ;; (0 (0 1) (0 1 2)) which should resolve to 0
                    ;; ((0 1) (0 1 2)) sould resolve to (0 1 2)
                    (if (and (cl:find-if list? result)
                             (not (cl:find-if impc:ti:complex-type? result)))
                        (let ((non-choices (cl:remove-duplicates (cl:remove-if list? result)))
                              (choices (cl:remove-duplicates (flatten (cl:remove-if atom? ts2)))))
                          ;; (println 'non-choices: non-choices)
                          (if (and (= (length non-choices) 1)
                                   (member (car non-choices) choices))
                              (set! result (car non-choices))
                              (set! result (cl:remove-duplicates (flatten result))))))

                    ;; (println 4 t 'unified: result)
                    ;; if there is a choice between resolved types and unresolved types
                    ;; then obviously we should choose resolved types!
                    (if (list? result)
                        (let ((resolved (cl:remove-duplicates
                                         (cl:remove-if-not (lambda (k)
                                                             (if (and (impc:ir:type? k)
                                                                      (impc:ti:complex-type? k))
                                                                 #t #f))
                                                           result))))
                          (if (not (null? resolved))
                              ;; (set! result (car resolved)))))
                              (set! result resolved))))

                    ;; (println 5 t 'unified: result)
                    ;; finally return type (and do generic update check)
                    (if (and (not (number? result))
                             (not (null? result))
                             (not (impc:ir:type? result))
                             (list? result)
                             (or (impc:ir:closure? (car result))
                                 (impc:ir:tuple? (car result))))
                        (begin
                          (impc:ti:check-to-update-generic-vars (car result) t vars)
                          (if (cl:find-if (lambda (k) (string? k)) result)
                              (cl:find-if (lambda (k) (string? k)) result)
                              (car result))) ;; result is a proper tuple or closure
                        (if (and (list? result)
                                 (not (null? result))
                                 (= (length result) 1))
                            (car result) ;; if result only has 1 element then return that
                            (if (or (impc:ir:type? result) ;; either result is a propert type
                                    (not (cl:find-if (lambda (k) (not (number? k))) result))) ;; or list of number '(0 1 2 3) for example
                                result ;; if list is either a propert type OR a list of numeric types (i.e. '(0 1 2))
                                '()))))))) ;; if we still have mixed choice of complex types then return NULL
          ((pair? t)
           (impc:ti:type-unify (cdr t) vars))
          (else (impc:compiler:print-bad-type-error t)))))


(define impc:ti:generic-type-details
  (lambda (a)
    (if (and (symbol? a)
             (regex:match? (symbol->string a) "##"))
        (let* ((gname (car (regex:split (symbol->string a) "##")))
               (gnum (string->number (cadr (regex:split (symbol->string a) "##"))))
               (_basename (impc:ir:get-base-type gname))
               (name_and_type (regex:type-split _basename ":"))
               (basename (car name_and_type))
               (gtype (if (null? (cdr name_and_type)) #f (cadr name_and_type)))
               (gchar (cdr (regex:split basename "%")))
               (gname2 (car (regex:split basename "%")))
               (gpt (impc:ir:gpolytype-types gname2)))
          (if gpt
              (list (string->symbol gname2) gnum (if (null? gchar) "" (car gchar)) (impc:ir:get-type-from-pretty-str (symbol->string gpt)) gtype)
              (list (string->symbol gname2) gnum (if (null? gchar) "" (car gchar)) '() gtype)))
        #f)))

;; try to find a type for a !bang from a reified type
;;
;; example use is in impc:ti:sym-unify
(define impc:ti:check-bang-against-reified
  (lambda (bang-sym reified-sym vars)
    (let ((r (assoc-strcmp reified-sym vars)))
      (if (null? r)
          #f
          (let* ((gtd (impc:ti:generic-type-details reified-sym))
                 (gtd2 (impc:ti:generic-type-details bang-sym))
                 (type (cdr r))
                 (gtype (cadddr gtd))
                 (pos (cl:position (car gtd2) gtype)))
            (if (and type pos (list? (car type)) (> (length (car type)) pos))
                (let ((val (list-ref (car type) pos)))
                  val)
                #f))))))


(define impc:ti:sym-unify
  (lambda (sym types vars)

    ;; if sym is a !bang symbol and has no type set
    ;; then we trawl through vars looking for reified
    ;; types which we might be able to match it against.
    (if (and (null? types)
             (regex:match? (symbol->string sym) "^!"))
        (let ((gtd (impc:ti:generic-type-details sym)))
          (map (lambda (k)
                 (if (and (not (null? (cdr k)))
                          (impc:ir:type? (cadr k)))
                     (let ((gtd2 (impc:ti:generic-type-details (car k))))
                       (if (and gtd2 (= (cadr gtd) (cadr gtd2)))
                           (let ((val (impc:ti:check-bang-against-reified sym (car k) vars)))
                             (if val
                                 (begin
                                   (impc:ti:update-var sym vars '() val))))))))
               vars)))

    ;; (if (not (cl:find-if list? types))
    ;; 	  (begin (set! types (cl:remove-duplicates types)) ;; first normalize and check for duplicates
    ;; 		 (if (= (length types) 1)
    ;; 		     (car types) ;; if only 1 element in list return as atom
    ;; 		     (impc:ti:complex-unify types types vars)))
    ;; 	  (impc:ti:complex-unify sym types vars))))

    (let ((result (impc:ti:complex-unify sym types vars)))
      ;; (println 'sym: sym 't: types 'result result 'vars: vars)
      (if (and (list? result)
               (= (length result) 1))
          (car result)
          (impc:ti:type-clean result)))))



;; unify is a little bit ugly
;; 1st it expands all symbols - during this process vars can be modified (force-var, update-var)
;; 2nd because var can change we check result against var to see if any change to var has improved things
;; 3rd because step 2 may have made changes for the better we should do a final symbol check
;; basically means going through the final result list to see if any symbols left in complex
;; types can be given types.
(define impc:ti:unify
  (lambda (vars)
    ;; (println 'unifyvars: vars)
    (let ((result (map (lambda (v)
                                        ;(println 'unify-v: v)
                         (let* ((sym (car v))
                                        ;(kkkkkk (println 'sym sym))
                                ;; expand any symbols and do reverse symbol checks
                                (types-expanded (map (lambda (t)
                                                       ;; first CLEAN the type (remove extraneous lists)
                                                       (set! t (impc:ti:type-clean t))
                                                       (if (or (symbol? t)
                                                               (list? t))
                                                           (let ((res (impc:ti:symbol-expand t vars (cdr v))))
                                                             (set! res (impc:ti:type-clean res))
                                                             res)
                                                           t))
                                                     (cdr v)))
                                ;; (kkkkkkkk (println 'unify-v-expanded: v 'expanded: types-expanded))
                                (types-unified (impc:ti:sym-unify sym types-expanded vars)))

                           ;; (println 'sym_____: v)
                           ;; (println 'expanded: types-expanded)
                           ;; (println 'unified_: types-unified)
                           ;; (println 'vars____: vars)

                           ;; (println 'types-unified: types-unified)
                           ;; (println 'un-expanded (cdr v))
                           ;; (println 'un-unified types-expanded)
                           ;; (println 'unified types-unified)
                           ;; (println 'vdone: v)
                           (cons sym types-unified)))
                       vars)))
      ;; a final comparison between vars and result
      ;; this is because things in VAR may well have changed
      ;;
      ;; anything in result that is NULL will hopefully
      ;; have a value in vars that we can use
      (let ((result2 (map (lambda (a b)
                            (if (null? (cdr a))
                                (if (not (null? (cdr b)))
                                    (if (= (length (cdr b)) 1)
                                        (cons (car a) (cadr b))
                                        (cons (car a) (cdr b)))
                                    a)
                                a))
                          result
                          vars)))
        ;; (println 'result: result)
        ;; (println 'vars: vars)
        ;; (println 'result2: result2)

        ;; and return result
        result2))))


;; unify is a little bit ugly
;; 1st it expands all symbols - during this process vars can be modified (force-var, update-var)
;; 2nd because var can change we check result against var to see if any change to var has improved things
;; 3rd because step 2 may have made changes for the better we should do a final symbol check
;; basically means going through the final result list to see if any symbols left in complex
;; types can be given types.
;; (define impc:ti:unify
;;    (lambda (vars)
;;       ;; (println 'unifyvars: vars)
;;       (let ((result (map (lambda (v)
;; 			   (println 'unify-v: v)
;; 			   (if (null? (cdr v))
;; 			       (if (regex:match? (symbol->string (car v)) "^!")

;; 			       (let* ((sym (car v))
;; 				      (types-expanded (map (lambda (t)
;; 							     ;; first CLEAN the type (remove extraneous lists)
;; 							     (set! t (impc:ti:type-clean t))
;; 							     (if (or (symbol? t)
;; 								     (list? t))
;; 								 (let ((res (impc:ti:symbol-expand t vars (cdr v))))
;; 								   (set! res (impc:ti:type-clean res))
;; 								   res)
;; 								 t))
;; 							   (cdr v)))
;; 				      ;; (kkkkkkkk (println 'unify-v-expanded: v 'expanded: types-expanded))
;; 				      (types-unified (impc:ti:sym-unify sym types-expanded vars)))
;; 				 (cons sym types-unified))))
;; 			 vars)))
;; 	;; a final comparison between vars and result
;; 	;; this is because things in VAR may well have changed
;; 	;;
;; 	;; anything in result that is NULL will hopefully
;; 	;; have a value in vars that we can use
;; 	(let ((result2 (map (lambda (a b)
;; 			      (if (null? (cdr a))
;; 				  (if (not (null? (cdr b)))
;; 				      (cons (car a) (cdr b))
;; 				      a)
;; 				  a))
;; 			    result
;; 			    vars)))
;; 	  ;; and return result
;; 	  result2))))


;; checks to see if a type system is completely unified
(define impc:ti:unity?
  (lambda (vars)
    (map (lambda (x)
           (if (impc:ir:type? (cdr x)) #t #f))
         vars)))


;; join elements into a list (without including nulls)
(define impc:ti:join
  (lambda args
    (cl:remove-if null? args)))


;; this function removes any uneccessary lists
;; it just checks for lists of 1 element and
;; extracts the atom from the list
;;
;; i.e. (211 (2) (211 3 3) (xlist*##123)) should be
;; (211 2 (211 3 3) xlist*##123)

;; (define impc:ti:type-clean
;;   (lambda (type)
;;     (if (or (null? type)
;; 	    (not (list? type)))
;; 	type
;; 	(if (and (list? type)
;; 		 (list? (car type)))
;; 	    (list (impc:ti:type-clean (car type)))
;; 	    (map (lambda (k)
;; 		   (if (list? k)
;; 		       (if (= (length k) 1)
;; 			   (car k)
;; 			   k)
;; 		       k))
;; 		 type)))))

;; this function removes any uneccessary lists
;; it just checks for lists of 1 element and
;; extracts the atom from the list
;;
;; i.e. (211 (2) (211 3 3) (xlist*##123)) should be
;; (211 2 (211 3 3) xlist*##123)
;; (define impc:ti:type-clean
;;   (lambda (type)
;;     (if (or (null? type)
;;             (atom? type)
;;             (impc:ir:type? type)) ;; (note to andrew) remove this line for GC crash!
;; 	type
;;         (map (lambda (k)
;;                (if (list? k)
;;                    (if (= (length k) 1)
;;                        (car k)
;;                        k)
;;                    k))
;;              type))))

(define impc:ti:type-clean
  (lambda (type)
    (if (or (null? type)
            (atom? type)
            (impc:ir:type? type)) ;; (note to andrew) remove this line for GC crash!
        type
        (map (lambda (k)
               (if (list? k)
                   (if (= (length k) 1)
                       (impc:ti:type-clean (car k))
                       (impc:ti:type-clean k))
                   k))
             type))))

;; this is here for whenever we get
;; new 'argument' information about
;; a locally bound lambda which might help
;; us to derive new return type information
(define impc:ti:type-check-bound-lambda
  (lambda (sym vars kts t)
    (if (not (assoc-strcmp sym *impc:ti:bound-lambdas*))
        #f
        (let* ((f (cadr (assoc-strcmp sym *impc:ti:bound-lambdas*)))
               (args (cadr f))
               (body (caddr f))
               (estr (sexpr->string body))
               (recursive? (regex:match? estr (string-append "(" "\\(\\s*" (symbol->string sym) "\\s" ")|(\\(\\s*callback)")))
               (rettype '()))
          (if (not recursive?)
              (begin
                (if (not (null? t))
                    (for-each (lambda (x y)
                                ;; (println 'lambda 'x: x 'y: y)
                                (impc:ti:update-var x vars kts y))
                              args (cddr t)))
                (set! rettype (impc:ti:type-check (caddr (cadr (assoc-strcmp sym *impc:ti:bound-lambdas*)))
                                                  vars kts #f))
                (if (null? t)
                    (let ((argtypes (map (lambda (x)
                                           (cadr (assoc-strcmp x vars)))
                                         args)))
                      ;; (println 'update: sym 'with (cons 213 (cons (car rettype) argtypes)))
                      (impc:ti:update-var sym vars kts (cons 213 (cons(car rettype) argtypes)))))
                (if (impc:ir:type? rettype)
                    rettype
                    #f)))))))

;; don't allow update to add to kts values
(define impc:ti:update-var
  (lambda (sym vars kts t)
    ;; clean type
    ;; i.e. change (211 4 (0) (1) 0)) -> (211 4 0 1 0)
    ;;
    (if (and (list? t)
             (= (length t) 1)
             (or (string? (car t))
                 (impc:ir:type? (car t))))
        (set! t (car t)))
    (set! t (impc:ti:type-clean t))
    ;; (println 'b1: t)
    (set! t (impc:ti:type-normalize t vars))
    ;; (println 'b2: t)
    (if (and (string? t)
             #t
             (assoc-strcmp sym vars))
        (let* ((p (assoc-strcmp sym vars))
               (l (map (lambda (k) (string? k)) (cdr p))))
          (if (and (member #t l)
                   (not (member t (cdr p))))
              (begin
                (if (regex:match? t "^%")
                    (impc:compiler:print-type-mismatch-error (impc:ir:pretty-print-type (impc:ir:get-named-type t)) p)
                    (impc:compiler:print-type-mismatch-error t p))))))
    ;; don't ever add oursevles (i.e. sym) as a type arg or NULL
    (if (or (null? t)
            (equal? t #f)
            (and (list? t)
                 (equal? sym (car t)))
            (equal? sym t))
        'exit
        (begin ;; (println 'update-var:> sym 'in: vars 'with: t 'kts: kts)
          (if (member sym kts) ;; if in known types don't do anything
              '()
              (if (and (not (assoc-strcmp sym vars))
                       (not (regex:match? (symbol->string sym) ":\\["))
                       (not (impc:ti:closure-exists? (symbol->string sym)))
                       (not (impc:ti:globalvar-exists? (symbol->string sym))))
                  (begin ;; (error)
                    (impc:compiler:print-missing-type-error sym))
                  (let ((pair (assoc-strcmp sym vars)))
                    (if pair
                        (let ((pair-rest (cdr pair)))
                          (if (or (impc:ir:type? t)
                                  (impc:ti:complex-type? t))
                              (begin
                                ;; if 't' is a closure without a return type
                                ;; but has new argument types then we might be able
                                ;; to infer the return type from the arg types
                                (if (and (impc:ir:closure? t)
                                         (not (impc:ir:type? t)))
                                    (begin
                                      (let ((res (impc:ti:type-check-bound-lambda sym vars kts t)))
                                        (if res
                                            (set-car! (cdr t) res)))))
                                ;; uncomment the following lines to do reverse bang tests
                                (if (and (string? t) ;; if a named type
                                         (regex:match? (symbol->string sym) "##"))
                                    (let ((gtd (impc:ti:generic-type-details sym)))
                                      (impc:ti:reverse-set-bangs-from-reified sym t (cadr gtd) vars)))
                                (if (and
                                     #f
                                     (string? t)
                                     (impc:ir:tuple? pair-rest))
                                    (set-cdr! pair (list t))
                                    (set-cdr! pair (cl:remove-duplicates (append (list t) pair-rest))))
                                )
                              (set-cdr! pair (cl:remove-duplicates (append t pair-rest))))))
                    '())))))))


;; force a var to a particular type
;; (i.e. wipe out other choices)
;;
;; do allow force-var to overwrite kts values
(define impc:ti:force-var
  (lambda (sym vars kts t)

    (if (and (list? t)
             (= (length t) 1)
             (string? (car t)))
        (set! t (car t)))

    (set! t (impc:ti:type-clean t))
    ;; (println 't1: t)
    (set! t (impc:ti:type-normalize t vars))
    ;; (println 't2: t)

                                        ;(if (equal? sym 'length) (begin (println '-> 'forcing 'length t))) ; (error)))
                                        ;(if (equal? sym 'l) (println '-> 'forcing 'l t))
                                        ;(println 'force-var:> sym 'in: vars 'with: t 'kts: kts)
    (if (and (not (assoc-strcmp sym vars))
             (not (impc:ti:closure-exists? (symbol->string sym)))
             (not (impc:ti:globalvar-exists? (symbol->string sym))))
        (impc:compiler:print-missing-identifier-error sym 'variable)
        (let ((pair (assoc-strcmp sym vars)))
          (if pair
              (if (impc:ir:type? t)
                  (begin
                    ;; uncomment the following lines to do reverse bang tests
                    (if (and (string? t) ;; if a named type
                             (regex:match? (symbol->string sym) "##"))
                        (let ((gtd (impc:ti:generic-type-details sym)))
                          (impc:ti:reverse-set-bangs-from-reified sym t (cadr gtd) vars)))
                    (set-cdr! pair (list t)))
                  (set-cdr! pair t))
              '())))))


(define impc:ti:get-var
  (lambda (sym vars)
    (if (not (assoc-strcmp sym vars))
        (if (impc:ti:globalvar-exists? (symbol->string sym))
            (cons sym (impc:ir:pointer-- (impc:ti:get-globalvar-type (symbol->string sym))))
            (impc:compiler:print-missing-identifier-error sym 'variable))
        (assoc-strcmp sym vars))))


;; clear all vars
(define impc:ti:clear-all-vars
  (lambda (vars)
    (map (lambda (x)
           (set-cdr! x '()))
         vars)))



;; resolve "string" types by looking up get-named-type
;; resolve 'symbol types by looking in vars
;; otherwise just return t
(define impc:ti:try-to-resolve-named-types
  (lambda (t vars)
    ;; check for named types
    (if (string? t)
        (let ((t (impc:ti:get-namedtype-type t))
              (ptr-level (impc:ir:get-ptr-depth t)))
          (dotimes (i ptr-level) (set! t (impc:ir:pointer++ t)))
          (list t))
        (if (symbol? t)
            (if (null? (assoc-strcmp t vars))
                '()
                (cdr (assoc-strcmp t vars)))
            t))))



(define impc:ti:numeric-check
  (lambda (ast vars kts request?)
    ;; (println 'ast: ast 'request? request?)
    (if *impc:ti:print-sub-checks* (println 'num:> 'ast: ast 'request? request?))
    (if (and request?
             (not (null? request?)))
        (cond ((symbol? request?)
               (let* ((t1 (impc:ti:symbol-check request? vars kts #f))
                      (t2 (impc:ti:numeric-check ast vars kts #f))
                      (t3 (cl:intersection t1 t2)))
                 (if (null? t1) t2 t3)))
              ((list? request?)
               (let* ((t1 (impc:ti:numeric-check ast vars kts #f))
                      (t2 (cl:intersection request? t1)))
                 t2))
              ((number? request?)
               (let* ((t1 (impc:ti:numeric-check ast vars kts #f))
                      (t2 (cl:intersection (list request?) t1)))
                 t2))
              ((string? request?)
               (let* ((t1 (impc:ti:numeric-check ast vars kts #f))
                      (t2 (cl:intersection (list request?) t1)))
                 t2))
              (else
               (print-with-colors 'red 'default #t (print "Compiler Error:"))
               (print "shouldn't reach here in numeric check - request?: ")
               (print-with-colors 'blue 'default #f (print request?))
               (print "\nYou might be using a ")
               (print-with-colors 'blue 'default #t (print "pref"))
               (print " where you should be using a ")
               (print-with-colors 'blue 'default #t (print "tref"))
               (println)
               (throw "")))
        (if (integer? ast)  ;; preference goes to start of list
            (if (or (= 1 ast) (= 0 ast))
                (list *impc:ir:si64* *impc:ir:si32* *impc:ir:si16* *impc:ir:ui8* *impc:ir:i1*)
                (if (< ast 256)
                    (list *impc:ir:si64* *impc:ir:si32* *impc:ir:si16* *impc:ir:ui8*)
                    (list *impc:ir:si64* *impc:ir:si32* *impc:ir:si16*)))  ;*impc:ir:fp64* *impc:ir:fp32*))
            (list *impc:ir:fp64* *impc:ir:fp32*)))))


;; IS NEW
(define impc:ti:symbol-check
  (lambda (ast vars kts request?)
    ;; (println 'symcheck 'ast: ast 'vars: vars)
    ;; (println 'vars: vars)
    (if (not (symbol? ast))
        (impc:compiler:print-compiler-error "Trying to symbol check a non-symbol" ast))
    (if (and
         (assoc-strcmp ast vars)
         (impc:ir:type? (impc:ti:type-unify (cdr (assoc-strcmp ast vars)) vars)))
        (begin ;; (println '.................really-saving-time!)
          (list (impc:ti:type-unify (cdr (assoc-strcmp ast vars)) vars)))
        (begin
          ;; (if (regex:match? (symbol->string ast) "!")
          ;;     (print-error 'Compiler 'Error: 'bad 'symbol 'name: ast 'no (symbol->string '!) 'allowed))

          ;; (println 'symbolcheck 'ast: ast 'vars: vars 'request: request?)
          ;; if we get a generic function here it means that someone
          ;; is trying to pass it as a value (which is illegal!)
          (if (and (symbol? ast)
                   (impc:ir:gpoly-exists? (string->symbol (impc:ir:get-base-type (symbol->string ast)))))
              ;; (regex:match? (symbol->string ast) "##")
              ;; (not (regex:match? (symbol->string ast) "!")))
              (begin
                (impc:compiler:print-compiler-error "trying to use generic function as value" ast)))
          (if *impc:ti:print-sub-checks* (println 'sym:> 'ast: ast 'request? request?))
          ;; if a request is made - assume it's forced
          ;; find the intersection between the request
          ;; and the current values and force that intersection
          (let ((polytype #f))
            (if (and (not (assoc-strcmp ast vars))
                     (not (impc:ti:closure-exists? (symbol->string ast)))
                     (not (impc:ti:globalvar-exists? (symbol->string ast))))
                (if (and (regex:match? (symbol->string ast) ":")
                         (impc:ir:gpoly-exists?
                          (string->symbol (car (regex:type-split (symbol->string ast) ":")))))
                    (let* ((p (regex:type-split (symbol->string ast) ":"))
                           (etype (cname-encode (cadr p))))
                      ;; (println 'ast: ast 'etype: etype)
                      (begin
                        (set! request? #f)
                        (set! ast (string->symbol (string-append (car p) "_poly_" etype)))
                        (set! polytype (impc:ir:get-type-from-pretty-str (cadr p)))))
                    (begin (impc:compiler:print-missing-identifier-error ast 'symbol))))
            (let ((type (if polytype polytype
                            (if (assoc-strcmp ast vars)
                                (cdr (assoc-strcmp ast vars))
                                (if (impc:ti:closure-exists? (symbol->string ast))
                                    (list (cons (+ *impc:ir:closure* *impc:ir:pointer* *impc:ir:pointer*) (map impc:ir:get-type-from-str (impc:ti:get-closure-arg-types (symbol->string ast)))))
                                    (list (impc:ir:pointer-- (impc:ti:get-globalvar-type (symbol->string ast)))))))))
              ;; (println '---------- (member ast kts) 'type: type (impc:ir:type? type))
              (if (and request?
                       (not (member ast kts)) ;; if we're in KTS then we should ignore requests!
                       (not (null? request?)))
                  (if (null? type)
                      (begin
                        (impc:ti:update-var ast vars kts (list request?))
                        request?)
                      (let ((intersection (impc:ti:type-unify (list request? type) vars)))
                        ;; (println 'intersection intersection 'request? request? 'type: type)
                        (if (not (null? intersection))
                            (begin
                              ;; andrew change
                              (impc:ti:force-var ast vars kts (list intersection))
                              ;;(impc:ti:update-var ast vars kts (list intersection))
                              (list intersection))
                            type)))
                  type)))))))



(define impc:ti:math-check
  (lambda (ast vars kts request?)
    ;; if request is false
    (if (not request?)
        (begin (if (member (cadr ast) kts) (set! request? (cdr (assoc-strcmp (cadr ast) vars))))
               (if (member (caddr ast) kts) (set! request? (cdr (assoc-strcmp (caddr ast) vars))))))
    ;; cleanup request!
    (if (and (list? request?)
             (= 1 (length request?)))
        (set! request? (car request?)))
    ;; now start type checking
    (let* ((n1 (cadr ast))
           (n2 (caddr ast))
           (a (impc:ti:type-unify (impc:ti:type-check n1 vars kts request?) vars))
           (b (impc:ti:type-unify (impc:ti:type-check n2 vars kts request?) vars))
           (t (impc:ti:type-unify (list a b) vars)))
      ;; if we can fully unify on 't'
      ;; then we might need to retypecheck a or b
      (if (impc:ir:type? t)
          (begin
            (if (and (list? a)
                     (list? n1)
                     (assoc-strcmp (car n1) vars))
                (begin (impc:ti:force-var (car n1) vars kts '())
                       (impc:ti:type-check n1 vars kts t)))
            (if (and (list? b)
                     (list? n2)
                     (assoc-strcmp (car n2) vars))
                (begin (impc:ti:force-var (car n2) vars kts '())
                       (impc:ti:type-check n2 vars kts t)))))
      ;;(println 'math: a b 't: t 'request? request? 'ast: ast 'vars: vars)
      (if (and (not (equal? a b))
               (impc:ir:type? b)
               (impc:ir:type? a)
               (not (or (impc:ir:tuple? a)
                        (impc:ir:tuple? b)))
               (not (and (impc:ir:vector? a)   ;; we are allowed to multiply
                         (impc:ir:vector? b)))) ;; a Vector by a Vector*
          (impc:compiler:print-type-conflict-error (impc:ir:pretty-print-type a)
                                                   (impc:ir:pretty-print-type b)
                                                   ast))
      (if (and (impc:ir:type? t)
               (impc:ir:pointer? t)
               (not (impc:ir:vector? t)))
          (impc:compiler:print-type-mismatch-error (impc:ir:pretty-print-type t) "number" (symbol->string (car ast))))
      (if *impc:ti:print-sub-checks* (println 'math:> 'ast: ast 'a: a 'b: b 't: t 'request? request?))
      (if (not (null? t))
          (begin (if (and (symbol? (cadr ast)) (not (impc:ir:tuple? t))) (impc:ti:force-var (cadr ast) vars kts t))
                 (if (and (symbol? (caddr ast)) (not (impc:ir:tuple? t))) (impc:ti:force-var (caddr ast) vars kts t))
                 (if (and (not (null? t)) ;; this here because math functions always return non-pointer vectors
                          (impc:ir:vector? t) ;; we want to do this because these vectors are always stack allocated
                          (impc:ir:pointer? t)) ;; also these vectors are immutable (i.e. cannot use vector-set!)
                     (impc:ir:pointer-- t)
                     t))
          (cond ((impc:ir:vector? a)
                 (if (symbol? (cadr ast)) (impc:ti:update-var (cadr ast) vars kts a))
                 (if (impc:ir:pointer? a) (impc:ir:pointer-- a) a))
                ((impc:ir:vector? b)
                 (if (symbol? (caddr ast)) (impc:ti:update-var (cadr ast) vars kts b))
                 (if (impc:ir:pointer? b) (impc:ir:pointer-- b) b))
                ((not (cl:find-if symbol? (cdr ast))) t) ;; return t
                ((and (symbol? (cadr ast))
                      (symbol? (caddr ast))
                      (not (null? (cdr (impc:ti:get-var (cadr ast) vars))))
                      (not (null? (cdr (impc:ti:get-var (caddr ast) vars)))))
                 ;; if both are symbols and their types cannot unify on anything
                 ;; then we have a problem!  So force both types to NULL
                 (impc:ti:force-var (cadr ast) vars kts '())
                 (impc:ti:force-var (caddr ast) vars kts '())
                 t) ;; and return t (which should be NULL)
                ((and (symbol? (cadr ast)) (not (null? b)))
                 (impc:ti:update-var (cadr ast) vars kts b) b) ;; return b
                ((and (symbol? (caddr ast)) (not (null? a)))
                 (impc:ti:update-var (caddr ast) vars kts a) a) ;; return a
                (else t))))))

(define impc:ti:math-intrinsic-check
  (lambda (ast vars kts request?)
    (let* ((args (- (length ast) 1))
           (a (impc:ti:type-unify (impc:ti:type-check (cadr ast) vars kts request?) vars))
           (b (if (> args 1)
                  (impc:ti:type-unify (impc:ti:type-check (caddr ast) vars kts request?) vars)
                  #f))
           (c (if (> args 2)
                  (impc:ti:type-unify (impc:ti:type-check (cadddr ast) vars kts request?) vars)
                  #f)))
      (if (and b
               (not (equal? a b))
               (not (number? (cadr ast)))
               (not (number? (caddr ast))))
          (impc:compiler:print-type-conflict-error (impc:ir:pretty-print-type a)
                                                   (impc:ir:pretty-print-type b)
                                                   ast)
          (if (and b
                   (not (equal? a b))
                   (number? (cadr ast)))
              (list b)
              (list a))))))

(define impc:ti:compare-check
  (lambda (ast vars kts request?)
    (let* ((n1 (if (number? (cadr ast)) (caddr ast) (cadr ast)))
           (n2 (if (number? (cadr ast)) (cadr ast) (caddr ast)))
           (a (impc:ti:type-unify (impc:ti:type-check n1 vars kts #f) vars)) ;; removed request?
           (b (impc:ti:type-unify (impc:ti:type-check n2 vars kts #f) vars)) ;; removed request?
           (t (impc:ti:type-unify (list a b) vars)))
      ;; if we can unify on 't'
      ;; then we might need to retypecheck a or b
      (if (impc:ir:type? t)
          (begin
            (if (and (list? a)
                     (list? n1)
                     (assoc-strcmp (car n1) vars))
                (begin (impc:ti:force-var (car n1) vars kts '())
                       (impc:ti:type-check n1 vars kts t)))
            (if (and (list? b)
                     (list? n2)
                     (assoc-strcmp (car n2) vars))
                (begin (impc:ti:force-var (car n2) vars kts '())
                       (impc:ti:type-check n2 vars kts t)))))
      (if *impc:ti:print-sub-checks* (println 'compare:> 'ast: ast 'a: a 'b: b 't: t 'request? request?))
      (if (not (null? t))
          (begin (if (symbol? (cadr ast)) (impc:ti:force-var (cadr ast) vars kts t))
                 (if (symbol? (caddr ast)) (impc:ti:force-var (caddr ast) vars kts t))
                 (if (and (not (null? t))
                          (impc:ir:vector? t))
                     (if (impc:ir:pointer? t)
                         (list (- (car t) *impc:ir:pointer*) (cadr t) *impc:ir:i1*)
                         (list (car t) (cadr t) *impc:ir:i1*))
                     (if (and (impc:ir:tuple? t)
                              (not (impc:ir:pointer? t)))
                         t
                         (list *impc:ir:i1*))))
          (cond ((impc:ir:vector? a)
                 (if (symbol? (cadr ast)) (impc:ti:update-var (cadr ast) vars kts a))
                 (let ((retvec (if (impc:ir:pointer? a) (impc:ir:pointer-- a) a)))
                   (list (car retvec) (cadr retvec) *impc:ir:i1*)))
                ((impc:ir:vector? b)
                 (if (symbol? (caddr ast)) (impc:ti:update-var (cadr ast) vars kts b))
                 (let ((retvec (if (impc:ir:pointer? b) (impc:ir:pointer-- b) b)))
                   (list (car retvec) (cadr retvec) *impc:ir:i1*)))
                ((or (and (impc:ir:tuple? a) (not (impc:ir:pointer? a)))
                     (and (impc:ir:tuple? b) (not (impc:ir:pointer? b))))
                 (list (if (impc:ir:tuple? a) a b)))
                ((not (cl:find-if symbol? (cdr ast))) (list *impc:ir:i1*)) ;; return t
                ((and (symbol? n1)
                      (symbol? n2)
                      (not (null? (cdr (impc:ti:get-var n1 vars))))
                      (not (null? (cdr (impc:ti:get-var n2 vars)))))
                 ;; if both are symbols and their types cannot unify on anything
                 ;; then we have a problem!  So force both types to NULL
                 (impc:ti:force-var n1 vars kts '())
                 (impc:ti:force-var n2 vars kts '())
                 (list *impc:ir:i1*)) ;; and return t (which should be NULL)
                ((and (symbol? n1) (not (null? b)))
                 (impc:ti:update-var n1 vars kts b)
                 (list *impc:ir:i1*)) ;; return b
                ((and (symbol? n2) (not (null? a)))
                 (impc:ti:update-var n2 vars kts a)
                 (list *impc:ir:i1*)) ;; return a
                (else (list *impc:ir:i1*)))))))


;; with _native functions
(define impc:ti:nativef-check
  (lambda (ast vars kts request?)
    ;; (println 'type-checking: (car ast))
    ;; (println 'native-check 'ast: ast 'vars: vars 'request: request?)
    (let* ((name (symbol->string (car ast)))
           (ftype (map impc:ir:get-type-from-str
                       (impc:ti:get-nativefunc-arg-types name))))
      ;;(println 'ftype:> 'ast: ast 'type: ftype)
      (if *impc:ti:print-sub-checks* (println 'ftype:> 'ast: ast 'type: ftype))

      (if (<> (length ftype)
              (length ast))
          (impc:compiler:print-compiler-error "bad arity in call" ast))

      ;; we don't care what we get back because we already know the return type
      (for-each (lambda (a t)
                  ;; if a is a symbol then add type t to a
                  ;; we also know that for native functions there
                  ;; is no choice about the type so we should
                  ;; force it to the type not update it
                                        ;(if (symbol? a) (impc:ti:force-var a vars kts t))
                  (if (and t (symbol? a)) (impc:ti:update-var a vars kts t))
                  (impc:ti:type-check a vars kts t))
                (cdr ast)
                (cdr ftype))
      (list (car ftype)))))


;; this takes a type like
;; "%List--PFBhaXI6PGk2NCxpNjQ_KixMaXN0Kj4*"
;; which decodes to: "<Pair:<i64,i64>*,List*>"
;; and unwraps it into (114 (114 2 2) (114 !a List*))
;; it must be recursive because a naive unwrap gives
;; (114 "%Pair--..." "%List--...")
(define impc:ti:completely-unwrap-named-type
  (lambda (x)
    (if (and (string? x)
             (regex:match? x "^%")
             (regex:match? x "_poly_")
             (if (null? (impc:ir:get-named-type x))
                 (impc:compiler:print-missing-type-error x)
                 #t))
        (let* ((gpolyname (regex:replace-all x "^%(.*)_poly_.*$" "$1"))
               (ptrdepth (impc:ir:get-ptr-depth x))
               (gpoly (cons (+ *impc:ir:tuple* (* *impc:ir:pointer* ptrdepth))
                            (map (lambda (x)
                                   (string->symbol x))
                                 (impc:ir:get-pretty-tuple-arg-strings
                                  (symbol->string (impc:ir:gpolytype-types gpolyname)))))))
          (impc:ti:completely-unwrap-named-type
           (replace-all (impc:ir:get-type-from-str (impc:ir:get-named-type x)) (list (cons x gpoly)))))
        (if (list? x)
            (map (lambda (y)
                   (impc:ti:completely-unwrap-named-type y))
                 x)
            x))))

(define impc:ti:descending-generic-type-match
  (lambda (a b)
    (cond ((equal? a b) #t)
          ((atom? a)
           (if (and (symbol? a)
                    (regex:match? (symbol->string a) "^!"))
               #t
               #f))
          ((atom? b)
           (if (and (symbol? b)
                    (regex:match? (symbol->string b) "^!"))
               #t
               #f))
          (else
           (if (member #f
                       (map (lambda (x y)
                              (impc:ti:descending-generic-type-match x y))
                            a b))
               #f #t)))))


;; match two explicit generic types!
;; returns true for a match of false for a fail
(define impc:ti:generic-types-matchup?
  (lambda (aa bb vars)
    ;; (println 'trying 'to 'match 'generic 'type aa 'against 'generic 'type bb)
    (if (or (not (symbol? aa))
            (not (or (string? bb) (symbol? bb)))
            (not (regex:match? (symbol->string aa) ":")))
        #f
        (let* ((a (symbol->string aa))
               (b (if (symbol? bb) (symbol->string bb) bb))
               (p1a (regex:type-split a "##"))
               (p1b (regex:type-split b "##"))
               (p2a (regex:type-split (car p1a) ":"))
               (p2b (regex:type-split (car p1b) ":"))
               (t1a (if (not (null? (cdr p2a)))
                        (impc:ir:get-type-from-pretty-str (cadr p2a)) '()))
               (t1b (if (not (null? (cdr p2b)))
                        (impc:ir:get-type-from-pretty-str (cadr p2b)) '()))
               (au (if (and (assoc-strcmp aa vars)
                            (= (length (cdr (assoc-strcmp aa vars))) 1))
                       (car (cdr (assoc-strcmp aa vars)))))
               (bu (if (and (assoc-strcmp bb vars)
                            (= (length (cdr (assoc-strcmp bb vars))) 1))
                       (car (cdr (assoc-strcmp bb vars))))))
          (if (and (null? bu) (regex:match? (car p2b) "^%"))
              (set! bu (car p2b)))
          (if (string? au)
              (set! t1a (impc:ti:completely-unwrap-named-type au)))
          (if (string? bu)
              (set! t1b (impc:ti:completely-unwrap-named-type bu)))
          ;; (println 'which 'is 'to 'match:)
          ;; (println t1a)
          ;; (println 'against:)
          ;; (println t1b)
          ;; now try to match on t1a and t1b
          (let* ((res (impc:ti:descending-generic-type-match t1a t1b)))
            ;; this for printing only
            ;; (if (not res)
            ;;     (begin
            ;;       (println 'match-failed: t1a 'vs t1b)
            ;;       (println 'A: aa)
            ;;       (println 'B: bb)))
            res)))))


;; type inferencing for generic functions arguments
(define impc:ti:nativef-generics-check-args
  (lambda (ast gpoly-type vars kts request?)
    ;; (println 'generic-check-args 'ast: ast 'vars: vars)
    ;; (println '____ast: ast)
    ;; (println 'generic-type: gpoly-type)

    ;; type inferencing for generic functions arguments
    (map (lambda (a gt)
           ;; (println 'arg-in: a 'gt: gt)
           ;; gt for generics type
           (let ((tt (impc:ti:type-check a vars kts gt))
                 (subcheck #t))
             ;; (println 'arg-in: a 'gt: gt 'tt: tt)
             ;; (println 'vars: vars)

             ;; generics are unforgiving to choice
             ;; so if we have number choice then
             ;; let's always force i64 or double
             (if (or (equal? tt (list *impc:ir:si64* *impc:ir:si32*))
                     (equal? tt (list *impc:ir:si64* *impc:ir:si32* *impc:ir:si16*))
                     (equal? tt (list *impc:ir:si64* *impc:ir:si32* *impc:ir:si16* *impc:ir:ui8*))
                     (equal? tt (list *impc:ir:si64* *impc:ir:si32* *impc:ir:si16* *impc:ir:ui8* *impc:ir:i1*)))
                 (set! tt (list *impc:ir:si64*)))
             (if (equal? tt (list *impc:ir:fp64* *impc:ir:fp32*))
                 (set! tt (list *impc:ir:fp64*)))

             ;; (println 1 'a: a 'tt: tt 'gt: gt)
             (if (and (list? tt) (= (length tt) 1)) (set! tt (car tt)))

             (if (and (atom? gt)
                      (symbol? gt)
                      (assoc-strcmp gt vars)
                      (if (regex:match? (symbol->string gt) ":")
                          (impc:ti:generic-types-matchup? gt tt vars)
                          #t))
                 (begin ;; (println '----matched-polytype-1: gt '-> tt)
                   (if (symbol? tt)
                       (if (not (assoc-strcmp tt vars))
                           (print-error "Catastrophic compiler error: type missing from VARs")
                           (if (null? (cdr (assoc-strcmp tt vars)))
                               (impc:ti:update-var gt vars kts (list tt))
                               (begin
                                 (impc:ti:update-var gt vars kts (impc:ti:type-unify (cdr (assoc-strcmp tt vars)) vars))))
                           (impc:ti:update-var gt vars kts (impc:ti:type-unify tt vars))))))

             (if (atom? tt)
                 (set! tt (list tt)))
             (if (and (list? tt)
                      (list? (car tt))
                      (not (atom? gt)))
                 (set! tt (car tt)))
             (if (atom? gt)
                 (set! gt (list gt)))
                                        ;(println 2 'a: a 'tt: tt 'gt: gt)
             ;; if gt and tt still not equal tt maybe a named-type
             (if (<> (length gt) (length tt))
                 (if (and (string? (car tt)) ;; named type?
                          (= (length gt) (length (impc:ti:get-namedtype-type (car tt)))))
                     (set! tt (impc:ti:get-namedtype-type (car tt)))
                     (set! subcheck #f)))
             ;;(print-error 'Compiler 'Error: 'type 'mismatch 'in 'generics gt '- tt)))

             ;; GCHANGE
             ;; we might be able to update-vars based by matching our request 'gt vs our result 'tt
             (if subcheck
                 (for-each
                  (lambda (aa bb)
                    ;; (println 'matched-polytype-2: aa '-> bb)
                    ;; (println 'vars: vars)
                    (if (and (atom? aa)
                             (symbol? aa)
                             (assoc-strcmp aa vars)
                             (if (regex:match? (symbol->string aa) ":")
                                 (impc:ti:generic-types-matchup? aa bb vars)
                                 #t))
                        (if (and (symbol? bb) (assoc-strcmp bb vars))
                            (begin
                                        ;(set! tt (impc:ti:type-unify (cdr (assoc-strcmp bb vars)) vars))
                                        ;(impc:ti:update-var aa vars kts tt))
                              (impc:ti:update-var aa vars kts (cdr (assoc-strcmp bb vars))))
                            (if (string? bb)
                                (impc:ti:update-var aa vars kts bb)
                                (impc:ti:update-var aa vars kts (list bb))))))
                  gt tt))
             tt))
         (cdr ast)
         (cddr gpoly-type))))


;; adds ##gnum's to all poly types
(define impc:ti:nativef-generics-make-gtypes-unique
  (lambda (pt gnum)
    (cond ((null? pt) '())
          ((symbol? pt)
           ;; (println 'bingo pt)
           (cond ((regex:match? (symbol->string pt) "^!") ;; check for !head and !head%b
                  (let ((kk (string->symbol (string-append (symbol->string pt) "##" (number->string gnum)))))
                    ;; (println 'pt: pt 'kk: kk)
                    kk))
                 ;; check for xlist*
                 ((or (if (and (regex:match? (symbol->string pt) ":")
                               (assoc-strcmp (string->symbol (car (regex:type-split (symbol->string pt) ":")))
                                             *impc:ir:gpolytypes*))
                          #t #f)
                      (assoc-strcmp (string->symbol (impc:ir:get-base-type (symbol->string pt)))
                                    *impc:ir:gpolytypes*))
                  (let ((kk (string->symbol (string-append (symbol->string pt) "##" (number->string gnum)))))
                    ;; (println 'pt: pt 'kk: kk)
                    kk))
                 ;; check for xlist%b*
                 ((and (regex:match? (symbol->string pt) "%") ;; check for
                       (assoc-strcmp (string->symbol (impc:ir:get-base-type (car (regex:split (symbol->string pt) "%")))) *impc:ir:gpolytypes*))
                  (let ((kk (string->symbol (string-append (symbol->string pt) "##" (number->string gnum)))))
                    ;; (println 'pt: pt 'kk: kk)
                    kk))
                 (else
                  ;; (println 'pt: pt 'kk: pt)
                  pt)))
          ((pair? pt)
           (cons (impc:ti:nativef-generics-make-gtypes-unique (car pt) gnum)
                 (impc:ti:nativef-generics-make-gtypes-unique (cdr pt) gnum)))
          (else pt))))


;; this attempts to update-var !bangs from reified types
;; i.e. if we have allready resolved xlist*##289 to %xlist--2812497382948
;; but we have failed to resolve !head##289
;; then we try to get back from %xlist--2812497382948 to set !head##289
;; (define impc:ti:reverse-set-bangs-from-reified
;;   (lambda (poly reified gnum vars)
;;     (println 'poly poly 'reified reified 'gnum: gnum)
;;     (if (regex:match? (symbol->string poly) "^!")
;; 	'done ;; we can only check reified if poly IS a list not a reference to a list (which happens with !)
;; 	(let* ((t (impc:ir:get-named-type reified))
;; 	       (ptrdepth (impc:ir:get-ptr-depth t))
;; 	       (gtd (impc:ti:generic-type-details poly))
;; 	       (tt (impc:ir:gpolytype-types (car gtd)))
;; 	       ;; (m1 (cl:remove-if (lambda (k) (or (string=? k "*")
;; 	       ;; 					 (string=? k "")))
;; 	       ;; 			 (regex:split t "(,)|({)|(})|(\\s)")))
;; 	       (m1 (impc:ir:get-type-from-str t))
;; 	       ;; (m2 (cl:remove-if (lambda (k)
;; 	       ;; 			   (or (string=? k "*")
;; 	       ;; 			       (string=? k "")))
;; 	       ;; 			 (regex:split (symbol->string tt) "(,)|(<)|(>)")))
;; 	       (m2 (impc:ir:get-type-from-pretty-str (apply string-append (symbol->string tt) (make-list ptrdepth "*")))))
;; 	  (println 'bangmatch: poly '-> reified)
;; 	  (println 't_: t)
;; 	  (println 'tt: tt)
;; 	  (println 'm1: m1)
;; 	  (println 'm2: m2)
;; 	  (println 'vars: vars)
;; 	  (if (= (length m1) (length m2))
;; 	      (map (lambda (a b)
;; 		     (println 'a: a 'b: b)
;; 		     (if (and (symbol? a)
;; 			      (regex:match? (symbol->string a) "^!"))
;; 			 (let* ((aa (symbol->string a))
;; 				(bangname (string->symbol
;; 					   (if (string=? "" (caddr gtd))
;; 					       (string-append aa "##" (number->string gnum))
;; 					       (string-append aa "%" (caddr gtd) "##" (number->string gnum)))))
;; 				(llllllllll (println 'bangname: bangname))
;; 				(bangname_current (cdr (assoc-strcmp bangname vars)))
;; 				(llllllllll (println 'bangname_current: bangname_current))
;; 				(bangname_current_unified (impc:ti:type-unify (cdr (assoc-strcmp bangname vars)) vars)))
;; 			   (println 'ttt)
;; 			   ;; (if (not (regex:match? b "^%")) (set! b (impc:ir:get-type-from-str b)))
;; 			   ;;(println 'bangname_current bangname_current 'bangname_current_unified bangname_current_unified)
;; 			   ;; possibly recursive decent
;; 			   (if (and (null? bangname_current_unified)
;; 				    (not (null? bangname_current))
;; 				    (symbol? (car bangname_current))
;; 				    (impc:ir:type? b))
;; 			       (let ((gtd2 (impc:ti:generic-type-details (car bangname_current))))
;; 				 ;;(println '_1_update-var (car bangname_current) b)
;; 				 ;;(println 'gtd gtd2)
;; 				 (impc:ti:update-var (car bangname_current) vars '() b)
;; 				 (if (and gtd2
;; 					  (eq? (car gtd) (car gtd2))
;; 					  (string? b)) ;; string b at this stage should be a "%..." reified type
;; 				     (impc:ti:reverse-set-bangs-from-reified (car bangname_current) b (cadr gtd2) vars))))
;; 			   ;; and local change :)
;; 			   (if (impc:ir:type? b)
;; 			       (begin
;; 				 ;; (println 'bangname: bangname 'newtype: b 'current bangname_current)
;; 				 (impc:ti:update-var bangname vars '() b))))))
;; 		   m2 m1))
;; 	  'done))))



;; this attempts to update-var !bangs from reified types
;; i.e. if we have allready resolved xlist*##289 to %xlist--2812497382948
;; but we have failed to resolve !head##289
;; then we try to get back from %xlist--2812497382948 to set !head##289
;; (define impc:ti:reverse-set-bangs-from-reified
;;   (lambda (poly reified gnum vars)
;;     (println 'reverse-bangs: poly 'reified reified 'gnum: gnum)
;;     (if (regex:match? (symbol->string poly) "^!")
;; 	'done ;; we can only check reified if poly IS a list not a reference to a list (which happens with !)
;; 	(let* ((t (impc:ir:get-named-type reified))
;;                ;; (lll (println 't: t))
;; 	       (ptrdepth (impc:ir:get-ptr-depth t))
;; 	       (gtd (impc:ti:generic-type-details poly))
;;                ;; (llllllllll (println 'poly: poly 'gtd: gtd))
;; 	       (tt (impc:ir:gpolytype-types (car gtd)))
;;                ;; (lllll (println 'tt tt))
;;                (tt2 (if (= (length gtd) 5) (list-ref gtd 4) '()))
;;                ;; (llllll (println 'tt2 tt2))
;; 	       (m1 (impc:ir:get-type-from-str t))
;; 	       (m2 (impc:ir:get-type-from-pretty-str (apply string-append (symbol->string tt) (make-list ptrdepth "*")))))
;; 	  ;; (println 'bangmatch: poly '-> reified)
;; 	  ;; (println 't_: t)
;;           (println 'gtd: gtd)
;; 	  (println 'tt: tt)
;;           ;; (println 'tt2: tt2)
;; 	  (println 'm1: m1)
;; 	  (println 'm2: m2)
;; 	  ;; (println 'vars: vars)
;; 	  (if (= (length m1) (length m2))
;; 	      (map (lambda (a b)
;; 		     (println 'a: a 'b: b)
;; 		     (if (and (symbol? a)
;; 			      (regex:match? (symbol->string a) "^!"))
;; 			 (let* ((aa (symbol->string a))
;; 				(bangname (string->symbol
;; 					   (if (string=? "" (caddr gtd))
;; 					       (string-append aa "##" (number->string gnum))
;; 					       (string-append aa "%" (caddr gtd) "##" (number->string gnum))))))
;; 			   (if (assoc-strcmp bangname vars)
;; 			       (let ((bangname_current (cdr (assoc-strcmp bangname vars)))
;; 				     (bangname_current_unified (impc:ti:type-unify (cdr (assoc-strcmp bangname vars)) vars)))
;; 				 ;; (if (not (regex:match? b "^%")) (set! b (impc:ir:get-type-from-str b)))
;; 				 ;;(println 'bangname_current bangname_current 'bangname_current_unified bangname_current_unified)
;; 				 ;; possibly recursive decent
;; 				 (if (and (null? bangname_current_unified)
;; 					  (not (null? bangname_current))
;; 					  (symbol? (car bangname_current))
;; 					  (impc:ir:type? b))
;; 				     (let ((gtd2 (impc:ti:generic-type-details (car bangname_current))))
;; 				       ;;(println '_1_update-var (car bangname_current) b)
;; 				       ;;(println 'gtd gtd2)
;;                                        ;; (println 'reverseupdate!!! (car bangname_current) 'with: b)
;;                                        ;; (println 'reified: reified 'vars: vars)
;; 				       (impc:ti:update-var (car bangname_current) vars '() b)
;; 				       (if (and gtd2
;; 						(eq? (car gtd) (car gtd2))
;; 						(string? b)) ;; string b at this stage should be a "%..." reified type
;; 					   (impc:ti:reverse-set-bangs-from-reified (car bangname_current) b (cadr gtd2) vars))))
;; 				 ;; and local change :)
;; 				 (if (impc:ir:type? b)
;; 				     (begin
;;                                        ;; (println 'reverseupdate! bangname 'with: b)
;;                                        ;; (println 'reified: reified 'vars: vars)
;; 				       ;; (println 'bangname: bangname 'newtype: b 'current bangname_current)
;; 				       (impc:ti:update-var bangname vars '() b))))
;; 			       'donothing))))
;; 		   m2 m1))
;; 	  'done))))



;; this attempts to update-var !bangs from reified types and also GTypes
;; i.e. if we have allready resolved xlist*##289 to %xlist--2812497382948
;; but we have failed to resolve !head##289
;; then we try to get back from %xlist--2812497382948 to set !head##289
(define impc:ti:reverse-set-bangs-from-reified
  (lambda (poly reified gnum vars)
    ;; (println 'reverse-bangs: poly 'gnum: gnum)
    ;; (println 'reified: reified)
    ;; (println 'pretty: (impc:ir:pretty-print-type reified))
    (if (and (not (list? poly))
             (or (not (symbol? poly))
                 (not (regex:match? (symbol->string poly) ":"))))
        'done ;; we can only check reified if poly IS a list (not a reference to a list!)
        (let* ((gpolytype (if (list? poly) poly
                              (impc:ir:get-type-from-pretty-str (car (regex:type-split (symbol->string poly) "##")))))
               (namedtype (impc:ir:get-type-from-str (impc:ir:get-named-type reified))))
          ;; (println 'poly: poly 'gnum gnum)
          ;; (println 'reified: (impc:ir:get-named-type reified))
          ;; (println 'polyt: gpolytype)
          ;; (println 'named: namedtype)
          (if (<> (length gpolytype)
                  (length namedtype))
              ;; not sure if this error message will work properly:
              (impc:compiler:print-type-mismatch-error (list poly gpolytype) (list reified namedtype)))
          (for-each (lambda (a b)
                      ;; (println 'a: a 'b: b)
                      (if (symbol? b)
                          (if (regex:match? (symbol->string b) "^!")
                              (impc:ti:update-var
                               (string->symbol (string-append (symbol->string b) "##" (number->string gnum)))
                               vars '() a)))
                      (if (and (string? a)
                               (not (string=? a reified)) ;; watch out for recursive!
                               (regex:match? a "_poly_"))
                          (impc:ti:reverse-set-bangs-from-reified b a gnum vars)))
                    namedtype gpolytype)))))

;;
;; first for generic functions we do a gnum test
;;
;; basically the gnum test looks to see if all of the types
;; in the gftype are of the same gnum as the generic function
;; if they aren't of the same gnum (i.e. if they are NEW links)
;; then we might be able to do additonal reverse lookups on the
;; OLD gnum vars by looking into NEW gnum vars
;;
;; for example:
;; if ORIGINAL type (gpoly-type) = (211 !head##110 xlist*##110)
;; and NEW type         (gftype) = (211 !head##110 xlist*##109)
;; then we might be able to match !head##110 against !head##109
;;
(define impc:ti:nativef-generics-final-tests
  (lambda (ast gpoly-type gftype gnum vars kts)
    ;; (println 'nativef-generics-final-tests)
    ;; do a final check of all !bang types in original gpoly-type to see
    ;; if we can improve them with any reified types we may have
    (for-each (lambda (k)
                (if (symbol? k)
                    (if (assoc-strcmp k vars) ;;(not (null? (assoc-strcmp k vars)))
                        (let ((v (cdr (assoc-strcmp k vars))))
                          (if (string? v)
                              (impc:ti:reverse-set-bangs-from-reified k v gnum vars)
                              (if (and (list? v)
                                       (= (length v) 1)
                                       (string? (car v)))
                                  (impc:ti:reverse-set-bangs-from-reified k (car v) gnum vars)))))))
              (cdr gpoly-type))
    ;; attempt to reify any gtype symbols that don't currenty have type values (i.e. not var entry)
    (for-each (lambda (a)
                (if (and (symbol? a)
                         (regex:match? (symbol->string a) "##")
                         (not (assoc-strcmp a vars)))
                    ;; (null? (cdr (assoc-strcmp a vars))))
                    ;; should call this impc:ti:symbol-tryto-reify-generic-type
                    (let ((res (impc:ti:reify-generic-type a vars '())))
                      (if (not (equal? res a))
                          (begin ;; (println 'genupdate: a '-> res)
                            (impc:ti:update-var a vars kts res))))))
              (cdr gftype))

    #t))


;; recursion test
(define *impc:ti:nativef-generics-recurse-test* 0)

(define impc:ti:nativef-generics-check-return-type
  (lambda (ast lambda-code gpoly-type gnum vars args)
    ;; (println 'lambda-code: lambda-code 'gnum: gnum)
    ;; (println 'ret-type-for: ast)
    (let ((grtype '()))
      ;;
      ;; this section is here to check for a return type
      ;; for this generic function.
      ;; we do this by grabbing the gpoly's lambda code and
      ;; sending it through type checking.
      ;;
      (if (< *impc:ti:nativef-generics-recurse-test* 5)
          (begin
            (set! *impc:ti:nativef-generics-recurse-test*
                  (+ *impc:ti:nativef-generics-recurse-test* 1))
            ;; type inferencing for generic functions return argument!
            (let* ((symname 'placeholder)
                   (extantsyms (map (lambda (x) (car x)) vars))
                   (s1 (impc:ti:rename-all-shadow-vars lambda-code extantsyms))
                   (c1 (impc:ti:get-var-types s1))
                   (t1 (impc:ti:first-transform (car c1) #t))
                   (s2 (impc:ti:rename-all-shadow-vars t1 extantsyms))
                   (c2 (impc:ti:get-var-types s2)) ;;lambda-code))
                   (t2 (impc:ti:mark-returns (car c2) symname #f #f #f))
                   (t3 (impc:ti:closure:convert t2 (list symname)))
                   (lvars (map (lambda (x) (list x)) (impc:ti:find-all-vars t3 '())))
                   (lvarnames (map (lambda (x) (car x)) lvars))
                   (trequest (impc:ti:type-unify gpoly-type vars))
                   (kts (cl:remove #f (map (lambda (x y) (if (impc:ir:type? y) x #f)) (cadr s1) args)))
                   (newvars (append lvars vars))
                   (ttype '()))
              ;; this here as a check (could be removed)
              (if (not (null? (cl:intersection lvarnames extantsyms)))
                  (impc:compiler:print-compiler-error "shadow vars found when specialising generic code" (cl:intersection lvarnames extantsyms)))
              ;; this is another check (could be removed)
              (for-each (lambda (x)
                          (if (member (car x) lvarnames)
                              (println 'Type 'Collision 'On x)))
                        vars)

              ;; update newvars to include incoming argument types
              (for-each (lambda (s t a)
                          ;; (println 's: s 't: t 'a: a)
                          (if (and (impc:ir:closure? t) (assoc-strcmp a *impc:ti:bound-lambdas*))
                              (set! *impc:ti:bound-lambdas*
                                    (cons (cons s (replace-all (cdr (assoc-strcmp a *impc:ti:bound-lambdas*))
                                                               (list (cons a s))))
                                          *impc:ti:bound-lambdas*)))
                          (impc:ti:update-var s newvars '() (impc:ti:type-unify t vars))
                          )
                        (cadr s1) ;;lambda-code)
                        args
                        (cdr ast))
              ;; NOW DO ACTUAL TYPE CHECK!
              (let ((toplvl? (if *impc:compiler:top-level-generic-error* #f #t)))
                (if toplvl? (set! *impc:compiler:top-level-generic-error*
                                  (cons (car (regex:type-split (symbol->string (car ast)) "##"))
                                        (map (lambda (t a)
                                               ;; (println 't: t 'a: a)
                                               (if (null? t)
                                                   (if (atom? a)
                                                       (cons "?" (atom->string a))
                                                       (sexpr->string a))
                                                   (cons (impc:ir:pretty-print-type t)
                                                         (if (atom? a)
                                                             (atom->string a)
                                                             (sexpr->string a)))))
                                             args
                                             (cdr ast)))))
                (set! ttype (impc:ti:type-check t1 newvars kts trequest))
                (if toplvl? (set! *impc:compiler:top-level-generic-error* #f)))
              ;; don't let any local vars (lvars) escape back up to a
              ;; level where they will not mean anything!!!!
              (set! ttype (replace-all ttype (map (lambda (x) (cons x '())) lvarnames)))
              (set! *impc:ti:nativef-generics-recurse-test* (- *impc:ti:nativef-generics-recurse-test* 1))
              (if (< *impc:ti:nativef-generics-recurse-test* 0)
                  (set! *impc:ti:nativef-generics-recurse-test* 0))
              (if (and (not (null? ttype))
                       (impc:ir:closure? (car ttype)))
                  ;; (impc:ir:type? (cadar ttype)))
                  (begin
                    ;; (println 'done ttype)
                    (set! grtype ttype)))))
          (begin ;; (println 'hit-recursion-limit)
            ;; (print-error 'Compiler 'Error: 'hit 'generics 'recursion 'limit)
            #f))
      grtype)))


;; generics check
(define impc:ti:nativef-generics
  (lambda (ast vars kts request?)
    ;; (println 'native: ast 'request: request?)
    ;; (println 'generics-check (car ast) 'request: request?)
    ;; (println 'vars: vars)
    ;; (println 'genericf-in: (assoc-strcmp (car ast) vars) 'request?)
    (set! impc:ir:get-type-expand-poly #f)
    ;; only check if no already fully formed!
    (if (impc:ir:type? (impc:ti:type-unify (cdr (assoc-strcmp (car ast) vars)) vars))
        (begin
          ;; (println 'bingo: 'saving 'time!)
          ;; (list (impc:ti:type-unify (cdr (assoc-strcmp (car ast) vars)) vars)))
          (for-each (lambda (x r)
                      (impc:ti:type-unify (impc:ti:type-check x vars kts r) vars))
                    (cdr ast)
                    (cddr (impc:ti:type-unify (cdr (assoc-strcmp (car ast) vars)) vars)))
          (list (cadr (impc:ti:type-unify (cdr (assoc-strcmp (car ast) vars)) vars))))
        (let* ((args (map (lambda (x)
                            (impc:ti:type-unify (impc:ti:type-check x vars kts #f) vars))
                          (cdr ast)))
               ;; (llllll (println 'nargs: (car ast) ': args))
               (gname (string->symbol (car (regex:split (symbol->string (car ast)) "##"))))
               (gnum (string->number (cadr (regex:split (symbol->string (car ast)) "##"))))
               (arity (- (length ast) 1))
               (gpt (impc:ir:gpoly-types gname arity args))
               ;; request? request? args)))
               (gpoly-code (cadr gpt))
               (lambda-code (caddr gpoly-code))
               (gtype (impc:ir:get-type-from-pretty-str (symbol->string (car gpt))))
               (gpoly-type (cons (real->integer (+ *impc:ir:closure* (* (impc:ir:get-ptr-depth gtype) *impc:ir:pointer*)))
                                 (map (lambda (k)
                                        (if (regex:match? k ":") ;; if generic either gvar of named type
                                            (string->symbol k)
                                            (impc:ir:get-type-from-pretty-str k)))
                                      (impc:ir:get-pretty-closure-arg-strings
                                       (cadr (regex:type-split (symbol->string (cadr gpoly-code)) ":")))))))
          ;; (println 'gpolycode: gpoly-code)

          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
          ;; this is all here purely for generating nicer compiler errors!
          ;; and can be removed safely without effecting any functionality
          (for-each (lambda (a b)
                      ;; (println 'a: a 'b: b)
                      (if (symbol? a)
                          (begin (set! a (assoc-strcmp a vars))
                                 (if (and (symbol? b)
                                          (list? a)
                                          (> (length a) 1)
                                          (atom? (cadr a))
                                          (regex:match? (symbol->string b) ":")) ;; generic!
                                     (let* ((bb (car (regex:type-split (symbol->string b) ":")))
                                            (ptrdepth (impc:ir:get-ptr-depth (symbol->string b)))
                                            (aa (cond ((string? (cadr a))
                                                       (cadr (regex:matched (cadr a) "%(.*)_poly_.*")))
                                                      ((symbol? (cadr a))
                                                       (car (regex:type-split (symbol->string (cadr a)) ":")))
                                                      (else (cadr a))))
                                            (aptrdepth (impc:ir:get-ptr-depth (cadr a))))
                                       ;; (println 'aa: aa 'bb: bb)
                                       (if (or (not (string? aa))
                                               (and (not (equal? aa bb))
                                                    (not (regex:match? aa "^!"))))
                                           (impc:compiler:print-type-mismatch-error
                                            (if (and (list? aa)
                                                     (not (impc:ir:type? aa)))
                                                aa
                                                (if (string? aa)
                                                    (apply string-append aa (make-list aptrdepth "*"))
                                                    (impc:ir:pretty-print-type aa)))
                                            (apply string-append bb (make-list ptrdepth "*"))
                                            (car (regex:type-split (symbol->string (car ast)) "##")))))))))
                    (cdr ast)
                    (cddr gpoly-type))
          ;;
          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

          ;; (gpoly-type (impc:ir:get-type-from-pretty-str (symbol->string (car (impc:ir:gpoly-types gname))))))


          ;; (set! impc:ir:get-type-expand-poly #t)
          ;; (println 'gpoly-type: gpoly-type 'gtype: gtype gnum)
          ;; (println 'gpoly-code: gpoly-code)
          ;; (println 'generictype: (cadr gpoly-code))
          ;;(println 'gpoly-typeb:> (car (impc:ir:gpoly-types gname)))
          (if (<> (length (cdr gpoly-type))
                  (length ast))
              (impc:compiler:print-compiler-error "bad arity in generics call" ast))

          ;; add ##gnum's to all gpoly types (both !bangs like !head and gpoly types like xlist*)
          (set! gpoly-type
                (impc:ti:type-unify
                 (impc:ti:nativef-generics-make-gtypes-unique gpoly-type gnum)
                 vars))

          ;; type inferencing for generic functions arguments and return type
          (let* ((res (impc:ti:nativef-generics-check-args ast gpoly-type vars kts request?))
                 (resb (map (lambda (x) (impc:ti:type-normalize (impc:ti:type-unify x vars))) res))
                 (req? (impc:ti:type-unify gpoly-type vars))
                 (nvars (cl:tree-copy vars))
                 (rtype (if (impc:ir:type? req?) ;; (cadr req?))
                            req?
                            (impc:ti:nativef-generics-check-return-type
                             ast lambda-code gpoly-type gnum nvars resb)))
                 ;; (cl:tree-copy vars)
                 (grtype (impc:ti:type-unify rtype vars)))

            ;; we might have gained something useful in nvars!
            ;; that we can use for vars!
            ;; have to be careful that it is a fully valid type though!
            ;; otherwise we might introduce dependencies from inside
            ;; a generic call that we should not have access to
            (for-each (lambda (n v)
                        (if (and (null? (cdr v))
                                 (= (length n) 2)
                                 (impc:ir:type? (cadr n)))
                            (begin ;; (println 'bingo 'update (car v) 'with (cdr n))
                              (impc:ti:update-var (car v) vars kts (cdr n)))))
                      nvars vars)

            ;; check to see if for-each is possible (i.e. request and (cadr gpoly-type)) are same length
            (if (list? request?)
                (if (and (list? (cadr gpoly-type))
                         (<> (length request?) (length (cadr gpoly-type))))
                    (set! request? #f))
                ;; (if (or (not (list? (cadr gpoly-type)))
                ;; 	       (<> (length request?) (length (cadr gpoly-type))))
                ;; 	   (set! request? #f))
                (if (list? (cadr gpoly-type))
                    (if (and (string? request?) ;; named type?
                             (= (length (cadr gpoly-type)) (length (impc:ti:get-namedtype-type request?))))
                        (set! request? (impc:ti:get-namedtype-type request?))
                        (set! request? #f))
                    (if (<> (length (list request?)) (length (list (cadr gpoly-type))))
                        (set! request? #f))))

            (if (and request?
                     (not (string? (cadr gpoly-type))))
                (if (and (list? request?)
                         (atom? (cadr gpoly-type))
                         (symbol? (cadr gpoly-type)))
                    (impc:ti:update-var (cadr gpoly-type) vars kts request?)
                    (if (and (list? request?)
                             (number? (cadr gpoly-type))
                             (member (cadr gpoly-type) request?))
                        (set! request? (cadr gpoly-type))
                        (for-each
                         (lambda (aa bb)
                           (if (and (atom? aa)
                                    (symbol? aa)
                                    (assoc-strcmp aa vars))
                               (impc:ti:update-var aa vars kts bb)))
                         (if (atom? request?)
                             (list (cadr gpoly-type))
                             (cadr gpoly-type))
                         (if (atom? request?)
                             (list request?)
                             request?)))))
            ;; (println 'gpoly-type-x: gpoly-type-x)
            ;; (set! gpoly-type gpoly-type-x)

            ;; if request? is not a fully formed type
            ;; then we will stick to the the current poly type
            (if (not (impc:ir:type? request?))
                (set! request? #f))

            ;; (println 'ast: 'preset: vars)
            ;; set generic functions type ( (cadr gpoly-type)|request? + res)
            (let ((gftype (if request?
                              (list (cons (+ *impc:ir:closure* (* 2 *impc:ir:pointer*))
                                          (cons (list request?) res)))
                              (list (cons (+ *impc:ir:closure* (* 2 *impc:ir:pointer*))
                                          (cons (list (cadr gpoly-type)) res))))))
              ;; (println 'gftype gftype)
              ;; (println 'gftype: gftype 'gpoly-type gpoly-type)
              (set! gftype (impc:ti:type-clean (car gftype)))
              (impc:ti:nativef-generics-final-tests ast gpoly-type gftype gnum vars kts)
              ;; if grtype is VALID
              ;; and if the return type of gftype is a symbol
              ;; THEN update the return type of gftype (symbol)
              ;; with the reified return type of grtype
              (if (and (impc:ir:type? grtype)
                       (symbol? (cadr gftype))
                       (assoc-strcmp (cadr gftype) vars))
                  (impc:ti:update-var (cadr gftype) vars kts (cadr grtype)))

              ;; update arguments?!
              (map (lambda (x y)
                     (if (symbol? x)
                         (impc:ti:update-var x vars kts (list y))))
                   (cdr ast)
                   (cddr gftype))

              ;; (println 'vars: vars)
              ;; (println 'request? request?)
              ;; (println 'gftype gftype (impc:ir:type? gftype))
              ;; (println 'grtype grtype (impc:ir:type? grtype))
              (if (impc:ir:type? grtype)
                  (impc:ti:update-var (car ast) vars kts (list grtype))
                  (impc:ti:update-var (car ast) vars kts (list gftype)))))

          (if request?
              (list request?)
              (list (cadr gpoly-type)))))))


;; polymorphic version
(define impc:ti:nativef-poly-check
  (lambda (ast vars kts request?)
    ;; (println 'poly-checking: (car ast))
    (if (impc:ir:type? (impc:ti:type-unify (cdr (assoc-strcmp (car ast) vars)) vars))
        (begin
          ;; (println 'bingo: 'saving 'time!)
          (for-each (lambda (a r)
                      (impc:ti:type-unify (impc:ti:type-check a vars kts r) vars))
                    (cdr ast)
                    (cddr (impc:ti:type-unify (cdr (assoc-strcmp (car ast) vars)) vars)))
          (list (cadr (impc:ti:type-unify (cdr (assoc-strcmp (car ast) vars)) vars))))
        (let* ((polyf (string->symbol (car (regex:split (symbol->string (car ast)) "##")))) ;"\\$\\$\\$"))))
               (ftypes (impc:ir:poly-types polyf))
               (valid-lgth (map (lambda (type)
                                  (if (<> (length (cdr type))
                                          (length ast)) #f #t))
                                ftypes))
               (valid-args (map (lambda (type valid)
                                  ;; (println 'type: type 'valid: valid)
                                  (if valid
                                      (let* ((checked-types
                                              (map (lambda (a t)
                                                     ;; andrew's change here!
                                                     (let ((t2 (impc:ti:type-unify (impc:ti:type-check a vars kts #f) vars)))
                                                       ;; (println 'a: a 't: t 't2: t2)
                                                       t2))
                                                   (cdr ast)
                                                   (cddr type)))
                                             (ct2 (map (lambda (ct ft) ;; checked type against poly type
                                                         ;; (println 'ct: ct 'ft: ft)
                                                         (if (and (number? ct) (number? ft))
                                                             (if (= ct ft) #t #f)
                                                             (if (and (string? ct) (string? ft))
                                                                 (if (string=? ct ft) #t #f)
                                                                 (if (list? ct)
                                                                     (if (member ft ct) #t #f) ;; #f
                                                                     #f))))
                                                       (if request?
                                                           (cons request? checked-types)
                                                           checked-types)
                                                       (if request?
                                                           (cdr type)
                                                           (cddr type)))))
                                        ct2)
                                      (list #f)))
                                ftypes
                                valid-lgth))
               (weighted-choices (map (lambda (l) (length (cl:remove #f l))) valid-args))
               (best-result (apply max weighted-choices))
               (valid-polys
                (cl:remove #f (map (lambda (type weight)
                                     (if (or
                                          (= weight 0)
                                          (< weight best-result)) #f
                                          type))
                                   ftypes
                                   weighted-choices))))
          ;; (println 'ftypes: ftypes)
          ;; (println 'weighted-choices: weighted-choices 'request? request?)
          ;; (println 'va valid-args)
          ;; (println '-> ast 'valid-polys: valid-polys 'request: request?)

          (if (null? valid-polys)
              (set! valid-polys
                    (cl:remove #f (map (lambda (a b) (if a b #f)) valid-lgth ftypes))))
          (if (null? valid-polys)
              (impc:compiler:print-compiler-error "no valid polymorphic options" ast))

                                        ;(println 'valid-polysa: valid-polys 'request? request? 'ast: ast)
          (let ((returns (map (lambda (t)
                                (cadr t))
                              valid-polys)))
            ;; (println 'returns returns 'request? request?)
            ;; (println 'vars: vars)
            ;; (if request?
            ;;     (if (list? request?)
            ;;         (set! returns (impc:ti:intersection* returns request?))
            ;;        (set! returns (impc:ti:intersection* returns (list request?)))))
            ;; (println 'returns2 returns)
            ;; (set! valid-polys (cl:remove #f
            ;;                              (map (lambda (v)
            ;;                                     (if (member (cadr v) returns)
            ;;                                         v
            ;;                                         #f))
            ;;                                   valid-polys)))

            ;; if we have a single valid poly
            ;; then we can try type-checking against
            ;; the correct function signature!
            (if (= 1 (length valid-polys))
                (map (lambda (a t)
                       (let ((t2 (impc:ti:type-unify (impc:ti:type-check a vars kts t) vars)))
                         ;; (println 'a: a 't: t 't2: t2)
                         t2))
                     (cdr ast)
                     (cddr (car valid-polys))))

            ;; (println 'updatepoly: valid-polys 'ast: ast)
            ;; update valid-polys to reflect return types (from request?)
            (impc:ti:update-var (car ast) vars kts valid-polys)
                                        ;(println 'returns: returns)
            returns)))))


;; (define impc:ti:callback-check
;;    (lambda (ast vars kts request?)
;;       ;(println 'callback-check 'ast: ast 'vars: vars 'request: request?)
;;       (let ((ftype (map impc:ir:get-type-from-str
;;                         (let ((ags (impc:ti:get-closure-arg-types (symbol->string (caddr ast)))))
;; 			  (if ags ags '())))))
;; 	;(println 'ftype: ftype)
;; 	(if *impc:ti:print-sub-checks* (println 'ftype:> 'ast: ast 'type: ftype))
;; 	(if (null? ftype)
;; 	    (begin (impc:ti:type-check (cadr ast) vars kts *impc:ir:si64*)
;; 		   (impc:ti:type-check (cddr ast) vars kts '())
;; 		   (list *impc:ir:void*))
;; 	    (begin (if (<> (+ 2 (length ftype))
;; 			   (length ast))
;; 		       (impc:compiler:print-compiler-error "bad arity in call" ast))
;; 		   ;; we don't care what we get back
;; 		   (for-each (lambda (a t)
;; 			       (if (symbol? a) (impc:ti:update-var a vars kts t))
;; 			       (impc:ti:type-check a vars kts t))
;; 			     (cdddr ast)
;; 			     (cdr ftype))
;; 		   ;; callback returns void
;; 		   (list *impc:ir:void*))))))

(define impc:ti:callback-check
  (lambda (ast vars kts request?)
    ;; (println 'callback-check 'ast: ast 'vars: vars 'request: request?)
    (let ((ftype (map impc:ir:get-type-from-str
                      (let ((ags (impc:ti:get-closure-arg-types (symbol->string (caddr ast)))))
                        (if ags ags '())))))
      (if *impc:ti:print-sub-checks* (println 'ftype:> 'ast: ast 'type: ftype))
      (impc:ti:type-check (cadr ast) vars kts *impc:ir:si64*)
      (if (null? ftype)
          (begin (let ((fargs (cons 213
                                    (cons -1
                                          (map (lambda (a)
                                                 (impc:ti:type-check a vars kts '()))
                                               (cdddr ast))))))
                   (if (and (assoc (caddr ast) vars)
                            (null? (cdr (assoc (caddr ast) vars))))
                       (impc:ti:update-var  (caddr ast) vars kts fargs)))
                 (list *impc:ir:void*))
          (begin (if (<> (+ 2 (length ftype))
                         (length ast))
                     (impc:compiler:print-compiler-error "bad arity in call" ast))
                 (if (and (assoc (caddr ast) vars)
                          (null? (cdr (assoc (caddr ast) vars))))
                     (impc:ti:update-var (caddr ast) vars kts (cons 213 ftype)))
                 ;; we don't care what we get back
                 (for-each (lambda (a t)
                             (if (symbol? a) (impc:ti:update-var a vars kts t))
                             (impc:ti:type-check a vars kts t))
                           (cdddr ast)
                           (cdr ftype))
                 ;; callback returns void
                 (list *impc:ir:void*))))))


(define impc:ti:push_new_zone-check
  (lambda (ast vars kts request?)
    (if (<> (length ast) 2)
        (impc:compiler:print-compiler-error "bad arity in call" ast))
    (impc:ti:type-check (cadr ast) vars kts *impc:ir:si64*)
    (list "%mzone*")))

(define impc:ti:push_zone-check
  (lambda (ast vars kts request?)
    (if (<> (length ast) 2)
        (impc:compiler:print-compiler-error "bad arity in call" ast))
    (impc:ti:type-check (cadr ast) vars kts "%mzone*")
    (list "%mzone*")))

(define impc:ti:create_zone-check
  (lambda (ast vars kts request?)
    (if (<> (length ast) 2)
        (impc:compiler:print-compiler-error "bad arity in call" ast))
    (impc:ti:type-check (cadr ast) vars kts *impc:ir:si64*)
    (list "%mzone*")))

(define impc:ti:pop_zone-check
  (lambda (ast vars kts request?)
    (if (<> (length ast) 1)
        (impc:compiler:print-compiler-error "bad arity in call" ast))
                                        ;(println 'memzonecheck ast (list? (cadr ast)))
    (list "%mzone*")))

;; (define impc:ti:memzone-check
;;   (lambda (ast vars kts request?)
;;     (if (or (> (length ast) 4)
;;             (< (length ast) 3))
;;         (impc:compiler:print-compiler-error  "memzone must be of the form (memzone size [delay] body) where \"delay\" is optional and \"body\" is a let, begin, lambda etc.."))
;;                                         ;(println 'memzonecheck ast (list? (cadr ast)))
;;     (if (= (length ast) 3)
;;         (begin (impc:ti:type-check (cadr ast) vars kts *impc:ir:si64*)
;;                (impc:ti:type-check (caddr ast) vars kts request?))
;;         (begin (impc:ti:type-check (cadr ast) vars kts *impc:ir:si64*)
;;                (impc:ti:type-check (caddr ast) vars kts *impc:ir:si64*)
;;                (impc:ti:type-check (cadddr ast) vars kts request?)))))



(define impc:ti:let-check
  (lambda (ast vars kts request?)
    ;; (println 'letchk: ast)
    ;; (println 'vars: vars '(cadr ast) (cadr ast))
    ;; for the symbols we want to set each return type
    (let ((internalreq?
           (if (equal? `(begin ,(caar (cadr ast)))
                       (caddr ast))
               request? #f)))
      (for-each (lambda (e)
                  (if (and (list? (cadr e))
                           (equal? (caadr e) 'lambda))
                      (set! *impc:ti:bound-lambdas* (cons e *impc:ti:bound-lambdas*)))
                  (if (and #f
                           (assoc-strcmp (car e) vars)
                           (impc:ir:type? (impc:ti:type-unify (cdr (assoc-strcmp (car e) vars)) vars)))
                      (list (impc:ti:type-unify (cdr (assoc-strcmp (car e) vars)) vars))
                      (let ((a (impc:ti:type-check (cadr e) vars kts
                                                   (if (member (car e) kts)
                                                       (cadr (assoc-strcmp (car e) vars))
                                                       internalreq?))))
                        ;; (println '---update: (car e) 'with: a)
                        (impc:ti:update-var (car e) vars kts a)
                        ;; (println '---vars: vars)
                        )))
                (cadr ast))
      ;; then return the return type for the whole let
      ;; which should have a begin body! so caddr should work
      (let ((ret (impc:ti:type-check (caddr ast) vars kts request?)))
        ret))))



(define impc:ti:null?-check
  (lambda (ast vars kts request?)
    ;;(println 'nullcheck)
    (let ((a (impc:ti:type-check (cadr ast) vars kts request?)))
      (if (null? a) ;; couldn't resolve yet!
          (list *impc:ir:i1*)
          (if (if (not (impc:ir:type? a))
                  (impc:ir:pointer? (car a))
                  (impc:ir:pointer? a))
              (list *impc:ir:i1*)
              (impc:compiler:print-compiler-error "null must take a pointer type" ast))))))


(define impc:ti:null-check
  (lambda (ast vars kts request?)
    ;; (println 'null-check 'ast: ast 'request? request?)
    (let ((res (if (and (symbol? request?)
                        (regex:match? (symbol->string request?) "##"))
                   (if (assoc-strcmp request? vars)
                       (if (null? (cdr (assoc-strcmp request? vars)))
                           request?
                           (cdr (assoc-strcmp request? vars))))
                   (if (and request?
                            (impc:ir:pointer? request?))
                       (list request?)
                       '())))) ;; forcing to i8* causes problems for generics
                                        ;(list (+ *impc:ir:pointer* *impc:ir:si8*))))))
      res)))



(define impc:ti:ret-check
  (lambda (ast vars kts request?)
    ;; (println 'retcheck: request?)
    ;; (println 'ast: ast)
    ;; grab function name from ret->
    (let* ((sym (if (equal? (caddr ast) (cadr ast))
                    '()
                    (impc:ti:get-var (cadr ast) vars)))
           (t (if (null? sym) #f
                  (if (null? (cdr sym))
                      #f
                      (if (impc:ir:type? (cdr sym))
                          (cdr sym)
                          (car (cdr sym))))))
                                        ;(car (cdr sym)))))
           ;; if closure has a return type set
           ;; pass it as a request
           (a (impc:ti:type-check (caddr ast) vars kts
                                  (if (and t
                                           (impc:ir:type? t)
                                           (impc:ir:closure? t))
                                      (if (list? t) (cadr t) request?)
                                        ;#f)))) ;; or else pass #f
                                      request?)))) ;; or pass on request
      ;;(println 'retchecked-> a 'request? request?)
      ;; if t is not a closure type we have a problem!
      (if (and t
               (or (not (list? t));(not (impc:ir:type? t))
                   (not (impc:ir:closure? t))))
          (impc:compiler:print-compiler-error "type error calculating return type - have you specified an incorrect closure type?" ast))
      (if *impc:ti:print-sub-checks* (println 'ret:> 'ast: ast 'a: a 'sym: sym))
      (if t
          ;; if the return value is a symbol then it should be
          ;; give then return type of 't
          (if (symbol? (caddr ast))
              (impc:ti:update-var (caddr ast) vars kts (list (cadr t)))
              ;; else the return value is not a symbol
              ;; and we should use it's value to update the lambda's type
              (impc:ti:update-var (car sym) vars kts
                                  (list (impc:ir:pointer++ (impc:ir:pointer++ (list* *impc:ir:closure* a (cddr t))))))))
      a)))


;; (define impc:ti:begin-check
;;   (lambda (ast vars kts request?)
;;     (let ((a (car (reverse (map (lambda (e)
;;                                   ;; (println 'e: e)
;;                                   (impc:ti:type-check e vars kts request?))
;;                                 (cdr ast))))))
;;       (if *impc:ti:print-sub-checks* (println 'begin:> 'ast: ast 'a: a))
;;       a)))


(define impc:ti:begin-check
  (lambda (ast vars kts request?)
    ;;(println 'request: request?)
    ;; we should ONLY use request? on the LAST sexpr in the begin
    ;; i.e. we should only use the LAST begin sexpr for a return type
    (let ((sexplst (reverse (cdr ast))))
      ;; we need type check coverage for ALL sexpr's
      ;; by only the last one counts towards the returned type

      ;; so we start with type coverage
      ;; reverse order shouldn't matter because there
      ;; should be no type dependencies between these sexpressions
      ;; also we don't want to pass any request? to these
      (map (lambda (e) (impc:ti:type-check e vars kts #f)) (cdr sexplst))
      ;; now we do the last sexpr in the begin for a return type
      ;; it SHOULD get passed the request?
      (let ((res (impc:ti:type-check (car sexplst) vars kts request?)))
        ;; and return res
        res))))


(define impc:ti:bitcast-check
  (lambda (ast vars kts request?)
    ;; (println 'bitcastcheck'req: request?)
    (if (null? (cddr ast))
        (if request? (list request?) (list))
        ;; for the symbols we want to set each return type
        ;;(impc:ti:update-var (cadr ast) vars kts (impc:ir:convert-from-pretty-types (caddr ast)))
        (list (impc:ir:convert-from-pretty-types (caddr ast))))))


(define impc:ti:bitconvert-check
  (lambda (ast vars kts request?)
    ;; don't pass on request because convert
    ;; is by definition expecting a different arg to its return!
    (impc:ti:type-check (cadr ast) vars kts #f)
    (if (null? (cddr ast))
        (if request? (list request?) (list))
        ;; for the symbols we want to set each return type
        ;;(impc:ti:update-var (cadr ast) vars kts (impc:ir:convert-from-pretty-types (caddr ast)))
        (list (impc:ir:convert-from-pretty-types (caddr ast))))))


(define impc:ti:if-check
  (lambda (ast vars kts request?)
                                        ;(println 'if: ast 'request? request?)
    (let* ((a (impc:ti:type-check (cadr ast) vars kts #f)) ;request?))
           (b (impc:ti:type-check (caddr ast) vars kts request?))
           (c (if (null? (cdddr ast))
                  '()
                  (impc:ti:type-check (cadddr ast) vars kts request?)))
           (t (impc:ti:type-unify (list b c) vars)))
                                        ;(t (cl:intersection (if (atom? b) (list b) b) (if (atom? c) (list c) c))))
      (if *impc:ti:print-sub-checks* (println 'if:> 'a: a 'b: b 'c: c 't: t))
      ;; (println 'a: a 'b: b 'c: c 't: t)
      (if (null? b)
          (set! t c))
      (if (null? c)
          (set! t b))
      ;; return intersection of b and c
      (if (null? t)
          t ;;(print-error 'Compiler 'Error: 'cannot 'unify 'then b 'and 'else c 'in ast) ;(map (lambda (v) (impc:ir:get-type-str v)) b) 'and 'else (map (lambda (v) (impc:ir:get-type-str v)) c) 'clauses 'in ast)
          t))))



(define impc:ti:void-check
  (lambda (ast vars kts request?)
    (if (> (length ast) 1)
        (impc:compiler:print-compiler-error "void does not take any arguments")
        (list *impc:ir:void*))))


(define impc:ti:array-set-check
  (lambda (ast vars kts request?)
    (if (<> (length ast) 4)
        (impc:compiler:print-bad-arity-error (car ast)))
    (let* ((a (impc:ti:type-check (cadr ast) vars kts '())) ;request?))
           ;; b should be fixed point types
           (b (impc:ti:type-check (caddr ast) vars kts (list *impc:ir:si64* *impc:ir:si32*)))
           ;; c should be of type a*
           (c (impc:ti:type-check (cadddr ast) vars kts (if (null? a) #f
                                                            (if (and (not (impc:ir:type? a))
                                                                     (impc:ir:array? (car a)))
                                                                (list (caddr (car a)))
                                                                (list (impc:ir:pointer-- (car a))))))))
      (if (or (and (not (null? a))
                   (not (impc:ir:array? (car a))))
              (and (not (null? a))
                   (> (impc:ir:get-ptr-depth (car a)) 1)))
          (impc:compiler:print-bad-type-error (impc:ir:get-type-str (car a) c)))
      ;; array set check will return the value set
      c)))


(define impc:ti:array-ref-ptr-check
  (lambda (ast vars kts request?)
    (if (<> (length ast) 3)
        (impc:compiler:print-bad-arity-error ast))
    (let ((a (impc:ti:type-check (cadr ast) vars kts '())) ;request?))
          ;; b should be fixed point
          (b (impc:ti:type-check (caddr ast) vars kts (list *impc:ir:si64* *impc:ir:si32*))))
      (if (impc:ir:type? a) (set! a (list a)))
      (if (null? a)
          a
          (if (or (not (impc:ir:array? (car a)))
                  (> (impc:ir:get-ptr-depth (car a)) 1))
              (impc:compiler:print-bad-type-error (impc:ir:get-type-str (car a)))
              (list (impc:ir:pointer++ (caddr (car a)))))))))


(define impc:ti:array-ref-check
  (lambda (ast vars kts request?)
                                        ;(println 'request? request?)
                                        ;(println 'array-ref-check: 'ast: ast 'vars: vars 'kts: kts)
    (if (<> (length ast) 3)
        (impc:compiler:print-bad-arity-error ast))
    (let ((a (impc:ti:type-check (cadr ast) vars kts '()))
          ;; b should be fixed point
          (b (impc:ti:type-check (caddr ast) vars kts (list *impc:ir:si64* *impc:ir:si32*))))
      (if (impc:ir:type? a) (set! a (list a)))
      (if (null? a)
          a
          (if (or (not (impc:ir:array? (car a)))
                  (> (impc:ir:get-ptr-depth (car a)) 1))
              (impc:compiler:print-bad-type-error (impc:ir:get-type-str (car a)))
              (list (caddr (car a))))))))

(define impc:ti:vector-set-check
  (lambda (ast vars kts request?)
                                        ;(println 'ast: ast 'vars: vars)
    (if (<> (length ast) 4)
        (impc:compiler:print-bad-arity-error ast))
    (let* ((a (impc:ti:type-check (cadr ast) vars kts '())) ;request?))
           ;; b should be i32
           (b (impc:ti:type-check (caddr ast) vars kts (list *impc:ir:si32*)))
           ;; c should be of type a*
           (c (impc:ti:type-check (cadddr ast) vars kts (if (null? a) #f (list (caddr (car a)))))))
      (if (or (and (not (null? a))
                   (not (impc:ir:vector? (car a))))
              (and (not (null? a))
                   (> (impc:ir:get-ptr-depth (car a)) 1)))
          (impc:compiler:print-bad-type-error (impc:ir:get-type-str (car a))))
      ;; vector set returns a whole new vector!  check llvm ir doc
      a)))

(define impc:ti:vector-ref-check
  (lambda (ast vars kts request?)
                                        ;(println 'request? request?)
                                        ;(println 'vector-ref-check: 'ast: ast 'vars: vars 'kts: kts)
    (if (<> (length ast) 3)
        (impc:compiler:print-bad-arity-error ast))
    (let ((a (impc:ti:type-check (cadr ast) vars kts '()))
          ;; b should be i32
          (b (impc:ti:type-check (caddr ast) vars kts (list *impc:ir:si32*))))
      (if (impc:ir:type? a) (set! a (list a)))
      (if (null? a)
          a
          (if (or (not (impc:ir:vector? (car a)))
                  (> (impc:ir:get-ptr-depth (car a)) 1))
              (impc:compiler:print-bad-type-error (impc:ir:get-type-str (car a)))
              (list (caddr (car a))))))))


(define impc:ti:vector-shuffle-check
  (lambda (ast vars kts request?)
    ;;(println 'vector-ref-check: 'ast: ast 'vars: vars 'kts: kts)
    (let ((a (impc:ti:type-check (cadr ast) vars kts request?))
          (b (impc:ti:type-check (caddr ast) vars kts request?)))
      (if (impc:ir:type? a) (set! a (list a)))
      (if (impc:ir:pointer? (car a))
          (impc:ir:pointer-- (car a))
          (car a)))))


(define impc:ti:pointer-set-check
  (lambda (ast vars kts request?)
    (if (<> (length ast) 4)
        (impc:compiler:print-bad-arity-error ast))
    (let* ((aa (impc:ti:type-check (cadr ast) vars kts request?))
           (a (if (and (list? aa) (= (length aa) 1) (symbol? (car aa))) '() aa))
           ;; b should be fixed point types
           (b (impc:ti:type-check (caddr ast) vars kts (list *impc:ir:si64* *impc:ir:si32*)))
           ;; c should be of type a*
           (c (impc:ti:type-check (cadddr ast) vars kts (if (null? a) #f
                                                            (if (atom? a)
                                                                (list (impc:ir:pointer-- a))
                                                                (if (and (not (impc:ir:type? a))
                                                                         (impc:ir:array? (car a)))
                                                                    (list (caddr (car a)))
                                                                    (list (impc:ir:pointer-- (car a)))))))))
      ;; try running type check on a if C exists! but a does not
      (if (and (null? a)
               (not (null? c)))
          (begin ;; (println 'bingo c)
            (set! a (impc:ti:type-check (cadr ast) vars kts
                                        (map (lambda (k) (impc:ir:pointer++ k))
                                             (cl:remove-if-not impc:ir:type? c))))))
      (if (not (null? a))
          (if (not (impc:ir:pointer? (if (impc:ir:type? a) a
                                         (if (list? a) (car a) a))))
              (impc:compiler:print-bad-type-error a "trying to pset! into a value")))

      (if (and (list? c) (= 1 (length c))) (set! c (car c)))

      (if (and (symbol? (cadr ast))
               (impc:ir:type? c))
          (if (string? c)
              (impc:ti:update-var (cadr ast) vars kts (string-append c "*"))
              (impc:ti:update-var (cadr ast) vars kts (impc:ir:pointer++ c))))
      ;; array set check will return the type of the value set
      c)))


(define impc:ti:pointer-ref-ptr-check
  (lambda (ast vars kts request?)
    (if (<> (length ast) 3)
        (impc:compiler:print-bad-arity-error ast))
    (let ((a (impc:ti:type-check (cadr ast) vars kts request?))
          ;; b should be fixed point
          (b (impc:ti:type-check (caddr ast) vars kts (list *impc:ir:si64* *impc:ir:si32*))))
      (if (impc:ir:type? a) (set! a (list a)))
      (if (null? a)
          a
          (if (impc:ir:array? (car a))
              (list (impc:ir:pointer++ (caddr (car a))))
              (list (car a)))))))


(define impc:ti:pointer-ref-check
  (lambda (ast vars kts request?)
    ;; (println 'pointer-ref-check: 'ast: ast 'request? request?) ;'vars: vars 'kts: kts)
    (if (<> (length ast) 3)
        (impc:compiler:print-bad-arity-error ast))
    (if (or (impc:ir:type? request?) (atom? request?)) (set! request? (list request?)))
    (let ((a (impc:ti:type-check (cadr ast) vars kts ;; '())) ;request?))
                                 (map (lambda (k) (impc:ir:pointer++ k))
                                      (cl:remove-if-not impc:ir:type? request?))))
          ;; b should be fixed point
          (b (impc:ti:type-check (caddr ast) vars kts (list *impc:ir:si64* *impc:ir:si32*))))
      (if (impc:ir:type? a) (set! a (list a)))
      (if (null? a)
          a
          (if (impc:ir:array? (car a))
              (list (caddr (car a)))
              (list (impc:ir:pointer-- (car a))))))))



;; make should be of the form
;; (make type)
;; where type is a valid type
;; (make i64)
;; memory is allocated on the head
(define impc:ti:heap-alloc-check
  (lambda (ast vars kts request?)
    ;; make should return a ptr to type a
    (let ((a (impc:ir:convert-from-pretty-types (if (< (length ast) 3) (cadr ast) (caddr ast)))))
      ;; returns a pointer of tuple type 'a'
      (if (null? a) a
          (impc:ir:pointer++ a)))))

;; make should be of the form
;; (halloc type)
;; where type is a valid type
;; (nalloc i64)
;; memory is allocated on the head
(define impc:ti:heap-alloc-check
  (lambda (ast vars kts request?)
    request?))


;; make should be of the form
;; (make type)
;; where type is a valid type
;; (make i64)
;; memory is allocated on the head
(define impc:ti:zone-alloc-check
  (lambda (ast vars kts request?)
    ;; make should return a ptr to type a
    (let ((a (impc:ir:convert-from-pretty-types (if (< (length ast) 3) (cadr ast) (caddr ast)))))
                                        ;(println 'zone-alloc-check 'a: a 'request: request?)
      ;; returns a pointer of tuple type 'a'
      (if (null? a) a
          (impc:ir:pointer++ a)))))

;; make should be of the form
;; (alloc type)
;; where type is a valid type
;; (alloc i64)
;; memory is allocated on the head
(define impc:ti:zone-alloc-check
  (lambda (ast vars kts request?)
    request?))

;; (if (null? (cdr ast))
;; 	 request?
;; 	 ;; make should return a ptr to type a
;; 	 (let ((a (impc:ir:convert-from-pretty-types (if (< (length ast) 3) (cadr ast) (caddr ast)))))
;; 	   (println 'zone-alloc-check 'a: a 'request: request?)
;; 	   ;; returns a pointer of tuple type 'a'
;; 	   (if (null? a) a
;; 	       (impc:ir:pointer++ a))))))


;; make should be of the form
;; (make type)
;; where type is a valid type
;; (make i64)
;; memory is allocated on the stack
(define impc:ti:stack-alloc-check
  (lambda (ast vars kts request?)
    ;; alloc should return a ptr to type a
    (let ((a (impc:ir:convert-from-pretty-types (if (< (length ast) 3) (cadr ast) (caddr ast)))))
      ;; returns a pointer of tuple type 'a'
      (if (null? a) a
          (impc:ir:pointer++ a)))))


;; make should be of the form
;; (salloc type)
;; where type is a valid type
;; (salloc i64)
;; memory is allocated on the head
(define impc:ti:stack-alloc-check
  (lambda (ast vars kts request?)
    request?))


(define impc:ti:tuple-set-check
  (lambda (ast vars kts request?)
    ;; (println 'tsetcheck ast) ; vars kts request?)
    (if (<> (length ast) 4)
        (impc:compiler:print-bad-arity-error ast))
    ;; (caddr ast) must be an integer
    (if (not (integer? (caddr ast)))
        (impc:compiler:print-bad-type-error (caddr ast) "tuple-set! must use a literal integer index"))
    (let* (;; a should be a tuple of some kind
           (a (let ((res (impc:ti:type-check (cadr ast) vars kts request?)))
                (if (null? res) res
                    (if (and (string? (car res))
                             (char=? (string-ref (car res) 0) #\%))
                        (let ((t (impc:ti:get-namedtype-type (impc:ir:get-base-type (car res)))))
                          (dotimes (i (impc:ir:get-ptr-depth (car res))) (set! t (impc:ir:pointer++ t)))
                          (list t))
                        res))))
           ;; b should be 32bit fixed point type -- llvm structs only support 32bit indexes
           (b (impc:ti:type-check (caddr ast) vars kts (list *impc:ir:si32*)))
           (req? (if (and (not (null? a))
                          (list? a))
                     (if (impc:ir:tuple? (car a))
                         (if (> (+ 2 (caddr ast)) (length (car a)))
                             (impc:compiler:print-index-oob-error 'tuple ast)
                             (list-ref (car a) (+ 1 (caddr ast))))
                         #f)
                     #f))
                                        ;(llllll (println 'req: req?  'cara: (car a) 'z: (caddr ast) 'list-ref: (+ 1 (caddr ast))))
           ;; c should be an element of a tuple
           (c (impc:ti:type-check (cadddr ast) vars kts req?)))
      ;; (if (and (not (null? a))
      ;;          (list? a))
      ;;     (if (impc:ir:tuple? (car a))
      ;;         (list-ref (car a) (+ 1 (caddr ast)))
      ;;         #f)
      ;;     #f))))
      (if (and (not (null? a))
               (not (symbol? (car a))) ;; symbol may not have yet been defined!!
               (not (impc:ir:tuple? (car a))))
          (impc:compiler:print-bad-type-error (caddr ast) (string-append "invalid tuple-set-check type " (impc:ir:get-type-str (car a)))))
      ;; if (cadddr ast) is a symbol we should update
      ;; it's type with c but for polymorphic cases
      ;; we should ensure that we also do a type-unification
      (if (symbol? (cadddr ast))
          (let* ((types (if (assoc-strcmp (cadddr ast) vars)
                            (cdr (assoc-strcmp (cadddr ast) vars))
                            (impc:ti:type-check (cadddr ast) vars kts req?)))
                 (utype (impc:ti:type-unify (list c types) vars)))
                                        ;(println 'types: types 'utype: utype 'c: (list c types))
            (if (null? utype)
                (impc:ti:force-var (cadddr ast) vars kts (list c))
                (impc:ti:force-var (cadddr ast) vars kts (list utype)))))

      ;; tuple set check will return the type of the value set
      c)))


(define impc:ti:tuple-ref-ptr-check
  (lambda (ast vars kts request?)
    ;; (caddr ast) must be an integer
    (if (not (integer? (caddr ast)))
        (impc:compiler:print-bad-type-error (caddr ast) "tuple-ref must use a literal integer index"))
    (let* (; a should be a tuple of some kind!
           (a (impc:ti:type-check (cadr ast) vars kts #f)) ;;(if (impc:ir:type? request?)
           ;;(impc:ir:tuple? request?)
           ;;request?
           ;;#f))) ;request?))
           ;; b should be fixed point -- llvm structs only support 32bit indexes
           (b (impc:ti:type-check (caddr ast) vars kts (list *impc:ir:si32*))))
      (if (and (not (null? a)) (or (atom? a) (impc:ir:type? a)))  (set! a (list a)))

      ;; check for named types
      (if (not (null? a)) (set! a (impc:ti:try-to-resolve-named-types (car a) vars)))


      ;;(println 'tupref-check 'a: a 'ast: ast (list-ref (car a) (+ 1 (caddr ast))))
      (if (and (not (null? a))
               (list? a)
               (impc:ir:tuple? (car a)))
          (list (impc:ir:pointer++ (list-ref (car a) (+ 1 (caddr ast)))))
          ;;'()))))
          (if (null? a)
              '()
              ;; (impc:compiler:print-bad-type-error (caddr ast) (string-append "invalid tuple-ref-ptr type " (impc:ir:get-type-str (car a)))))))))
              a)))))



(define impc:ti:tuple-ref-check
  (lambda (ast vars kts request?)
                                        ;(println 'ref-check ast request?) ;kts vars)
    ;; (caddr ast) must be an integer
    (if (not (integer? (caddr ast)))
        (impc:compiler:print-bad-type-error (caddr ast) "tuple-ref must use a literal integer index"))
    (let* (; a should be a tuple of some kind!
           (a (impc:ti:type-check (cadr ast) vars kts #f)) ;(if (and (impc:ir:type? request?)
                                        ;	(impc:ir:tuple? request?))
                                        ;  request?
                                        ; #f))) ;request?))
           ;; b should be fixed point -- llvm structs only support 32bit indexes
           (b (impc:ti:type-check (caddr ast) vars kts (list *impc:ir:si32*)))
           (idx (eval (caddr ast))))
      ;; (println 'a1: a)
      (if (and (not (null? a)) (or (atom? a) (impc:ir:type? a))) (set! a (list a)))
      ;; unify a?
      (if (not (null? a)) (set! a (impc:ti:type-unify (car a) vars)))
      (if (and (not (null? a)) (or (atom? a) (impc:ir:type? a))) (set! a (list a)))
      ;; (println 'a2: a)
      ;; is 'a' still generic? (i.e. not resolved to a named type yet?)
      (if (and (not (null? a))
               (symbol? (car a)))
          (let* ((p1 (regex:split (symbol->string (car a)) "##"))
                 ;;(lllll (println 'p1: p1))
                 (p2 (regex:split (car p1) ":"))
                 ;;(llllllll (println 'p2: p2))
                 (args (map (lambda (x)
                              (if (regex:match? x "^\\!")
                                  (string->symbol (string-append x "##" (cadr p1)))
                                  (impc:ir:get-type-from-pretty-str x)))
                            (if (null? (cdr p2))
                                '()
                                (impc:ir:get-pretty-tuple-arg-strings (cadr p2))))))
            (set! a (list (list (cons 114 args))))))
      ;; (println 'a3: a)
      ;; we MUST expand named types!
      (if (not (null? a)) (set! a (impc:ti:try-to-resolve-named-types (car a) vars)))
      (if (and (not (null? a)) (or (atom? a) (impc:ir:type? a)))  (set! a (list a)))
      ;; (println 'a4: a)
      (if (and (not (null? a))
               (list? a)
               (impc:ir:tuple? (car a)))
          (begin (if (>= (caddr ast)
                         (- (length (car a)) 1))
                     (impc:compiler:print-index-oob-error 'tuple ast))
                 (let ((res (list-ref (car a) (+ 1 idx))))
                   ;; (println 'res: res 'req: request?)
                   (if (not (impc:ir:type? res))
                       (if (and (assoc-strcmp res vars) request?)
                           (if (null? (cdr (assoc-strcmp res vars)))
                               (begin
                                 ;; (println 'updateres: res '-> request?)
                                 (impc:ti:update-var res vars kts request?)
                                 (set! res request?))
                               (set! res '()))
                           (set! res '())))
                   ;; (println 'trefres: res)
                   res))
          '()))))

;; 	     (if (impc:ir:type? res) res
;; 		 (if (assoc-strcmp res vars)
;; 		     (assoc-strcmp res vars)
;; 		     '()))))
;; '()))))
;; (if (null? a)
;; 	'()
;;     ;; (impc:compiler:print-bad-type-error (impc:ir:get-type-str (car a)) "in tuple-ref"))))))
;;     a)))))


;;(closure-set! closure a i32 5)
(define impc:ti:closure-set-check
  (lambda (ast vars kts request?)
                                        ;(println 'cset 'ast: ast 'request? request?)
    (if (<> (length ast) 5)
        (impc:compiler:print-bad-arity-error ast))
    (let* (;; a should be a closure of some kind
           (a (if (and (symbol? (cadr ast))
                       (impc:ti:closure-exists? (symbol->string (cadr ast))))
                  #t ; // yes (cadr ast) is a globally defined closure
                  (impc:ti:type-check (cadr ast) vars kts request?)))
           ;; b should be a string (the var's name)
           (b (impc:ti:type-check (caddr ast) vars kts (list *impc:ir:si8*)))
           ;; c should be a value for var's name
           (c (impc:ti:type-check (cadddr ast) vars kts
                                  (if (null? (car (cddddr ast)))
                                      request?
                                      (impc:ir:get-type-from-str (car (cddddr ast)))))))
      c)))

;;(closure-ref closure a i32)
(define impc:ti:closure-ref-check
  (lambda (ast vars kts request?)
                                        ;(println 'cls 'ref 'check: ast 'request? request?)
    (if (<> (length ast) 4)
        (impc:compiler:print-bad-arity-error ast))
    (let* (;; a should be a closure of some kind
           (a (if (and (symbol? (cadr ast))
                       (impc:ti:closure-exists? (symbol->string (cadr ast))))
                  #t ; // yes (cadr ast) is a globally defined closure
                  (impc:ti:type-check (cadr ast) vars kts request?)))
           ;; b should be a string (the var's name)
           (b (impc:ti:type-check (caddr ast) vars kts (list *impc:ir:si8*))))
      (if (null? (cadddr ast))
          (if request?
              request?
              '())
          (impc:ir:get-type-from-str (cadddr ast))))))

;; (closure-ref closure a i32)
(define impc:ti:closure-refcheck-check
  (lambda (ast vars kts request?)
                                        ;(println 'cls 'ref 'check: ast 'request? request?)
    (if (<> (length ast) 3)
        (impc:compiler:print-bad-arity-error ast))
    (let* (;; a should be a closure of some kind
           (a (if (and (symbol? (cadr ast))
                       (impc:ti:closure-exists? (symbol->string (cadr ast))))
                  #t ; // yes (cadr ast) is a globally defined closure
                  (impc:ti:type-check (cadr ast) vars kts request?)))
           ;; b should be a string (the var's name)
           (b (impc:ti:type-check (caddr ast) vars kts (list *impc:ir:si8*))))
      (list *impc:ir:i1*))))


(define impc:ti:set-check
  (lambda (ast vars kts request?)
    ;; (println 'ast: ast 'vars: vars 'kts: kts 'request?: request?)
    (let* ((sym (impc:ti:get-var (cadr ast) vars))
           (a (impc:ti:type-check (caddr ast) vars kts (cdr sym))))
      (if *impc:ti:print-sub-checks* (println 'set!:> 'ast: ast 'a: a))
      ;; (println 'a: a 'sym: sym)
      (if (and (list? a)
               (= (length a) 1)
               (impc:ir:type? (car a)))
          (set! a (car a)))
      ;; if sym is not a global var then add return type to sym
      (if (and (assoc-strcmp (car sym) vars)
               (member a (cdr (assoc-strcmp (car sym) vars))))
          (impc:ti:force-var (car sym) vars '() a)
          (if (assoc-strcmp (car sym) vars)
              (impc:ti:update-var (car sym) vars kts a)))
      a)))

(define impc:ti:pdref-check
  (lambda (ast vars kts request?)
    (let* ((a (impc:ti:type-check (cadr ast) vars kts request?)))
      (if *impc:ti:print-sub-checks* (println 'ptrref:> 'ast: ast 'a: a))
      ;; return type of ptrref is 'a' dereferenced'
      (if (list? a)
          (set! a (car a)))
      (if (and (impc:ir:type? a)
               (impc:ir:pointer? a))
          (impc:ir:pointer-- a)
          (impc:compiler:print-bad-type-error a "pref needs a pointer argument")))))


(define impc:ti:pref-check
  (lambda (ast vars kts request?)
    (let* ((a (impc:ti:type-check (cadr ast) vars kts request?)))
      (if *impc:ti:print-sub-checks* (println 'ptrref:> 'ast: ast 'a: a))
      ;; return type of ptrref is 'a' referenced
      (if (list? a)
          (set! a (car a)))
      (if (and (impc:ir:type? a)
               (impc:ir:pointer? a))
          (impc:ir:pointer++ a)
          (impc:compiler:print-bad-type-error a "pref needs a pointer argument")))))


(define impc:ti:lambda-check
  (lambda (ast vars kts request?)
    ;; (println 'lcheck: ast 'request? request?)
    ;; (println 'vars: vars)
    ;;'ast: ast 'request? request? 'vars: vars 'kts: kts)
    ;; first we check if a type request has been made
    (if (and request?
             (impc:ir:closure? request?))
        ;; if there is a request then cycle through
        ;; and set lambda arg symbols
        (begin (map (lambda (sym req)
                      ;; (println 'larg: sym 'req: req)
                      (if (symbol? sym)
                          (if (atom? req)
                              (impc:ti:update-var sym vars kts (list req))
                              (impc:ti:update-var sym vars kts req))))
                    (cadr ast)
                    (cddr request?))
               ;; finally set request? to the return type
               (set! request? (cadr request?))))
    ;; run body for type coverage
    ;; grab the last result as return type
    ;; (println 'aaaa: (caddr ast))
    ;; (println 'vars: vars)
    (let ((res (impc:ti:type-check (caddr ast) vars kts request?)))
                                        ;(println 'bbbb: res '-> request? request?) ;  '-> (caddr ast))
      ;; if we have a choice between numeric options we force one!
      (if (and (not (impc:ti:complex-type? res))
               (list? res)
               (> (length res) 1)
               (not (member #f (map (lambda (t) (impc:ir:floating-point? t)) res))))
          (set! res (list *impc:ir:fp64*))) ;; force doubles
      (if (and (not (impc:ti:complex-type? res))
               (list? res)
               (> (length res) 1)
               (not (member #f (map (lambda (t) (impc:ir:fixed-point? t)) res))))
          (set! res (list *impc:ir:si64*))) ;; force i64
      ;; (println 'cccc: res)
      ;; return lambda type which is made up of
      ;; argument symbols plus return type from last body expression
      ;; (println 'vars: vars)
      (let* ((ret (list (impc:ir:pointer++ (impc:ir:pointer++ (list* *impc:ir:closure* res (cadr ast))))))
             (uret (impc:ti:type-unify ret vars)))
        ;; (println 'ret: ret)
        ;; (println 'uret: uret)
        ;; (println 'request: request?)
        (if (not (null? uret))
            (map (lambda (sym req)
                   ;; (println 'larg: sym 'req: req)
                   (if (symbol? sym)
                       (impc:ti:update-var sym vars kts (impc:ti:type-unify req vars))))
                 (cadr ast)
                 (cddr uret)))
        (if (null? uret) ret uret)))))


;; whenever a closure is called we calculate a type for it
;; at the end these possibly multiple views should unify!
(define impc:ti:closure-call-check
  (lambda (ast vars kts request?)
    ;; (println 'cchint 'ast: ast 'vars: vars 'request: request?)
    ;; otherwise we need to try to find a type definition for the closure
    (let* ((ctype (if (assoc-strcmp (car ast) vars)
                      (cdr (assoc-strcmp (car ast) vars))
                      (if (impc:ti:closure-exists? (symbol->string (car ast)))
                          (list (impc:ti:get-closure-type (symbol->string (car ast))))
                          (impc:compiler:print-missing-identifier-error (car ast) 'closure))))
           ;; (llllllll (println 'ctype: ctype))
           ;; get argument expression types
           (res (map (lambda (e t)
                       ;; (println 'e: e 't: t)
                       (let ((res (impc:ti:type-check e vars kts
                                                      (if (symbol? t)
                                                          (impc:ti:symbol-check t vars kts #f)
                                                          t))))
                         ;; if t is a symbol then add res to t
                         (if (and (not (null? res))
                                  (symbol? t))
                             (if (or (and (list? res)
                                          (impc:ir:type? (car res)))
                                     (impc:ir:type? res))
                                 (impc:ti:force-var t vars kts res)
                                        ;(impc:ti:update-var t vars kts res)
                                 (impc:ti:update-var t vars kts res)))
                                        ;(if (symbol? t) (impc:ti:update-var t vars kts res))

                         res))
                     (cdr ast)
                     (if (or (null? ctype)
                             (and (number? (car ctype))
                                  (= (car ctype) (+ *impc:ir:closure* (* 2 *impc:ir:pointer*))))
                             (not (impc:ir:closure? (car ctype))))
                         (make-list (length (cdr ast)) #f)
                         ;; if we are using an existing definition then check arity
                         (if (<> (length (cddr (car ctype)))
                                 (length (cdr ast)))
                             (impc:compiler:print-bad-arity-error ast)
                             (cddr (car ctype))))))
           ;; if we already have a type defined we can use it's return type
           ;; otherwise
           ;; if there was a request that will be the return type
           ;; otherwise we cannot know it
           (ret (if (and (not (null? ctype))
                         (not (atom? (car ctype)))
                         (impc:ir:closure? (car ctype)))
                    (cadr (car ctype))
                    (if (and request?
                             (not (null? request?)))
                        request?
                        '()))))

      (if *impc:ti:print-sub-checks* (println 'closure:> 'ast: ast 'res: res 'ret: ret))
      (if (assoc-strcmp (car ast) vars)
          (impc:ti:update-var (car ast) vars kts
                              (list (impc:ir:pointer++ (impc:ir:pointer++ (list* *impc:ir:closure* ret res))))))
      (if (list? ret) ret
          (list ret)))))


;; for fptrcall
;; which has the form
;; (fptrcall fptr ... args)
(define impc:ti:fptrcall-check
  (lambda (ast vars kts request?)
    ;; (println 'ast: ast)
    (let* ((fptr (impc:ti:type-check (cadr ast) vars kts #f))
           ;; (lllll (println 'fptr fptr))
           (ctype (if (impc:ir:closure? (car fptr))
                      (car fptr)
                      (impc:compiler:print-bad-type-error (car fptr) "bad fptr type in fptrcall")))
           ;; (lllllll (println 'ctype ctype))
           ;; get argument expression types
           (res (map (lambda (e t)
                       ;;(println 'e: e 't: t)
                       (let ((res (impc:ti:type-check e vars kts
                                                      (if (symbol? t)
                                                          (impc:ti:symbol-check t vars kts #f)
                                                          t))))
                         ;; if t is a symbol then add res to t
                         (if (symbol? t)
                             (if (or (and (list? res)
                                          (impc:ir:type? (car res)))
                                     (impc:ir:type? res))
                                 (impc:ti:force-var t vars kts res)
                                 (impc:ti:update-var t vars kts res)))
                         res))
                     (cddr ast)
                     (if (<> (length (cddr ctype))
                             (length (cddr ast)))
                         (impc:compiler:print-bad-arity-error ast)
                         (cddr ctype)))))
      (cadr ctype))))



;; for fptrcall
;; which has the form
;; (fptrcall fptr ... args)
(define impc:ti:fptrcall-check
  (lambda (ast vars kts request?)
    (let* ((fptr (impc:ti:type-check (cadr ast) vars kts #f)))
      (if (null? fptr)
          (list)
          (let* ((ctype (if (impc:ir:closure? (car fptr))
                            (car fptr)
                            (impc:compiler:print-bad-type-error (car fptr) "bad fptr type in fptrcall")))
                 (res (map (lambda (e t)
                             ;;(println 'e: e 't: t)
                             (let ((res (impc:ti:type-check e vars kts
                                                            (if (symbol? t)
                                                                (impc:ti:symbol-check t vars kts #f)
                                                                t))))
                               ;; if t is a symbol then add res to t
                               (if (symbol? t)
                                   (if (or (and (list? res)
                                                (impc:ir:type? (car res)))
                                           (impc:ir:type? res))
                                       (impc:ti:force-var t vars kts res)
                                       (impc:ti:update-var t vars kts res)))
                               res))
                           (cddr ast)
                           (if (<> (length (cddr ctype))
                                   (length (cddr ast)))
                               (impc:compiler:print-bad-arity-error ast)
                               (cddr ctype)))))
            (cadr ctype))))))




(define impc:ti:dotimes-check
  (lambda (ast vars kts request?)
    (let ((a (impc:ti:type-check (cadr (cadr ast)) vars kts
                                 (cl:sort (list *impc:ir:fp64* *impc:ir:fp32*
                                                *impc:ir:si64* *impc:ir:si32* *impc:ir:si16* *impc:ir:ui8*) <))))
      ;; if numeric? and multiple choice - then force a type!
      (if (number? (cadr (cadr ast)))
          (cond ((equal? (cl:sort a <)
                         (cl:sort (list *impc:ir:fp64* *impc:ir:fp32* *impc:ir:si64* *impc:ir:si32* *impc:ir:si16* *impc:ir:ui8*) <))
                 (set! a (list *impc:ir:si64*)))
                ((equal? (cl:sort a <)
                         (cl:sort (list *impc:ir:fp64* *impc:ir:fp32*) <))
                 (set! a (list *impc:ir:fp64*)))
                (else 'leave-a-alone)))
      ;; (car (cadr ast)) should be a symbol that we want to update with a
      (if (not (symbol? (car (cadr ast))))
          (impc:compiler:print-badly-formed-expression-error 'dotimes ast))
      (impc:ti:update-var (car (cadr ast)) vars kts a)
      ;; stretch over body code but don't worry about return types
      (impc:ti:type-check (caddr ast) vars kts #f)
      ;; dotimes returns void
      (list *impc:ir:void*))))

(define impc:ti:while-check
  (lambda (ast vars kts request?)
    (let ((type (impc:ti:type-check (cadr ast) vars kts #f))
          (body (impc:ti:type-check (caddr ast) vars kts #f)))
      (if (not (or (and (number? type) (= type *impc:ir:i1*))
                   (= (car type) *impc:ir:i1*)
                   (null? type)))
          (impc:compiler:print-bad-type-error (car type) "test expression in while loop must return a boolean"))
      (list *impc:ir:void*))))

(define impc:ti:printf-check
  (lambda (ast vars kts request?)
    (let ((a (impc:ti:type-check (cadr ast) vars kts (list (+ *impc:ir:si8* *impc:ir:pointer*)))))
      ;; run through everything else for completeness but don't care about the results
      (for-each (lambda (x) (impc:ti:type-check x vars kts #f)) (cddr ast))
      ;; printf returns i32
      (list *impc:ir:si32*))))

(define impc:ti:fprintf-check
  (lambda (ast vars kts request?)
    (let ((a (impc:ti:type-check (cadr ast) vars kts (list (+ *impc:ir:si8* *impc:ir:pointer*))))
          (b (impc:ti:type-check (cadr ast) vars kts (list (+ *impc:ir:si8* *impc:ir:pointer*)))))
      ;; run through everything else for completeness but don't care about the results
      (for-each (lambda (x) (impc:ti:type-check x vars kts #f)) (cdddr ast))
      ;; printf returns i32
      (list *impc:ir:si32*))))

(define impc:ti:sprintf-check
  (lambda (ast vars kts request?)
    (let ((a (impc:ti:type-check (cadr ast) vars kts (list (+ *impc:ir:si8* *impc:ir:pointer*))))
          (b (impc:ti:type-check (caddr ast) vars kts (list (+ *impc:ir:si8* *impc:ir:pointer*)))))
      ;; run through everything else for completeness but don't care about the results
      (for-each (lambda (x) (impc:ti:type-check x vars kts #f)) (cdddr ast))
      ;; printf returns i32
      (list *impc:ir:si32*))))

(define impc:ti:sscanf-check
  (lambda (ast vars kts request?)
    (let ((a (impc:ti:type-check (cadr ast) vars kts (list (+ *impc:ir:si8* *impc:ir:pointer*))))
          (b (impc:ti:type-check (cadr ast) vars kts (list (+ *impc:ir:si8* *impc:ir:pointer*)))))
      ;; run through everything else for completeness but don't care about the results
      (for-each (lambda (x) (impc:ti:type-check x vars kts #f)) (cdddr ast))
      ;; printf returns i32
      (list *impc:ir:si32*))))

(define impc:ti:fscanf-check
  (lambda (ast vars kts request?)
    (let ((a (impc:ti:type-check (cadr ast) vars kts (list (+ *impc:ir:si8* *impc:ir:pointer*))))
          (b (impc:ti:type-check (caddr ast) vars kts (list (+ *impc:ir:si8* *impc:ir:pointer*)))))
      ;; run through everything else for completeness but don't care about the results
      (for-each (lambda (x) (impc:ti:type-check x vars kts #f)) (cdddr ast))
      ;; printf returns i32
      (list *impc:ir:si32*))))

(define impc:ti:string-check
  (lambda (ast vars kts request?)
    (if (string? ast)
        (list (+ *impc:ir:si8* *impc:ir:pointer*))
        '())))

(define impc:ti:carcdr-check
  (lambda (ast vars kts request?)
    ;; check that we are getter a pair as an argument
    (impc:ti:type-check (cadr ast) vars kts (list (impc:ir:pointer++ *impc:ir:pair*)))
    ;; don't do anything about return type yet
    '()))

(define impc:ti:coerce-check
  (lambda (ast vars kts request?)
    (impc:ti:type-check (cadr ast) vars kts #f)
    (list (caddr ast))))

(define impc:ti:closure-in-first-position
  (lambda (ast vars kts request?)
    ;; first check return type of car ast (which will be a closure)
    ;; then check against it's arg types
    (let ((type (impc:ti:type-check (car ast) vars kts request?)))
      (if (null? type)
          (impc:compiler:print-bad-type-error "unknown-type" ast))
      (if (not (impc:ir:type? type))
          (set! type (car type)))
      (if (not (list? type))
          (impc:compiler:print-bad-type-error (impc:ir:pretty-print-type type) ast))
      (if (<> (length (cddr type)) (length (cdr ast)))
          (impc:compiler:print-bad-arity-error ast))
      (if (<> (+ *impc:ir:closure* *impc:ir:pointer* *impc:ir:pointer*) (car type))
          (impc:compiler:print-bad-type-error (impc:ir:pretty-print-type (car type)) ast)
          (begin (map (lambda (a b)
                        (impc:ti:type-check b vars kts a))
                      (cddr type)
                      (cdr ast))
                 (cadr type))))))

;; vars is statefull and will be modified in place
(define impc:ti:type-check
  (lambda (ast vars kts request?)
    ;; (println 'tc: ast 'vars: vars)
    ;; (println 'type-check: ast  'vars: vars  'kts: kts 'request? request?)
    (if *impc:ti:print-main-check* (println 'type-check: ast 'kts: kts 'request? request?))
    (if *impc:ti:print-main-check* (println 'vars------: vars))
    (cond ((null? ast) '())
          ((and (atom? ast) (number? ast)) (impc:ti:numeric-check ast vars kts request?))
          ((and (atom? ast) (symbol? ast)) (impc:ti:symbol-check ast vars kts request?)) ;#f)) ;request?))
          ((and (atom? ast) (string? ast)) (impc:ti:string-check ast vars kts request?))
          ((atom? ast) (impc:compiler:print-compiler-error "internal error unhandled atom" ast))
          ((and (list? ast) (member (car ast) *impc:letslist*)) (impc:ti:let-check ast vars kts request?))
          ((and (list? ast) (member (car ast) *impc:lambdaslist*)) (impc:ti:lambda-check ast vars kts request?))
          ((and (list? ast) (member (car ast)
                                    *impc:mathbinaryaritylist*))
           ;; '(* / + - % modulo bitwise-and bitwise-or bitwise-eor bitwise-shift-left bitwise-shift-right bitwise-not)))
           (let ((r (impc:ti:math-check ast vars kts request?)))
             (if (impc:ir:tuple? r)
                 (begin ;; this is very dodgy!
                   (set! *unique-polynum* (+ 1 *unique-polynum*))
                   (let ((m (string->symbol (string-append (cond ((eq? (car ast) '*) "xtm_multiplication##")
                                                                 ((eq? (car ast) '+) "xtm_addition##")
                                                                 ((eq? (car ast) '/) "xtm_division##")
                                                                 ((eq? (car ast) '-) "xtm_subtraction##")
                                                                 ((eq? (car ast) '%) "xtm_modulo##")
                                                                 (else (print-error "Error in math overloading")))
                                                           (number->string *unique-polynum*)))))
                     (insert-at-index 1 vars (list m))
                     (set-car! ast m)
                     (set! r (impc:ti:type-check ast vars kts request?)))))
             r))
          ((and (list? ast) (member (car ast) '(< > = <>)))
           (let ((r (impc:ti:compare-check ast vars kts request?)))
             (if (impc:ir:tuple? r)
                 (begin ;; this is very dodgy!
                   (set! *unique-polynum* (+ 1 *unique-polynum*))
                   (let ((m (string->symbol (string-append (cond ((eq? (car ast) '<) "xtm_lessthan##")
                                                                 ((eq? (car ast) '>) "xtm_greaterthan##")
                                                                 ((eq? (car ast) '=) "xtm_equal##")
                                                                 ((eq? (car ast) '<>) "xtm_notequal##")
                                                                 (else (print-error "Error in math overloading")))
                                                           (number->string *unique-polynum*)))))
                     (insert-at-index 1 vars (list m))
                     (set-car! ast m)
                     (set! r (impc:ti:type-check ast vars kts request?)))))
             *impc:ir:i1*))
          ((and (list? ast) (member (car ast) *impc:mathintrinsicslist*)) (impc:ti:math-intrinsic-check ast vars kts request?))
          ((and (list? ast) (member (car ast) '(dotimes))) (impc:ti:dotimes-check ast vars kts request?))
          ((and (list? ast) (member (car ast) '(while))) (impc:ti:while-check ast vars kts request?))
          ((and (list? ast) (member (car ast) '(llvm_printf))) (impc:ti:printf-check ast vars kts request?))
          ((and (list? ast) (member (car ast) '(llvm_sprintf))) (impc:ti:sprintf-check ast vars kts request?))
          ((and (list? ast) (member (car ast) '(llvm_fprintf))) (impc:ti:fprintf-check ast vars kts request?))
          ((and (list? ast) (member (car ast) '(llvm_sscanf))) (impc:ti:sscanf-check ast vars kts request?))
          ((and (list? ast) (member (car ast) '(llvm_fscanf))) (impc:ti:fscanf-check ast vars kts request?))
          ((and (list? ast) (member (car ast) '(push_zone))) (impc:ti:push_zone-check ast vars kts request?))
          ((and (list? ast) (member (car ast) '(pop_zone))) (impc:ti:pop_zone-check ast vars kts request?))
          ((and (list? ast) (member (car ast) '(push_new_zone))) (impc:ti:push_new_zone-check ast vars kts request?))
          ((and (list? ast) (member (car ast) '(create_zone))) (impc:ti:create_zone-check ast vars kts request?))
          ;;((and (list? ast) (member (car ast) '(memzone))) (impc:ti:memzone-check ast vars kts request?))
          ((and (list? ast) (member (car ast) '(llvm_callback))) (impc:ti:callback-check ast vars kts request?))
                                        ;((and (list? ast) (member (car ast) '(make-array))) (impc:ti:make-array-check ast vars kts request?))
          ((and (list? ast) (member (car ast) '(vector-set!))) (impc:ti:vector-set-check ast vars kts request?))
          ((and (list? ast) (member (car ast) '(vector-ref))) (impc:ti:vector-ref-check ast vars kts request?))
          ((and (list? ast) (member (car ast) '(vector-shuffle))) (impc:ti:vector-shuffle-check ast vars kts request?))
          ((and (list? ast) (member (car ast) '(array-set!))) (impc:ti:array-set-check ast vars kts request?))
          ((and (list? ast) (member (car ast) '(array-ref))) (impc:ti:array-ref-check ast vars kts request?))
          ((and (list? ast) (member (car ast) '(array-ref-ptr))) (impc:ti:array-ref-ptr-check ast vars kts request?))
          ((and (list? ast) (member (car ast) '(pointer-set!))) (impc:ti:pointer-set-check ast vars kts request?))
          ((and (list? ast) (member (car ast) '(pointer-ref))) (impc:ti:pointer-ref-check ast vars kts request?))
          ((and (list? ast) (member (car ast) '(pointer-ref-ptr))) (impc:ti:pointer-ref-ptr-check ast vars kts request?))
          ((and (list? ast) (member (car ast) '(stack-alloc))) (impc:ti:stack-alloc-check ast vars kts request?))
          ((and (list? ast) (member (car ast) '(heap-alloc))) (impc:ti:heap-alloc-check ast vars kts request?))
          ((and (list? ast) (member (car ast) '(zone-alloc))) (impc:ti:zone-alloc-check ast vars kts request?))
                                        ;((and (list? ast) (member (car ast) '(make-tuple))) (impc:ti:make-tuple-check ast vars kts request?))
          ((and (list? ast) (member (car ast) '(tuple-set!))) (impc:ti:tuple-set-check ast vars kts request?))
          ((and (list? ast) (member (car ast) '(tuple-ref))) (impc:ti:tuple-ref-check ast vars kts request?))
          ((and (list? ast) (member (car ast) '(tuple-ref-ptr))) (impc:ti:tuple-ref-ptr-check ast vars kts request?))
          ((and (list? ast) (member (car ast) '(closure-set!))) (impc:ti:closure-set-check ast vars kts request?))
          ((and (list? ast) (member (car ast) '(closure-ref))) (impc:ti:closure-ref-check ast vars kts request?))
          ((and (list? ast) (member (car ast) '(closure-refcheck))) (impc:ti:closure-refcheck-check ast vars kts request?))
          ((and (list? ast) (member (car ast) '(pref))) (impc:ti:pref-check ast vars kts request?))
          ((and (list? ast) (member (car ast) '(pdref))) (impc:ti:pdref-check ast vars kts request?))
          ((and (list? ast) (member (car ast) '(null?))) (impc:ti:null?-check ast vars kts request?))
          ((and (list? ast) (member (car ast) '(impc_null))) (impc:ti:null-check ast vars kts request?))
          ((and (list? ast) (member (car ast) '(bitcast))) (impc:ti:bitcast-check ast vars kts request?))
          ((and (list? ast) (member (car ast) '(bitconvert))) (impc:ti:bitconvert-check ast vars kts request?))
          ((and (list? ast) (member (car ast) '(void))) (impc:ti:void-check ast vars kts request?))
          ((and (list? ast) (member (car ast) '(fptrcall))) (impc:ti:fptrcall-check ast vars kts request?))
          ((and (list? ast) ;; generic function
                (symbol? (car ast))
                (regex:match? (symbol->string (car ast)) "##") ;"\\$\\$\\$")
                (impc:ir:gpoly-exists? (string->symbol (car (regex:split (symbol->string (car ast)) "##"))))) ;"\\$\\$\\$")))))
                                        ;(println 'generic (car ast))
           (impc:ti:nativef-generics ast vars kts request?))
          ((and (list? ast) ;; polymorphic function
                (symbol? (car ast))
                (regex:match? (symbol->string (car ast)) "##") ;"\\$\\$\\$")
                (impc:ir:poly-types (string->symbol (car (regex:split (symbol->string (car ast)) "##"))))) ;"\\$\\$\\$")))))
           (let ((reses (impc:ti:nativef-poly-check ast vars kts request?)))
                                        ;(println 'ast: ast reses)
             reses))
          ((and (list? ast) ;; native function
                (symbol? (car ast))
                (impc:ti:nativefunc-exists? (symbol->string (car ast))))
           (impc:ti:nativef-check ast vars kts request?))
          ((and (list? ast) (member (car ast) '(begin))) (impc:ti:begin-check ast vars kts request?))
          ((and (list? ast) (member (car ast) '(if ifret))) (impc:ti:if-check ast vars kts request?))
          ((and (list? ast) (member (car ast) '(set!))) (impc:ti:set-check ast vars kts request?))
          ((and (list? ast) (member (car ast) '(ret->))) (impc:ti:ret-check ast vars kts request?))
          ((and (list? ast) (assoc-strcmp (car ast) vars)) (impc:ti:closure-call-check ast vars kts request?))
          ((and (list? ast) (list? (car ast))) (impc:ti:closure-in-first-position ast vars kts request?))
          ((and (list? ast) ;; this is here to check against closures as global vars (i.e. not in local environment)
                (symbol? (car ast))
                (impc:ti:closure-exists? (symbol->string (car ast))))
           (impc:ti:closure-call-check ast vars kts request?))
          (else
           (println 'here)
           (impc:ti:join (impc:ti:type-check (car ast) vars kts request?)
                         (impc:ti:type-check (cdr ast) vars kts request?))))))


(define impc:ti:find-unresolved-simple-types
  (lambda (union)
    (let ((unresolved (cl:remove #f (map (lambda (x) ;; return the first bad variable that is not a closure
                                           (if (null? (cdr x)) #f
                                               (if (and (list? (cdr x)) ;; check there are multiple choices
                                                        (number? (cadr x))
                                                        (not (member (modulo (cadr x) *impc:ir:pointer*)
                                                                     (list *impc:ir:tuple* *impc:ir:closure* *impc:ir:array* *impc:ir:vector*))) ;; make sure it's a base type (not closure or tuple)
                                                        (cl:every impc:ir:type? (cdr x))) ;; check that it's choices are valid (not null)
                                                   x #f)))
                                         union))))
      (if (null? unresolved) #f
          unresolved))))


(define impc:ti:remove-single-element-lists
  (lambda (l)
    (map (lambda (k)
           ;; (println 'k k)
           (if (list? k)
               (if (= (length k) 1)
                   (car k)
                   (impc:ti:remove-single-element-lists k))
               k))
         l)))


(define impc:ti:clean-fvars
  (lambda (vars)
    ;; (println 'cleaning: vars)
    ;; first remove all single element lists
    (map (lambda (v)
           (set-cdr! v (impc:ti:remove-single-element-lists (cdr v))))
         vars)
    ;; (println 'vars2: vars)
    vars))





(define *type-check-continuation* '())

(define impc:ti:run-type-check
  (lambda (vars forced-types ast)
    ;; (println '------------------------------------)
    ;; (println 'forced-types forced-types)
    ;; (println 'vars: vars)
    ;; (println 'run-type-check 'ast: ast)
    (let ((typelist (call/cc (lambda (k) (set! *type-check-continuation* k) '()))))
      (if (null? typelist)
          (set! typelist (impc:ti:run-type-check* vars forced-types ast)))
      ;; (println 'unified 'types: typelist)
      typelist)))


;; run the type checker
;; if we fail to unify completely the first time
;; try some possible substitutions!
(define impc:ti:run-type-check*
  (lambda (vars forced-types ast . cnt)
    ;; (println '------------------------------------)
    ;; (println 'forced-types forced-types)
    ;; (println 'vars: vars)
    ;; (println 'run-type-check 'ast: ast)
                                        ;(if (null? cnt) (sys:clear-log-view))
    (let* ((fvars (map (lambda (t) ;; add any forced-type values to vars
                         (if (assoc-strcmp (car t) forced-types)
                             (let ((tt (cdr (assoc-strcmp (car t) forced-types))))
                               (cons (car t) (list tt)))
                             t))
                       vars))
           ;; (lll (println 'vars1: vars))
           (kts (map (lambda (x) (car x)) forced-types)) ;; just need symbols from forced-types
           ;; fvars gets modified 'in place' during this next
           ;; operation
           (ret (impc:ti:type-check ast fvars kts #f))
           ;; (llllllll (println 'pre-unified-vars: fvars))
           (u (impc:ti:unify fvars))
           ;; (lllll (println 'post-unified-vars: u))
           (t (impc:ti:unity? u))
           ;; (lllllll (println (println 'cccccc)))
           (tt (cl:every (lambda (x) x) t))
           (a (if tt #t
                  (impc:ti:find-unresolved-simple-types u))))
                                        ;(println 'fvars: fvars)
                                        ;(println 'types: u)
      (if *impc:ti:print-unifications* (println 'tirun:> a '-> u))
      ;; if we have unified types then return them through continuation
      (if (or tt
              (and (not (null? cnt))
                   (list? (car cnt))
                   (member u (car cnt))))
          (*type-check-continuation* u))
      (cond ((and (not (null? cnt))
                  (eq? #f (car cnt)))
             u)
            ((not a) ;; this run is for generics
             (impc:ti:clear-all-vars fvars)
             (let* ((ret (impc:ti:run-type-check* fvars
                                                  ;; kts for all solved types
                                                  (cl:remove #f (map (lambda (k)
                                                                       (if (impc:ir:type? (cdr k)) k #f))
                                                                     u))
                                                  ast (cons u (if (null? cnt) cnt (car cnt))))))
               ret))
            (else ;; (println 'bingo2: a)
             (let ((res (map (lambda (x) ;; call run-type-check for each version of a simple type
                               ;; first clear vars
                               (impc:ti:clear-all-vars fvars)
                               (impc:ti:run-type-check* fvars
                                                        ;; as well as all simple types which have resolved fully
                                                        (append (cl:remove-if-not (lambda (z) (and (not (list? z))
                                                                                              (pair? z))) u)
                                                                ;; and any simple types that unify on x
                                                                (cl:remove 'failed
                                                                           (map (lambda (k)
                                                                                  (if (null? (cl:intersection (list x) (cdr k)))
                                                                                      'failed
                                                                                      (cons (car k) x)))
                                                                                (impc:ti:find-unresolved-simple-types u)))
                                                                forced-types)
                                                        ast #f))
                             ;; ast (cons u (if (null? cnt) cnt (car cnt)))))
                             (cdr (car a)))))
               ;; then see what versions might be OK?
               (let* ((rr (map (lambda (y)
                                 (cl:remove-if (lambda (x)
                                                 (regex:match? (symbol->string (car x)) "^!" ))
                                               y))
                               res))
                      (r (cl:find-if (lambda (x)
                                       (cl:every (lambda (x) x) (impc:ti:unity? x)))
                                     rr)))
                 (if (not r) ;; if no options are any good then :(
                     (impc:compiler:print-could-not-resolve-type-error
                      (map (lambda (x) (symbol->string (car x)))
                           (cl:remove-if (lambda (x)
                                           (impc:ir:type? (cdr x)))
                                         (car res)))))
                 r)))))))


;;
;;
;; Other utility code
;;
;;

;; add types to source
;; also add clrun for closure application
;; and inject polymorphic functions
(define impc:ti:add-types-to-source
  (lambda (symname ast types envvars . prev)
    ;; (println 'symname: symname)
    ;; (println 'ast: ast)
    ;; (println 'envvars: envvars 'prev: prev)
    (if (atom? ast) ;; ast
        (if (and (symbol? ast)
                 (regex:match? (symbol->string ast) ":"))
            (let* ((p (regex:type-split (symbol->string ast) ":"))
                   (ptrs (impc:ir:get-ptr-depth ast))
                   (poly? (impc:ir:gpoly-exists? (string->symbol (car p))))
                   (etype (cname-encode (cadr p))))
              (if poly?
                  (begin
                    (if (not (llvm:get-function (string-append (car p) "_poly_" etype)))
                        (let* ((arity (- (length (impc:ir:get-pretty-closure-arg-strings (cadr p))) 1))
                               (ptypes (impc:ir:gpoly-types (string->symbol (car p)) arity (cadr p)))
                               (tmp (if (not ptypes)
                                        (impc:compiler:print-bad-arity-error ast)))
                               (code (caddr (cadr (impc:ir:gpoly-types (string->symbol (car p)) arity (cadr p)))))
                               (pfunc (string->symbol (string-append (car p) "_poly_" etype))))
                          (set! code `(let ((,pfunc ,code)) ,pfunc))
                          (impc:ti:run pfunc code *impc:default-zone-size* (cons pfunc (string->symbol (cadr p))))
                          (impc:ir:add-poly (string->symbol (car p)) pfunc (cadr p))
                          (let ((setter (llvm:get-function (string-append (symbol->string pfunc) "_setter"))))
                            (sys:push-memzone (sys:create-mzone *impc:default-zone-size*))
                            (llvm:run setter (sys:peek-memzone)) ;; (sys:create-mzone *impc:default-zone-size*))
                            (sys:pop-memzone)) ;; don't destroy - this happens in _setter func
                          pfunc))
                    (begin ;; (println 'here!)
                      (string->symbol (string-append (car p) "_poly_" etype))))
                  (impc:compiler:print-missing-identifier-error ast 'variable)))
            ast)
        (cond ((member (car ast) '(__make-closure __make-closure-s __make-closure-h __make-closure-z))
		 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
               ;; these lines just added by AS
               (if (and (null? (cdr prev))
                        (list? (car prev)))
                   (set! prev (car prev)))
               ;; can safely be removed
		 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
               (list (car ast)
                     (cadr ast)
                     ;; global name
                     (string-append (symbol->string symname) "__" (number->string (llvm:count++)))
                     (if (or (null? prev) ;; this adds return type
                             (null? (cdr (assoc-strcmp (car prev) types))))
                         *impc:ir:other*
                         (caddr (assoc-strcmp (car prev) types)))
                     (map (lambda (v) ;; environment types
                            (if (member v envvars)
                                (let ((p (assoc-strcmp v types)))
                                  (cons (string->symbol (string-append (symbol->string (car p)) "__sub"))
                                        (cdr p)))
                                (assoc-strcmp v types)))
                          (cons symname (caddr ast)))
                     (map (lambda (v) ;; argument types
                            (assoc-strcmp v types))
                          (cadddr ast))
                     (impc:ti:add-types-to-source symname (car (cddddr ast)) types (append envvars (caddr ast)))))
              ((equal? (car ast) 'clrun->)
               (list* (car ast)
                      (cadr ast)
                      (map (lambda (arg type)
                                        ;(print 'clrunargs-> arg type)
                             (let ((a (impc:ti:add-types-to-source symname arg types envvars ast)))
                               (if (null? type)
                                   (impc:compiler:print-could-not-resolve-type-error
                                    (symbol->string (cadr ast)))
                                   a)))
                           (cddr ast)
                           (cdddr (if (not (assoc-strcmp (cadr ast) types)) ;; if not in local env then get types from global var
                                      (cons (cadr ast) (impc:ti:get-globalvar-type (symbol->string (cadr ast))))
                                      (assoc-strcmp (cadr ast) types))))))

              ;; inject (and potential compile) generic functions
              ;; do generic functions before polys
              ((and (symbol? (car ast))
                    (regex:match? (symbol->string (car ast)) "##") ;"\\$\\$\\$")
                    (impc:ir:gpoly-exists? (string->symbol (car (regex:split (symbol->string (car ast)) "##")))))
               ;; (println 'types types)
               ;; (println 'gpoly: (car ast))
               ;; (println 'gpoly: (impc:ir:gpoly-types (string->symbol (car (regex:split (symbol->string (car ast)) "\\$\\$\\$")))))
               ;; (println 'compile 'generic? ast)
               ;; (println 'types types)
               (if (null? (cdr (assoc-strcmp (car ast) types)))
                   (impc:compiler:print-could-not-resolve-generic-type-error types ast))

               (let* ((polyname (string->symbol (car (regex:split (symbol->string (car ast)) "##")))) ;"\\$\\$\\$"))))
                      (type (if (null? (cdr (assoc-strcmp (car ast) types)))
                                (impc:compiler:print-could-not-resolve-type-error (car ast))
                                (impc:ir:pretty-print-type (cdr (assoc-strcmp (car ast) types)))))
                      (cname (cname-encode type))
                      (symp (regex:type-split (symbol->string symname) "_poly_"))
                      (symcname (if (null? (cdr symp)) "" (cadr symp)))
                      (arity (- (length (impc:ir:get-pretty-closure-arg-strings type)) 1))
                      (code (caddr (cadr (impc:ir:gpoly-types polyname arity type))))
                                        ;(lllll (println 'actual-code (caddr (cadr (impc:ir:gpoly-types polyname)))))
                      (exists (if (string=? type "") #f (impc:ir:check-poly polyname type))))
                 ;; (println 'polyname: polyname 'type: type 'exists: exists 'changed: (impc:ir:gpoly-src-changed polyname arity))
                 ;; (impc:ir:gpoly-src-changed polyname arity))
                 ;; (println 'p: (car ast) 'exists: exists 'changed: (impc:ir:gpoly-src-changed polyname arity))
                 (if (or (if exists
                             (if (and (regex:match? (symbol->string exists) "_poly_")
                                      (impc:ir:gpoly-src-changed polyname arity))
                                 #f
                                 #t)
                             #f)
                         (and (string=? (car (regex:split (symbol->string (car ast)) "##"))
                                        (car (regex:split (symbol->string symname) "_poly_")))
                              (string=? cname symcname)))
                     (if (and (string=? (car (regex:split (symbol->string (car ast)) "##"))
                                        (car (regex:split (symbol->string symname) "_poly_")))
                              (string=? cname symcname))
                         (begin ;; (println 'resursivepoly)
                           (cons 'clrun-> (cons symname
                                                (map (lambda (jj)
                                                       (impc:ti:add-types-to-source symname jj types envvars ast))
                                                     (cdr ast)))))
                         (begin ;; (println 'polyexists)
                           (cons exists
                                 (map (lambda (jj)
                                        (impc:ti:add-types-to-source symname jj types envvars ast))
                                      (cdr ast)))))
                     (let ((pfunc (string->symbol (string-append (car (regex:split (symbol->string (car ast)) "##")) "_poly_" (cname-encode type)))))
                       ;; (println 'pfund: pfunc)
                       (impc:ir:gpoly-src-compiled polyname arity)
                       (set! code `(let ((,pfunc ,code)) ,pfunc))
                                        ;(print)
                       ;; (println 'pfunc: pfunc 'type: type 'code: code)
                       ;; (println 'kts: (cons pfunc (string->symbol type)))
                                        ;(print)
                       (impc:ti:run pfunc code *impc:default-zone-size* (cons pfunc (string->symbol type)))
                       (impc:ir:add-poly polyname pfunc type)
                       (let ((setter (llvm:get-function (string-append (symbol->string pfunc) "_setter"))))
                         (sys:push-memzone (sys:create-mzone *impc:default-zone-size*))
                         (llvm:run setter (sys:peek-memzone)) ;; (sys:create-mzone *impc:default-zone-size*))
                         (sys:pop-memzone) ;; don't destroy - this happens in _setter func
                         )
                       (cons pfunc
                             (map (lambda (jj)
                                    (impc:ti:add-types-to-source symname jj types envvars ast))
                                  (cdr ast)))))))
              ;; inject polymorphic functions
              ((and (symbol? (car ast))
                    (regex:match? (symbol->string (car ast)) "##")) ;"\\$\\$\\$"))
               (let* ((pname (string->symbol (car (regex:split (symbol->string (car ast)) "##")))) ;"\\$\\$\\$"))))
                      (type (cdr (assoc-strcmp (car ast) types)))
                      (polyname (impc:ir:check-poly pname type)))
                 (cons polyname
                       (map (lambda (jj)
                              (impc:ti:add-types-to-source symname jj types envvars ast))
                            (cdr ast)))))
              ;; environments
              ((member (car ast) '(__make-env __make-env-zone))
               (list (car ast)
                     (cadr ast)
                     (map (lambda (p)
                            (list (assoc-strcmp (car p) types)
                                  (impc:ti:add-types-to-source symname (cadr p) types envvars (car p))))
                          (caddr ast))
                     (impc:ti:add-types-to-source symname (cadddr ast) types envvars)))
              ((or (and (assoc-strcmp (car ast) types)
                        ;; (if (null? prev) #t
                        ;;     (not (member (car ast) (car prev))))
                        (impc:ir:closure? (cdr (assoc-strcmp (car ast) types))))
                   (and (not (list? (car ast)))
                        (symbol? (car ast))
                        ;; (if (null? prev) #t
                        ;;     (not (member (car ast) (car prev))))
                        (impc:ti:closure-exists? (symbol->string (car ast)))))
               (impc:ti:add-types-to-source symname (cons 'clrun-> ast) types envvars))
              ((list? ast)
               (map (lambda (x)
                      (impc:ti:add-types-to-source symname x types envvars ast))
                    ast))
              (else (cons (apply impc:ti:add-types-to-source symname (car ast) types envvars)
                          (apply impc:ti:add-types-to-source symname (cdr ast) types envvars)))))))


;; this is uggglly and needs to be redone!!!!!!!
;; adds ret tags
(define impc:ti:mark-returns
  (lambda (ast name in-body? last-pair? blocked?)
    (cond ((atom? ast)
           (if (and in-body? last-pair?)
               (if blocked? ast (list 'ret-> name ast))
               ast))
          ((pair? ast)
           (cond ((equal? (car ast) 'if)
                  ;; if statement need special syntax adjustments for returns
                  (append (if blocked? (list 'if) (list 'ifret)) (list (cadr ast))
                          (list (impc:ti:mark-returns (caddr ast) name in-body? last-pair? blocked?))
                          (if (not (null? (cdddr ast)))
                              (list (impc:ti:mark-returns (cadddr ast) name in-body? last-pair? blocked?)))))
                 ((member (car ast) *impc:letslist*)
                  (append (list (car ast))
                          (list (map (lambda (a)
                                       ;; let assigns always block (lambda can override but nothing else)
                                       (list (car a) (impc:ti:mark-returns (cadr a) (car a) #f #f #t)))
                                     (cadr ast)))
                          (impc:ti:mark-returns (cddr ast) name #t #f blocked?)))
                 ((member (car ast) *impc:lambdaslist*)
                  (append (list (car ast)) (list (cadr ast))
                          ;; lambda always unblocks because lambdas always need a return
                          (impc:ti:mark-returns (cddr ast) name #t #f #f)))
                                        ;((equal? (car ast) 'dotimes)
                                        ; (append '(dotimes) (list (cadr ast)) (impc:ti:mark-returns (cddr ast) name #t #f blocked?)))
                 ((equal? (car ast) 'begin)
                  (if (null? (cdr ast))
                      (impc:compiler:print-no-retval-error ast))
                  (let* ((rev (reverse (cdr ast)))
                         (last (car rev))
                         (rest (reverse (cdr rev)))
                         (newast (append '(begin)
                                         (append (map (lambda (a)
                                                        ;; block everything except ...
                                                        (impc:ti:mark-returns a name in-body? #f #t))
                                                      rest)
                                                 ;; the last one which we let through
                                                 ;; ONLY if it hasn't been blocked higher up!
                                                 (list (impc:ti:mark-returns last name in-body?
                                                                             (if blocked? #f #t)
                                                                             blocked?))))))
                    newast))
                 ((equal? (car ast) 'begin)
                  (append '(begin) (impc:ti:mark-returns (cdr ast) name in-body? #f blocked?)))
                 ((and in-body? last-pair? (not blocked?)) ;; if everything is good add a return!
                  (list 'ret-> name (cons (car ast) (impc:ti:mark-returns (cdr ast) name in-body? #f #t))))
                                        ;(list 'ret-> name ast))
                 (else (cons (impc:ti:mark-returns (car ast) name in-body? #f blocked?)
                             (impc:ti:mark-returns (cdr ast) name in-body? #f blocked?))))))))


;; this is a dodgy flatten :(
(define impc:ti:flatten-1
  (lambda (lst)
    (cond ((null? lst) '())
          ((list? (car lst))
           (append (car lst) (impc:ti:flatten-1 (cdr lst))))
          (else (list lst)))))



;; (define impc:ti:find-all-vars
;;    (lambda (full-ast syms)
;;      (letrec ((f (lambda (ast)
;; 		   ;; (println 'ast: ast)
;; 		   (cond ((pair? ast)
;; 			  (cond ((and (symbol? (car ast)) ;; this for generics
;; 				      (regex:match? (symbol->string (car ast)) "##") ;"\\$\\$\\$")
;; 				      (impc:ir:gpoly-types (string->symbol (car (regex:split (symbol->string (car ast)) "##")))))
;; 				 ;; (println 'generics ast (regex:split (symbol->string (car ast)) "(\\$\\$\\$)|(_poly_)"))
;; 				 (let* ((gname (string->symbol (car (regex:split (symbol->string (car ast)) "(##)|(_poly_)"))))
;;                                         (gnum (string->number (cadr (regex:split (symbol->string (car ast)) "(##)|(_poly_)"))))
;;                                         (typestrs (cl:remove-duplicates (impc:ir:get-pretty-closure-arg-strings (symbol->string (car (impc:ir:gpoly-types gname))))))
;;                                         (types (map (lambda (x) (impc:ir:get-type-from-pretty-str x)) typestrs))
;;                                         (newsyms (cl:remove-duplicates
;;                                                   (map (lambda (a b)
;;                                                          (if (or (impc:ir:type? b)
;;                                                                  (not (impc:ir:tuple? b)))
;;                                                              #f
;;                                                              (if (regex:match? a ":")
;;                                                                  (string->symbol (string-append a "##" (number->string gnum)))
;;                                                                  (string->symbol (string-append (impc:ir:get-base-type a)
;;                                                                                                 ":"
;;                                                                                                 (impc:ir:pretty-print-type b)
;;                                                                                                 "##" (number->string gnum))))))
;;                                                        typestrs types)))
;;                                         (gvars
;;                                          (cl:remove-duplicates
;;                                           (cl:remove-if-not (lambda (x)
;;                                                               (and (symbol? x) (regex:match? (symbol->string x) "^!")))
;;                                                             (flatten types))))
;;                                         (newsyms_gvars (map (lambda (k)
;;                                                               (string->symbol (string-append (symbol->string k) "##" (number->string gnum))))
;;                                                             gvars)))
;;                                    (set! syms (append syms (list (car ast)) (cl:remove #f (cl:remove-duplicates (append newsyms newsyms_gvars)))))
;;                                    ;; (println 'newsyms: syms)
;;                                    (f (cdr ast))))
;; 				((and (symbol? (car ast)) ;; this for polys
;; 				      (regex:match? (symbol->string (car ast)) "##") ;"\\$\\$\\$")
;; 				      (impc:ir:poly-types (string->symbol (car (regex:split (symbol->string (car ast)) "##"))))) ;"\\$\\$\\$")))))
;; 				 ;; (println 'poly!var (car ast))
;; 				 (set! syms (append (list (car ast)) syms))
;; 				 (f (cdr ast)))
;; 				((member (car ast) '(__make-closure __make-closure-s __make-closure-h __make-closure-z))
;; 				 (if (not (null? (cl:intersection (cadddr ast) syms)))
;; 				     (print-error 'Compiler 'Error: 'Sorry 'single 'definition 'variables 'only! 'caught 'trying 'to 'redefine (symbol->string (car (cl:intersection (cadddr ast) syms))) 'as 'a 'shadow 'variable))
;; 				 (set! syms (cl:remove-duplicates (append (caddr ast) (cadddr ast) syms)))
;; 				 (f (car (cddddr ast))))
;; 				((member (car ast) '(__make-env __make-env-zone))
;; 				 (set! syms
;; 				       (append (map (lambda (p)
;; 						      (if (member (car p) syms)
;; 							  (print-error 'Compiler 'Error: 'Sorry 'single 'definition 'variables 'only! 'caught 'trying 'to 'redefine (symbol->string (car p)) p 'as 'a 'shadow 'variable))
;; 						      (car p))
;; 						    (caddr ast))
;; 					       syms))
;; 				 (for-each (lambda (p)
;; 					     (f (cadr p)))
;; 					   (caddr ast))
;; 				 (f (cadddr ast)))
;; 				(else (f (car ast))
;; 				      (f (cdr ast)))))
;; 			 ((atom? ast) '())))))
;;        (f full-ast)
;;        syms)))


(define impc:ti:find-all-vars
  (lambda (full-ast syms)
    (letrec ((f (lambda (ast)
                  ;; (println 'ast: ast)
                  (cond ((pair? ast)
                         (cond ((and (symbol? (car ast)) ;; this for generics
                                     (regex:match? (symbol->string (car ast)) "##") ;"\\$\\$\\$")
                                     (impc:ir:gpoly-exists? (string->symbol (car (regex:split (symbol->string (car ast)) "##")))))
                                (if (not (impc:ir:gpoly-types (string->symbol (car (regex:split (symbol->string (car ast)) "##")))
                                                              (length (cdr ast)) #f))
                                    (impc:compiler:print-bad-arity-error (car (regex:split (symbol->string (car ast)) "##"))))
                                ;; (println 'generics ast (regex:split (symbol->string (car ast)) "(\\$\\$\\$)|(_poly_)"))
                                (let* ((gname (string->symbol (car (regex:split (symbol->string (car ast)) "(##)|(_poly_)"))))
                                       (gnum (string->number (cadr (regex:split (symbol->string (car ast)) "(##)|(_poly_)"))))
                                       (arity (length (cdr ast)))
                                       (typestrs (cl:remove-duplicates
                                                  (impc:ir:get-pretty-closure-arg-strings
                                                   (symbol->string (car (impc:ir:gpoly-types gname arity #f))))))
                                       (types (map (lambda (x) (impc:ir:get-type-from-pretty-str x)) typestrs))
                                       (newsyms (cl:remove-duplicates
                                                 (map (lambda (a b)
                                                        (if (or (impc:ir:type? b)
                                                                (not (impc:ir:tuple? b)))
                                                            #f
                                                            (if (regex:match? a ":")
                                                                (string->symbol (string-append a "##" (number->string gnum)))
                                                                (string->symbol (string-append (impc:ir:get-base-type a)
                                                                                               ":"
                                                                                               (impc:ir:pretty-print-type b)
                                                                                               "##" (number->string gnum))))))
                                                      typestrs types)))
                                       (gvars
                                        (cl:remove-duplicates
                                         (cl:remove-if-not (lambda (x)
                                                             (and (symbol? x) (regex:match? (symbol->string x) "^!")))
                                                           (flatten types))))
                                       (newsyms_gvars (map (lambda (k)
                                                             (string->symbol (string-append (symbol->string k) "##" (number->string gnum))))
                                                           gvars)))
                                  (set! syms (append syms (list (car ast)) (cl:remove #f (cl:remove-duplicates (append newsyms newsyms_gvars)))))
                                  ;; (println 'newsyms: syms)
                                  (f (cdr ast))))
                               ((and (symbol? (car ast)) ;; this for polys
                                     (regex:match? (symbol->string (car ast)) "##") ;"\\$\\$\\$")
                                     (impc:ir:poly-types (string->symbol (car (regex:split (symbol->string (car ast)) "##"))))) ;"\\$\\$\\$")))))
                                ;; (println 'poly!var (car ast))
                                (set! syms (append (list (car ast)) syms))
                                (f (cdr ast)))
                               ((member (car ast) '(__make-closure __make-closure-s __make-closure-h __make-closure-z))
                                (if (not (null? (cl:intersection (cadddr ast) syms)))
                                    (impc:compiler:print-shadow-var-error (car (cl:intersection (cadddr ast) syms)) 'as 'a 'shadow 'variable))
                                (set! syms (cl:remove-duplicates (append (caddr ast) (cadddr ast) syms)))
                                (f (car (cddddr ast))))
                               ((member (car ast) '(__make-env __make-env-zone))
                                (set! syms
                                      (append (map (lambda (p)
                                                     (if (member (car p) syms)
                                                         (impc:compiler:print-shadow-var-error (car p)))
                                                     (car p))
                                                   (caddr ast))
                                              syms))
                                (for-each (lambda (p)
                                            (f (cadr p)))
                                          (caddr ast))
                                (f (cadddr ast)))
                               (else (f (car ast))
                                     (f (cdr ast)))))
                        ((atom? ast) '())))))
      (f full-ast)
      syms)))



(define impc:ti:block:check-for-free-syms
  (lambda (ast esyms)
                                        ;(print 'check: 'ast: ast 'esyms: esyms)
    (cl:remove-duplicates (let loop ((lst ast))
                            (cond ((pair? lst)
                                   (append (loop (car lst))
                                           (loop (cdr lst))))
                                  ((atom? lst)
                                   (if (member lst esyms)
                                       (list lst)
                                       '())))))))

;;
;; adds make-closure and make-env tags
;;

(define impc:ti:allocate-var?
  (lambda (ast)
    (cond ((null? ast) #f)
          ((member ast *impc:lambdaslist*) #t)
          ((pair? ast)
           (or (impc:ti:allocate-var? (car ast))
               (impc:ti:allocate-var? (cdr ast))))
          (else #f))))

(define impc:ti:allocate-var?
  (lambda (ast)
    (cond ((null? ast) 0)
          ((member ast '(lambda lambdaz)) 3)
          ((eq? ast 'lambdah) 1)
          ((eq? ast 'lambdas) 2)
          ((pair? ast)
           (let ((a (impc:ti:allocate-var? (car ast)))
                 (b (impc:ti:allocate-var? (cdr ast))))
             (if (> a b) a b)))
          (else 0))))

;; adds make-closure and make-env tags
(define impc:ti:closure:convert
  (lambda (ast esyms)
    (cond ((pair? ast)
           (if (member (car ast) *impc:lambdaslist*)
               (let (;(env (impc:ti:block:check-for-free-syms ast esyms))
                     (allocate-mem-for-vars? (impc:ti:allocate-var? (cdr ast))))
                 (list (cond ((eq? (car ast) 'lambdah) '__make-closure-h)
                             ((eq? (car ast) 'lambdas) '__make-closure-s)
                             (else '__make-closure-z))
                       allocate-mem-for-vars?
                       ;; name of compiled function is always last
                       ;; so we can remove it by dropping it off the end
                       (cdr (reverse (cl:remove-duplicates esyms))) ;env
                       (cadr ast)
                       (impc:ti:closure:convert (caddr ast) (append (cadr ast) esyms))))
               (if (member (car ast) *impc:letslist*)
                   (let* ((allocate-mem-for-vars? (impc:ti:allocate-var? ast))
                          (bindings (map (lambda (binding)
                                           (car binding))
                                         (cadr ast))))
                                        ;(free-syms (impc:ti:block:check-for-free-syms (cddr ast) (append bindings esyms))))
                     (cons '__make-env
                           (cons allocate-mem-for-vars?
                                 (list (impc:ti:closure:convert (cadr ast) (append bindings esyms))
                                       (impc:ti:closure:convert (caddr ast) (append bindings esyms))))))
                   (cons (impc:ti:closure:convert (car ast) esyms)
                         (impc:ti:closure:convert (cdr ast) esyms)))))
          ((atom? ast) ast))))



;; expects t1 (i.e. original untransformed code)
(define impc:ti:get-closure-arg-symbols
  (lambda (closure-sym ast)
                                        ;(print 'ast: ast)
    (cond ((null? ast) '())
          ((atom? ast) '())
          ((vector? ast) '())
          ((and (pair? ast)
                (eq? (car ast) closure-sym))
           (if (and (not (null? (cdr ast)))
                    (list? (cadr ast))
                    (member (caadr ast) *impc:lambdaslist*))
               (cadr (cadr ast))
               '()))
          (else (append (impc:ti:get-closure-arg-symbols closure-sym (car ast))
                        (impc:ti:get-closure-arg-symbols closure-sym (cdr ast)))))))


(define impc:ti:handle-forced-types
  (lambda (t1 . args)
    (if (null? args) '()
        (let* ((forced-types (map (lambda (t)
                                    (map (lambda (tt)
                                           (if (not (or (symbol? tt)
                                                        (list? tt)))
                                               (impc:compiler:print-bad-type-error t "bad fixed type")))
                                         (if (list? t) (cdr t) (list (cdr t))))
                                    (cons (car t) (impc:ir:convert-from-pretty-types (cdr t))))
                                  args))
               (forced-types-updated (apply append (list)
                                            (map (lambda (t)
                                                   (if (and (impc:ir:closure? (cdr t))
                                                            (not (null? (impc:ti:get-closure-arg-symbols (car t) t1))))
                                                       (if (<> (length (cdddr t)) (length (impc:ti:get-closure-arg-symbols (car t) t1)))
                                                           (begin
                                        ;(println '------ (cdddr t) (impc:ti:get-closure-arg-symbols (car t) t1))
                                                             (impc:compiler:print-bad-type-error (cdr t) (car t)))
                                                           (append (map (lambda (sym type)
                                                                          (cons sym type))
                                                                        (impc:ti:get-closure-arg-symbols (car t) t1)
                                                                        (cdddr t))
                                                                   (list t)))
                                                       (list t)))
                                                 forced-types)))
               (checked-for-duplicates (let loop ((types forced-types-updated))
                                         (if (null? types) (cl:remove-duplicates forced-types-updated)
                                             (if (and (assoc-strcmp (caar types) (cdr types))
                                                      (not (equal? (cdr (assoc-strcmp (caar types) (cdr types)))
                                                                   (cdr (car types)))))
                                                 (impc:compiler:print-type-mismatch-error
                                                  (assoc-strcmp (caar types) (cdr types))
                                                  (car types))
                                                 (loop (cdr types)))))))
          ;; checked-for-duplicates))))
          ;; finally remove anything that isn't a fully qualified type!
          (cl:remove-if-not (lambda (t) (impc:ir:type? (cdr t))) checked-for-duplicates)))))




(define impc:ti:get-closure-names
  (lambda (ast . args)
    (let ((blst '()))
      (let loop ((alst ast))
        (cond ((null? alst) '())
              ((atom? alst) '())
              ((pair? alst)
               (if (member (car alst) '(__make-closure __make-closure-h __make-closure-z __make-closure-s))
                   (set! blst (cons (caddr alst) blst)))
               (loop (car alst))
               (loop (cdr alst)))))
      blst)))


(define impc:ti:numeric-cast-operator
  (lambda (a b)
    (let* ((lowest (if (< a b) a b))
           (highest (if (= a lowest) b a))
           (caststr (string-append (if (impc:ir:floating-point? highest)
                                       (if (= highest *impc:ir:fp64*) "d" "f")
                                       (impc:ir:pretty-print-type highest))
                                   "to"
                                   (if (impc:ir:floating-point? lowest)
                                       (if (= lowest *impc:ir:fp64*) "d" "f")
                                       (impc:ir:pretty-print-type lowest)))))
      caststr)))


;; an optional compiler stage to support some basic type coercions
;; particular math coercions of forced types
(define impc:ti:coercion-run
  (lambda (ast forced-types)
    ;; (println 'ast: ast)
    (if (pair? ast)
        (cond ((member (car ast) '(< > * / = + - <>))
               (let ((a (assoc-strcmp (cadr ast) forced-types))
                     (b (assoc-strcmp (caddr ast) forced-types)))
                 (if (and (and a b)
                          (not (impc:ir:tuple? (cdr a)))
                          (not (impc:ir:vector? (cdr a)))
                          (<> (cdr a) (cdr b)))
                     (let ((ret (string->symbol (impc:ti:numeric-cast-operator (cdr a) (cdr b)))))
                       ;; (println '> (cdr a) (cdr b))
                       (if (> (cdr a) (cdr b))
                           `(,(car ast) (,ret ,(cadr ast)) ,(caddr ast))
                           `(,(car ast) ,(cadr ast) (,ret ,(caddr ast)))))
                     (if (and a (number? (caddr ast)))
                         (if (and (impc:ir:floating-point? (cdr a))
                                  (integer? (caddr ast)))
                             `(,(car ast) ,(cadr ast) ,(integer->real (caddr ast)))
                             (if (and (impc:ir:fixed-point? (cdr a))
                                      (real? (caddr ast)))
                                 `(,(car ast) ,(cadr ast) ,(real->integer (caddr ast)))
                                 ast))
                         (if (and b (number? (cadr ast)))
                             (if (and (impc:ir:floating-point? (cdr b))
                                      (integer? (cadr ast)))
                                 `(,(car ast) ,(integer->real (cadr ast)) ,(caddr ast))
                                 (if (and (impc:ir:fixed-point? (cdr b))
                                          (real? (cadr ast)))
                                     `(,(car ast) ,(real->integer (cadr ast)) ,(caddr ast))
                                     ast))
                             ast)))))
              (else (cons (impc:ti:coercion-run (car ast) forced-types)
                          (impc:ti:coercion-run (cdr ast) forced-types))))
        ast)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define impc:ti:scm_rt_check_string
  (lambda (n)
    (let* ((os (make-string 0))
           (n1 (substring n 1 2))
           (name-str (impc:ir:make-const-string "Scheme to xlang type conversion error\n"))
           (name (impc:ir:gname)))
      (emit n "_bool = icmp eq i32 " n "_rt_check, 1\n" os)
      (emit "br i1 " n "_bool, label " n "_true, label " n "_false\n" os)
      (emit "\n" n1 "_true:\n" os)
      (emit "br label " n "_continue\n" os)
      (emit "\n" n1 "_false:\n" os)
      (emit name-str os)
      (emit "call i32 (i8*, ...)* @llvm_printf(i8* " (car name) ")\n" os)
      (emit n "_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)\n" os)
      (emit "ret i8* " n "_errret\n" os)
      (emit "\n" n1 "_continue:\n" os)
      ;;(emit n " = call ccc double @r64value(i8* " n "_val)\n" os)
      (impc:ir:strip-space os))))


(define impc:ti:get-expression-type
  (lambda (ast)
    (let* ((symname 'nosuchname)
           (c `(let ((xtm_exp_result ,ast)) xtm_exp_result))
           (shadows (impc:ti:rename-all-shadow-vars c '()))
           (c1 (impc:ti:get-var-types shadows)) ;; this is a cons pairof (ast . types)
           (ta (impc:ti:first-transform (car c1) #t)) ;; car is ast
           (shadow-code (impc:ti:rename-all-shadow-vars ta '()))
           (c2 (impc:ti:get-var-types shadow-code))
           (ccc (append (cdr c2) (cdr c1)))
           (cc (impc:ti:expand-generic-types ccc))
           (t1 (car c2))
           (t2 (impc:ti:closure:convert t1 (list))) ;(list symname)))
           (vars (map (lambda (x) (list x)) (impc:ti:find-all-vars t2 '())))
           (forced-types '()) ;(apply impc:ti:handle-forced-types t1 (append cc args)))
           (t4 (impc:ti:coercion-run t2 forced-types)) ;; t4 and t5 are optional
           (typespre (impc:ti:run-type-check vars forced-types t1))
           (t5 (impc:ti:closure:convert t4 (list symname)))
           (types (impc:ti:type-normalize typespre)))
      (cdr (assoc 'xtm_exp_result types)))))


;; compile the getter/setter/stub/callback functions
(define impc:ti:compile-auxilliary-functions
  (lambda (fs fssetter fsgetter fstub fstub_native fstub_scheme fstub_scheme_valid fscallback compile-stub?)
    (if *impc:compile*
        (let ((ir-string (string-append fs
                                        fssetter
                                        (if compile-stub?
                                            (string-append fsgetter fstub fstub_native
                                                           (if fstub_scheme_valid
                                                               fstub_scheme "")
                                                           fscallback)
                                            ""))))
          (if *impc:compiler:print-raw-llvm*
              (print-full-nq ir-string))
          (if (not (llvm:compile-ir ir-string))
              (impc:compiler:print-compiler-error "cannot compile closure helper functions (getter/setter etc.)"))))))

(define impc:ti:run
  (lambda (symname code zone-size . args)
    ;; (println '-----------> 'impc:ti:run: symname)
    ;; (println 'code: code)
    ;; (println 'args: args)
    (set! *impc:ir:sym-name-stack* '())
    (set! *impc:ir:ls_var* '())
    (set! *impc:ti:bound-lambdas* '())
    (set! *impc:ti:generic-type-mappings* '())
    (set! *impc:ti:nativef-generics-recurse-test* 0)
    ;; don't want type checking to find existing native versions!
    (if *impc:compile*
        (begin ;(llvm:remove-globalvar (string-append (symbol->string symname) "_var"))
                                        ;(llvm:erase-function (symbol->string symname))
          (llvm:erase-function (string-append (symbol->string symname) "_setter"))
          (llvm:erase-function (string-append (symbol->string symname) "_maker"))))
    (let* ((c code)
           (shadows (impc:ti:rename-all-shadow-vars c '()))
           (c1 (impc:ti:get-var-types shadows)) ;; this is a cons pairof (ast . types)
           (ta (impc:ti:first-transform (car c1) #t)) ;; car is ast
           ;; (llllll (println 'ta: ta))
           ;; might be over kill doing shadow vars twice!
           (shadow-code (impc:ti:rename-all-shadow-vars ta '()))
           ;; (llll (println 'shadow-code shadow-code))
           (c2 (impc:ti:get-var-types shadow-code)) ;; it is possible for macros in the first-transform to introduce new var-types
           (ccc (append (cdr c2) (cdr c1)))
           ;; (llllll (println 'ccc: ccc))
           (cc (impc:ti:expand-generic-types ccc))
           (t1 (car c2))
           (t2 (impc:ti:mark-returns t1 symname #f #f #f))
           (t3 (impc:ti:closure:convert t2 (list symname)))
           (vars (map (lambda (x) (list x)) (impc:ti:find-all-vars t3 '())))
           ;; (llllllllll (println 'vars: vars))
           (forced-types (apply impc:ti:handle-forced-types t1 (append cc args)))
           ;; (llllllllllll (println 'forced: forced-types))
           (t4 (impc:ti:coercion-run t2 forced-types)) ;; t4 and t5 are optional
           (typespre (impc:ti:run-type-check vars forced-types t4))
           (t5 (impc:ti:closure:convert t4 (list symname)))
           (types (impc:ti:type-normalize typespre))
           (newast '()))
      ;; (println 'forced: forced-types)
      ;; (println 'types-post: types)
      ;; (println 'run: (impc:ti:unity? types))
      ;; (println 'newast: newast)
      ;; (println 'forced: forced-types)
      ;; (println 'times: (- ct2 ct1) (- ct3 ct2) (- ct4 ct3) (- ct5 ct4) (- ct6 ct5) (- ct7 ct6) (- ct8 ct7) (- ct9 ct8) (- ct10 ct9) (- ct11 ct10))

      ;; (println 'typesa types)
      ;; A FINAL TYPE CLEANUP
      ;;
      ;; finally we remove !bang types which ultimately don't need to be resolved fully
      ;; don't need to be resolved because they are helpers to resolution not reified types in their own right
      ;;
      ;; also we make sure that any types of the form (sym "%list...") are converted to (sym . "%list...")
      ;; in other words change list ("%list...") into atom "%list..."

      (set! types (cl:remove #f (map (lambda (x)
                                       (if (or (regex:match? (symbol->string (car x)) "^!")
                                               (regex:match? (symbol->string (car x))
                                                             "^[A-Za-z0-9_-]*:<.*##[0-9]*$"))
                                           #f
                                           (if (list? (cdr x))
                                               (if (= (length (cdr x)) 1)
                                                   (cons (car x) (cadr x))
                                                   x)
                                               x)))
                                     types)))

      ;; just added by andrew (can be safely removed)
      (if (null? types)
          (impc:compiler:print-could-not-resolve-type-error symname))

      ;; (println 'final-types: types)

      ;; if we didn't unify print error and bomb out!
      (if (not (cl:every (lambda (x) x) (impc:ti:unity? types)))
          (begin
            ;; (println 'types_: types)
            (impc:compiler:print-could-not-resolve-type-error
             (cl:remove 'good (map (lambda (x y) (if y 'good (symbol->string (car x))))
                                   types (impc:ti:unity? types)))
             "you could try forcing the type of one or more of these symbols")))

      ;; if we have type checked ok then set addtypes to source and create new ast
      (set! newast (impc:ti:add-types-to-source symname t5 (cl:tree-copy types) (list)))
      ;; (println 'ast:)
      ;; (println newast)
      ;; (println 'types:)
      ;; (for-each (lambda (t) (println t)) types)

      ;; if this function has been defined before make sure we aren't changing its signature!!
      (if (and (impc:ti:closure-exists? (symbol->string symname))
               (or (<> (length (impc:ti:get-closure-arg-types (symbol->string symname)))
                       (length (cddr (assoc-strcmp symname types))))
                   (cl:position #f (map (lambda (a b)
                                          (equal? a b))
                                        (cons (+ *impc:ir:closure*
                                                 *impc:ir:pointer*
                                                 *impc:ir:pointer*)
                                              (map (lambda (x) (impc:ir:get-type-from-str x))
                                                   (impc:ti:get-closure-arg-types (symbol->string symname))))
                                        (cdr (assoc-strcmp symname types))))))
          (impc:compiler:print-no-redefinitions-error
           symname
           (impc:ir:pptype (cons (+ *impc:ir:closure*
                                    *impc:ir:pointer*
                                    *impc:ir:pointer*)
                                 (map (lambda (x) (impc:ir:get-type-from-str x))
                                      (impc:ti:get-closure-arg-types (symbol->string symname)))))
           (impc:ir:pptype (cdr (assoc-strcmp symname types)))))
                                        ;(print-error "stop")
      (if *impc:compiler:print-ast* (println '---------------------------------))
      (if *impc:compiler:print-ast* (println 'types: types))
                                        ;(println 'ctypes: converted-types)
      (if *impc:compiler:print-ast* (println 'newast: newast))
      ;; check for unfound types
      (for-each (lambda (t)
                  (if (not (impc:ir:type? (cdr t)))
                      (impc:compiler:print-could-not-resolve-type-error (car t))))
                types)
      ;; compile to ir
      (define fstr (impc:ir:compiler newast types))
      ;;
      ;; now compile ir to x86 and make stub code
      (let* ((closure-type (cadr (impc:ir:gname)))
             (closure-type-- (impc:ir:get-type-str (impc:ir:pointer-- (impc:ir:get-type-from-str closure-type))))
             (compile-stub? (not (impc:ti:closure-exists? (symbol->string symname))))
             (fs (string-append "define dllexport ccc " closure-type " @" (string-append (symbol->string symname) "_maker")
                                "(i8* %_impz) nounwind {\nentry:\n"
                                ;; "%_zone = bitcast i8* %_impz to %mzone*\n"
                                ;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                ;; ;; new lines for impz
                                "%_impzPtr = alloca i8*\n"
                                "store i8* %_impz, i8** %_impzPtr\n"
                                ;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                fstr "}\n"))
             (fssetter (string-append (if compile-stub? ;;(llvm:get-globalvar (string-append (symbol->string symname) "_var"))
                                          (string-append "@" (symbol->string symname) "_var = dllexport global [1 x i8*] [ i8* null ]\n\n"
                                                         "@" (symbol->string symname) "_var_zone = dllexport global [1 x i8*] [ i8* null ]\n\n")
                                          "") ;; if global var alread exists do nothing
                                      "define dllexport ccc void @" (string-append (symbol->string symname) "_setter")
                                      "(i8* %_impz) nounwind {\nentry:\n"
                                      "%oldzone1 = getelementptr [1 x i8*]* @" (symbol->string symname) "_var_zone, i32 0, i32 0\n"
                                      "%oldzone2 = load i8** %oldzone1\n"
                                      "%oldzone3 = bitcast i8* %oldzone2 to %mzone*\n"
                                      "store i8* %_impz, i8** %oldzone1\n"
                                        ; existing code
                                      "%closure = call ccc " (cadr (impc:ir:gname))
                                      " @" (string-append (symbol->string symname) "_maker") "(i8* %_impz)\n"
                                      "%ptr = bitcast " (cadr (impc:ir:gname)) " %closure to i8*\n"
                                      "%varptr = bitcast [1 x i8*]* @" (symbol->string symname) "_var to i8**\n"
                                      "store i8* %ptr, i8** %varptr\n"
                                      ;; new code
                                      "; destroy oldzone if not null\n"
                                      "%test = icmp ne %mzone* %oldzone3, null\n"
                                      "br i1 %test, label %then, label %cont\n"
                                        ;"then:\ncall ccc void @llvm_zone_destroy(%mzone* %oldzone3)\nbr label %cont\n"
                                      "then:\ncall ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)\nbr label %cont\n"
                                      "cont:\n"
                                      "ret void\n}\n"))
             (stub-type (impc:ir:get-closure-type-from-str closure-type))
             (fsgetter (string-append "define dllexport ccc i8* @" (symbol->string symname) "_getter() nounwind {\n"
                                      "entry:\n"
                                      "%ptr = getelementptr [1 x i8*]* @" (symbol->string symname) "_var, i32 0, i32 0\n"
                                      "%func = load i8** %ptr\n"
                                      "ret i8* %func\n}\n"))
             (cb-struct-type (if (null? (cdr stub-type))
                                 '()
                                 (string-append ;"{void(i8*)*"
                                  "{"
                                  (impc:ir:get-type-str (cadr stub-type))
                                  (apply string-append
                                         (map (lambda (a)
                                                (string-append ", " (impc:ir:get-type-str a)))
                                              (cddr stub-type)))
                                  "}*")))
             (fscallback (string-append "define dllexport ccc void @" (string-append (symbol->string symname) "_callback(i8* %dat) nounwind {\n"
                                                                                     "entry:\n"
                                                                                     (if (null? cb-struct-type)
                                                                                         "%fstruct = select i1 true, i8* %dat, i8* %dat\n"
                                                                                         (string-append "%fstruct = bitcast i8* %dat to " cb-struct-type "\n"))
                                                                                     ;;"%fPtr = getelementptr " cb-struct-type " %fstruct ,i32 0, i32 0\n"
                                                                                     (apply string-append (map (lambda (n t ap a)
                                                                                                                 (string-append ap " = getelementptr " cb-struct-type " %fstruct, i32 0, i32 " (number->string n) "\n"
                                                                                                                                a " = load " (impc:ir:get-type-str t) "* " ap "\n"))
                                                                                                               (make-list-with-proc (- (length stub-type) 1) (lambda (i) i)) ;(+ i 1)))
                                                                                                               (cdr stub-type)
                                                                                                               '("%ap" "%bp" "%cp" "%dp" "%ep" "%fp" "%gp" "%hp" "%ip" "%jp" "%kp" "%lp" "%mp" "%np" "%op" "%pp" "%qp" "%rp" "%sp" "%tp")
                                                                                                               '("%a" "%b" "%c" "%d" "%e" "%f" "%g" "%h" "%i" "%j" "%k" "%l" "%m" "%n" "%o" "%p" "%q" "%r" "%s" "%t")))
                                        ;"%_zone = call ccc %mzone* @llvm_peek_zone_stack()\n"
                                                                                     "%_zone = call ccc %mzone* @llvm_threads_get_callback_zone()\n"
                                                                                     "call ccc void @llvm_push_zone_stack(%mzone* %_zone)\n"
                                                                                     "call ccc %mzone* @llvm_zone_reset(%mzone* %_zone)\n"
                                                                                     "%_impz = bitcast %mzone* %_zone to i8*\n"
                                                                                     "%ptr = getelementptr [1 x i8*]* @" (symbol->string symname) "_var, i32 0, i32 0\n"
                                                                                     "%ptrvar = load i8** %ptr\n"
                                                                                     "%closure_tmp = bitcast i8* %ptrvar to " closure-type "\n"
                                                                                     "%closure = load " closure-type " %closure_tmp \n"
                                                                                     "%fPtr = getelementptr " closure-type-- " %closure, i32 0, i32 2\n"
                                                                                     "%ePtr = getelementptr " closure-type-- " %closure, i32 0, i32 1\n"
                                                                                     "%ff = load "
                                                                                     (regex:replace closure-type-- "\\{ ?i8\\*, ?i8\\*,(.*)\\}\\*" "$1")
                                                                                     "* %fPtr\n"
                                                                                     "%ee = load i8** %ePtr\n"
                                                                                     (if (impc:ir:void? (car stub-type)) "" "%result = ")
                                                                                     "call fastcc " (impc:ir:get-type-str (car stub-type)) " %ff(i8* %_impz, i8* %ee"
                                                                                     ;;"call ccc " (impc:ir:get-type-str (car stub-type)) " %ff(i8* %_impz, i8* %ee"
                                                                                     (apply string-append (map (lambda (t n)
                                                                                                                 (string-append ", "
                                                                                                                                (impc:ir:get-type-str t)
                                                                                                                                " " n))
                                                                                                               (cdr stub-type)
                                                                                                               '("%a" "%b" "%c" "%d" "%e" "%f" "%g" "%h" "%i" "%j" "%k" "%l" "%m" "%n" "%o" "%p" "%q" "%r" "%s" "%t")))
                                                                                     ")\n"
                                                                                     "call ccc %mzone* @llvm_pop_zone_stack()\n"
                                                                                     "ret void\n"
                                                                                     "}\n")))
             (fstub_scheme_valid #t)
             (fstub_scheme (string-append "define dllexport ccc i8* " ;(impc:ir:get-type-str (car stub-type))
                                          " @" (string-append (symbol->string symname) "_scheme(i8* %_sc, i8* %args) nounwind\n"
                                                              "{\nentry:\n"
                                                              "%_zone = call ccc %mzone* @llvm_peek_zone_stack()\n"
                                                              "%_impz = bitcast %mzone* %_zone to i8*\n"

                                        ;(begin (println 'aaaaa) "")

                                                              (apply string-append
                                                                     (map (lambda (t n idx)
                                        ;(println 't: t 'n: n 'idx: idx)
                                                                            (string-append n "_val = call ccc i8* @list_ref(i8* %_sc, i32 " (number->string idx) ",i8* %args)\n"
                                                                                           (cond ((and (not (number? t))
                                                                                                       (not (impc:ir:pointer? t)))
                                                                                                  (set! fstub_scheme_valid #f)
                                                                                                  "")
                                                                                                 ((or (not (number? t))
                                                                                                      (not (or (impc:ir:number? t)
                                                                                                               (impc:ir:void? t))))
                                                                                                  (if (and (number? t)
                                                                                                           (= t (+ *impc:ir:pointer* *impc:ir:si8*)))
                                                                                                      (string-append n "_rt_check = call i32 @is_cptr_or_str(i8* " n "_val)\n"
                                                                                                                     (impc:ti:scm_rt_check_string n)
                                                                                                                     n " = call ccc i8*  @cptr_value(i8* " n "_val)\n")
                                                                                                      (string-append n "_rt_check = call i32 @is_cptr(i8* " n "_val)\n"
                                                                                                                     (impc:ti:scm_rt_check_string n)
                                                                                                                     "%ttv_" (number->string idx) " = call ccc i8* @cptr_value(i8* " n "_val)\n"
                                                                                                                     n " = bitcast i8* %ttv_" (number->string idx) " to " (impc:ir:get-type-str t) "\n")))
                                                                                                 ((= t *impc:ir:fp64*) (string-append n "_rt_check = call i32 @is_real(i8* " n "_val)\n"
                                                                                                                                      (impc:ti:scm_rt_check_string n)
                                                                                                                                      n " = call ccc double @r64value(i8* " n "_val)\n"))
                                                                                                 ((= t *impc:ir:fp32*) (string-append n "_rt_check = call i32 @is_real(i8* " n "_val)\n"
                                                                                                                                      (impc:ti:scm_rt_check_string n)
                                                                                                                                      n " = call ccc float  @r32value(i8* " n "_val)\n"))
                                                                                                 ((= t *impc:ir:si64*) (string-append n "_rt_check = call i32 @is_integer(i8* " n "_val)\n"
                                                                                                                                      (impc:ti:scm_rt_check_string n)
                                                                                                                                      n " = call ccc i64  @i64value(i8* " n "_val)\n"))
                                                                                                 ((= t *impc:ir:ui64*) (string-append n "_rt_check = call i32 @is_integer(i8* " n "_val)\n"
                                                                                                                                      (impc:ti:scm_rt_check_string n)
                                                                                                                                      n " = call ccc i64  @i64value(i8* " n "_val)\n"))
                                                                                                 ((= t *impc:ir:si32*) (string-append n "_rt_check = call i32 @is_integer(i8* " n "_val)\n"
                                                                                                                                      (impc:ti:scm_rt_check_string n)
                                                                                                                                      n " = call ccc i32  @i32value(i8* " n "_val)\n"))
                                                                                                 ((= t *impc:ir:ui32*) (string-append n "_rt_check = call i32 @is_integer(i8* " n "_val)\n"
                                                                                                                                      (impc:ti:scm_rt_check_string n)
                                                                                                                                      n " = call ccc i32  @i32value(i8* " n "_val)\n"))
                                                                                                 ((= t *impc:ir:si16*) (string-append n "_rt_check = call i32 @is_integer(i8* " n "_val)\n"
                                                                                                                                      (impc:ti:scm_rt_check_string n)
                                                                                                                                      n " = call ccc i16  @i16value(i8* " n "_val)\n"))
                                                                                                 ((= t *impc:ir:ui16*) (string-append n "_rt_check = call i32 @is_integer(i8* " n "_val)\n"
                                                                                                                                      (impc:ti:scm_rt_check_string n)
                                                                                                                                      n " = call ccc i16  @i16value(i8* " n "_val)\n"))
                                                                                                 ((= t *impc:ir:si8*) (string-append n "_rt_check = call i32 @is_integer(i8* " n "_val)\n"
                                                                                                                                     (impc:ti:scm_rt_check_string n)
                                                                                                                                     n " = call ccc i8  @i8value(i8* " n "_val)\n"))
                                                                                                 ((= t *impc:ir:ui8*) (string-append n "_rt_check = call i32 @is_integer(i8* " n "_val)\n"
                                                                                                                                     (impc:ti:scm_rt_check_string n)
                                                                                                                                     n " = call ccc i8  @i8value(i8* " n "_val)\n"))
                                                                                                 ((= t *impc:ir:i1*) (string-append n "_rt_check = call i32 @is_integer(i8* " n "_val)\n"
                                                                                                                                    (impc:ti:scm_rt_check_string n)
                                                                                                                                    n " = call ccc i1  @i1value(i8* " n "_val)\n"))
                                                                                                 ((= t *impc:ir:char*) (string-append n "_rt_check = call i32 @is_string(i8* " n "_val)\n"
                                                                                                                                      (impc:ti:scm_rt_check_string n)
                                                                                                                                      n " = call ccc i8*  @string_value(i8* " n "_val)\n"))
                                                                                                 (else (error "Compiler Error: 'bad 'type 'in 'scheme 'stub")))))
                                                                          (cdr stub-type)
                                                                          '("%a" "%b" "%c" "%d" "%e" "%f" "%g" "%h" "%i" "%j" "%k" "%l" "%m" "%n" "%o" "%p" "%q" "%r" "%s" "%t")
                                                                          (make-list-with-proc 20 (lambda (i) i))))

                                        ;(begin (println 'bbbbb) "")

                                                              "%ptr = getelementptr [1 x i8*]* @" (symbol->string symname) "_var, i32 0, i32 0\n"
                                                              "%ptrvar = load i8** %ptr\n"
                                                              "%closure_tmp = bitcast i8* %ptrvar to " closure-type "\n"
                                                              "%closure = load " closure-type " %closure_tmp \n"
                                                              "%fPtr = getelementptr " closure-type-- " %closure, i32 0, i32 2\n"
                                                              "%ePtr = getelementptr " closure-type-- " %closure, i32 0, i32 1\n"
                                                              "%ff = load "
                                                              (regex:replace closure-type-- "\\{ ?i8\\*, ?i8\\*,(.*)\\}\\*" "$1")
                                                              "* %fPtr\n"
                                                              "%ee = load i8** %ePtr\n"
                                                              (if (impc:ir:void? (car stub-type)) "" "%result = ")
                                                              "call fastcc " (impc:ir:get-type-str (car stub-type)) " %ff(i8* %_impz, i8* %ee"

                                                              (apply string-append
                                                                     (map (lambda (t n)
                                                                            (string-append ", " (impc:ir:get-type-str t) " " n))
                                                                          (cdr stub-type)
                                                                          '("%a" "%b" "%c" "%d" "%e" "%f" "%g" "%h" "%i" "%j" "%k" "%l" "%m" "%n" "%o" "%p" "%q" "%r" "%s" "%t")))
                                                              ")\n"

                                        ;(begin (println 'ccccc) "")

                                                              (let* ((t (car stub-type)))
                                                                (cond ((and (not (number? t))
                                                                            (not (impc:ir:pointer? t)))
                                                                       (set! fstub_scheme_valid #f)
                                                                       "")
                                                                      ((or (not (number? t))
                                                                           (not (or (impc:ir:number? t)
                                                                                    (impc:ir:void? t))))
                                                                       (string-append "%tmpres = bitcast " (impc:ir:get-type-str t) " %result to i8*\n"
                                                                                      "%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)\n"))
                                                                      ((= t *impc:ir:void*) "%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)\n") ;; don't do anything for void
                                                                      ((= t *impc:ir:fp64*) "%res = call ccc i8* @mk_double(i8* %_sc, double %result)\n")
                                                                      ((= t *impc:ir:fp32*) "%res = call ccc i8* @mk_float(i8* %_sc, float %result)\n")
                                                                      ((= t *impc:ir:si64*) "%res = call ccc i8* @mk_i64(i8* %_sc, i64 %result)\n")
                                                                      ((= t *impc:ir:ui64*) "%res = call ccc i8* @mk_i64(i8* %_sc, i64 %result)\n")
                                                                      ((= t *impc:ir:si32*) "%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)\n")
                                                                      ((= t *impc:ir:ui32*) "%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)\n")
                                                                      ((= t *impc:ir:si16*) "%res = call ccc i8* @mk_i16(i8* %_sc, i16 %result)\n")
                                                                      ((= t *impc:ir:ui16*) "%res = call ccc i8* @mk_i16(i8* %_sc, i16 %result)\n")
                                                                      ((= t *impc:ir:si8*) "%res = call ccc i8* @mk_i8(i8* %_sc, i8 %result)\n")
                                                                      ((= t *impc:ir:ui8*) "%res = call ccc i8* @mk_i8(i8* %_sc, i8 %result)\n")
                                                                      ((= t *impc:ir:i1*) "%res = call ccc i8* @mk_i1(i8* %_sc, i1 %result)\n")
                                                                      ((= t *impc:ir:char*) "%res = call ccc i8* @mk_string(i8* %_sc, i8* %result\n")
                                                                      (else (error 'Compiler 'Error: 'return 'type 'error 'in 'scheme 'stub))))

                                                              "ret i8* %res\n"
                                                              "}")))
             (fstub (string-append "define dllexport fastcc " (impc:ir:get-type-str (car stub-type))
                                   " @" (string-append (symbol->string symname) "("
                                                       (apply string-append (map (lambda (t n c)
                                                                                   (string-append c (impc:ir:get-type-str t) " "
                                                                                                  n))
                                                                                 (cdr stub-type)
                                                                                 '("%a" "%b" "%c" "%d" "%e" "%f" "%g" "%h" "%i" "%j" "%k" "%l" "%m" "%n" "%o" "%p" "%q" "%r" "%s" "%t")
                                                                                 '("" "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," ",")))
                                                       ") nounwind \n"
                                                       "{\nentry:\n"
                                                       "%_zone = call ccc %mzone* @llvm_peek_zone_stack()\n"
                                                       "%_impz = bitcast %mzone* %_zone to i8*\n"
                                                       "%ptr = getelementptr [1 x i8*]* @" (symbol->string symname) "_var, i32 0, i32 0\n"
                                                       "%ptrvar = load i8** %ptr\n"
                                                       "%closure_tmp = bitcast i8* %ptrvar to " closure-type "\n"
                                                       "%closure = load " closure-type " %closure_tmp \n"
                                                       "%fPtr = getelementptr " closure-type-- " %closure, i32 0, i32 2\n"
                                                       "%ePtr = getelementptr " closure-type-- " %closure, i32 0, i32 1\n"
                                                       "%ff = load "
                                                       (regex:replace closure-type-- "\\{ ?i8\\*, ?i8\\*,(.*)\\}\\*" "$1")
                                                       "* %fPtr\n"
                                                       "%ee = load i8** %ePtr\n"
                                                       (if (impc:ir:void? (car stub-type)) "" "%result = ")
                                                       "call fastcc " (impc:ir:get-type-str (car stub-type)) " %ff(i8* %_impz, i8* %ee"
                                                       (apply string-append (map (lambda (t n)
                                                                                   (string-append ", "
                                                                                                  (impc:ir:get-type-str t)
                                                                                                  " " n))
                                                                                 (cdr stub-type)
                                                                                 '("%a" "%b" "%c" "%d" "%e" "%f" "%g" "%h" "%i" "%j" "%k" "%l" "%m" "%n" "%o" "%p" "%q" "%r" "%s" "%t")))
                                                       ")\nret " (impc:ir:get-type-str (car stub-type))
                                                       (if (impc:ir:void? (car stub-type)) "\n" " %result\n")
                                                       "}")))
             (fstub_native (string-append "define dllexport ccc " (impc:ir:get-type-str (car stub-type))
                                          " @" (string-append (symbol->string symname) "_native("
                                                              (apply string-append (map (lambda (t n c)
                                                                                          (string-append c (impc:ir:get-type-str t) " "
                                                                                                         n))
                                                                                        (cdr stub-type)
                                                                                        '("%a" "%b" "%c" "%d" "%e" "%f" "%g" "%h" "%i" "%j" "%k" "%l" "%m" "%n" "%o" "%p" "%q" "%r" "%s" "%t")
                                                                                        '("" "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," ",")))
                                                              ") nounwind \n"
                                                              "{\nentry:\n"
                                                              "%_zone = call ccc %mzone* @llvm_peek_zone_stack()\n"
                                                              "%_impz = bitcast %mzone* %_zone to i8*\n"
                                                              "%ptr = getelementptr [1 x i8*]* @" (symbol->string symname) "_var, i32 0, i32 0\n"
                                                              "%ptrvar = load i8** %ptr\n"
                                                              "%closure_tmp = bitcast i8* %ptrvar to " closure-type "\n"
                                                              "%closure = load " closure-type " %closure_tmp \n"
                                                              "%fPtr = getelementptr " closure-type-- " %closure, i32 0, i32 2\n"
                                                              "%ePtr = getelementptr " closure-type-- " %closure, i32 0, i32 1\n"
                                                              "%ff = load "
                                                              (regex:replace closure-type-- "\\{ ?i8\\*, ?i8\\*,(.*)\\}\\*" "$1")
                                                              "* %fPtr\n"
                                                              "%ee = load i8** %ePtr\n"
                                                              (if (impc:ir:void? (car stub-type)) "" "%result = ")
                                                              "call fastcc " (impc:ir:get-type-str (car stub-type)) " %ff(i8* %_impz, i8* %ee"
                                                              (apply string-append (map (lambda (t n)
                                                                                          (string-append ", "
                                                                                                         (impc:ir:get-type-str t)
                                                                                                         " " n))
                                                                                        (cdr stub-type)
                                                                                        '("%a" "%b" "%c" "%d" "%e" "%f" "%g" "%h" "%i" "%j" "%k" "%l" "%m" "%n" "%o" "%p" "%q" "%r" "%s" "%t")))
                                                              ")\nret " (impc:ir:get-type-str (car stub-type))
                                                              (if (impc:ir:void? (car stub-type)) "\n" " %result\n")
                                                              "}"))))

        ;; (println fsgetter)
        ;; (println fstub)

        (impc:ti:compile-auxilliary-functions fs fssetter fsgetter fstub fstub_native fstub_scheme fstub_scheme_valid fscallback compile-stub?)
        (if *impc:compile*
            (let ((ftype (map impc:ir:get-type-str
                              (cdr (impc:ir:get-type-from-str closure-type)))))
              (if (and (not *impc:compiler:print-raw-llvm*)
                       (or *impc:ti:print-code-specialization-compiles*
                           (not (regex:match? (symbol->string symname) "_poly_"))))
                  ;; the error is here!
                  (let* ((type1 (impc:ir:pretty-print-type (impc:ir:get-type-str (cons (+ *impc:ir:closure* *impc:ir:pointer* *impc:ir:pointer*) ftype))))
                         (type2 (impc:ir:get-pretty-closure-arg-strings type1))
                         (simpletype
                          (string-append "["
                                         (string-join (map (lambda (x)
                                                             (if (regex:match? x ":")
                                                                 (apply string-append (car (regex:type-split x ":"))
                                                                        (make-list (impc:ir:get-ptr-depth x) "*"))
                                                                 x))
                                                           type2)
                                                      ",")
                                         "]*")))
                    ;; (println 'type2 type2)
                    ;; (println 'simpletype simpletype)
                    (if (regex:match? (symbol->string symname) "_poly_")
                        ;; note: can probably change this to the
                        ;; bind-func specific one as well (as in
                        ;; the 'else' branch)
                        (impc:compiler:print-binding-details-to-log
                         "Spec'zed:"
                         symname
                         (if *impc:ti:print-full-generic-types*
                             (impc:ir:pretty-print-type (impc:ir:get-type-str (cons (+ *impc:ir:closure* *impc:ir:pointer* *impc:ir:pointer*) ftype)))
                             simpletype))
                        (begin
                          (impc:ti:set-closure-type (symbol->string symname)
                                                    (impc:ir:get-type-from-pretty-str simpletype))
                          (impc:compiler:print-bind-func-details-to-log
                           "Compiled:"
                           symname
                           simpletype
                           zone-size)))))))
        (cadr (impc:ir:gname))))))

(define-macro (xtm-closure-doc name)
  `(let ((docstring (impc:ti:get-closure-docstring ,name))
         (types (impc:ti:get-closure-type ,name))
         (form (impc:ti:get-closure-body ,name)))
     (if docstring
         (list (cdr docstring) (cdr types) (cdr form))
         (if types
             (list '() (cdr types) (cdr form))
             (if form
                 (list '() '() (cdr form))
                 #f)))))


(define-macro (definec symname . args)
  (let ((zone-size *impc:default-zone-size*))
    (if (number? (car args))
        (begin (set! zone-size (car args))
               (set! args (cdr args))))
    (if (string? (car args))
        (set! args (cdr args)))
    (let ((types (cdr (reverse args)))
          (expr (car (reverse args)))
          (precomp_sexpr '()))
      (if (regex:match? (symbol->string symname) ":")
          (let ((sres (regex:type-split (symbol->string symname) ":")))
            (set! symname (string->symbol (car sres)))
            (set! types (cons (cons symname (string->symbol (cadr sres))) types))))
      ;; (print-full symname 'types: types 'e: expr 'args: args)
      `(define ,symname
         (let* ((res1 (impc:ti:run ',symname
                                   '(let ((,symname ,expr)) ,symname)
                                   ,zone-size
                                   ,@(if (null? types)
                                         '()
                                         (map (lambda (k) (list 'quote k)) types))))
                (setter (llvm:get-function (string-append (symbol->string ',symname) "_setter")))
                (func (llvm:get-function (symbol->string ',symname))))
           (if setter
               (begin
                 (sys:push-memzone (sys:create-mzone ,zone-size))
                 (llvm:run setter (sys:peek-memzone))
                 (sys:pop-memzone) ;; don't destroy here - should happen in _setter
                 )
               (impc:compiler:print-missing-compiled-function-setter-error ',symname))
           (if func
               ;;(lambda args (apply llvm:run func (sys:peek-memzone) args))
               (if (llvm:get-scheme-function ,(symbol->string symname))
                   (begin
                     (llvm:ffi-set-name
                      (llvm:get-scheme-function ,(symbol->string symname))
                      ,(symbol->string symname))
                     (mk-ff (llvm:get-scheme-function ,(symbol->string symname))))
                   (impc:compiler:print-no-scheme-stub-notification ',symname))
               (impc:compiler:print-missing-compiled-function-error ',symname)))))))


;; alias for definec (should replace definec)
(define-macro (bind-func . args)
  (if (list? (car args))
      (impc:compiler:print-compiler-error "bind-func requires a name!"))
  ;; if doc-string exists!
  (let ((func-name (car (regex:type-split (symbol->string (car args)) ":")))
        (docstring (if (string? (cadr args)) (cadr args) "")))
    ;; remove docstring (if present)
    (if (not (string=? docstring ""))
        (set! args (append (list (car args)) (cddr args))))
    (if (impc:ti:closure-exists? func-name)
        (begin
          (impc:ti:set-closure-docstring func-name docstring)
          (impc:ti:set-closure-body func-name (cadr args)))
        (impc:ti:register-new-closure func-name
                                      '()
                                      docstring
                                      (cadr args)))
    (if (impc:ir:poly-types (car args))
        (impc:compiler:print-already-bound-error (car args) "poly function"))
    (if (impc:ir:gpoly-exists? (car args))
        (impc:compiler:print-already-bound-error (car args) "generic closure")))
  (if (regex:match? (symbol->string (car args)) ":")
      (let* ((res (regex:type-split (symbol->string (car args)) ":"))
             (name (car res))
             (type (cadr res))
             (ags (impc:ir:get-pretty-closure-arg-strings type))
             ;; expand all non-explict generic types
             ;; i.e. expand list* into list:<!a,list*>*
             (expand-polys (map (lambda (k)
                                  (if (impc:ir:gpolytype-types (impc:ir:get-base-type k))
                                      (apply string-append (impc:ir:get-base-type k) ":"
                                             (symbol->string (impc:ir:gpolytype-types (impc:ir:get-base-type k)))
                                             (make-list (impc:ir:get-ptr-depth k) "*"))
                                      k))
                                ags))
             (newtype (string-append "[" (string-join expand-polys ",") "]*"))
             (newnametype (string->symbol (string-append name ":" newtype))))
        ;; (println 'oldargs: args)
        ;; (println 'newargs: (cons newnametype (cdr args)))
        (if (regex:match? newtype "!")
            (begin
              (impc:ir:add-gpoly (cons 'bind-func (cons newnametype (cdr args))))
              ;;(impc:ir:add-gpoly (cons 'bind-func args))
              `(impc:compiler:print-binding-details-to-log "Generic: " ,(car res) ,(cadr res)))
            `(impc:ti:parametric-poly-pass '(definec ,@args))))
      `(impc:ti:parametric-poly-pass '(definec ,@args))))


(define-macro (bind-typevar name . args)
  (if (string? name) (set! name (string->symbol name)))
  `(map (lambda (a)
          (impc:ti:add-vtype ',name a))
        ',args))


;; bind-func-ipc is for passing an already compiled (and setter'd)
;; native function across to a non-primary process
(define bind-func-ipc
  (lambda (symname)
    (let ((zone-size *impc:default-zone-size*))
      (eval
       `(define ,symname
          (let* ((setter (llvm:get-function (string-append (symbol->string ',symname) "_setter")))
                 (func (llvm:get-function (symbol->string ',symname))))
                                        ;(println 'scmfunc: (llvm:get-scheme-function ,(symbol->string symname)))
            (if func
                (if (llvm:get-scheme-function ,(symbol->string symname))
                    (begin
                      (llvm:ffi-set-name
                       (llvm:get-scheme-function ,(symbol->string symname))
                       ,(symbol->string symname))
                      (mk-ff (llvm:get-scheme-function ,(symbol->string symname))))
                    (impc:compiler:print-no-scheme-stub-notification ',symname))
                                        ;(lambda args (apply llvm:run func (sys:peek-memzone) args))
                (impc:compiler:print-missing-compiled-function-error ',symname))))
       (interaction-environment)))))

(define ipc:bind-func
  (lambda (procname symname)
    (ipc:call procname 'bind-func-ipc symname)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define-macro (bind-alias symbol type)
  `(begin (impc:ir:add-type-alias ,(symbol->string symbol) ,(symbol->string type))
          (impc:compiler:print-binding-details-to-log
           "SetAlias:"
           ',symbol
           ;;(print ',type)
           (begin
             (set! *impc:ir:get-type-callback-off* #t) ;; don't wait, do it immediately
             (let ((r (impc:ir:pretty-print-type ,(symbol->string symbol))))
               (set! *impc:ir:get-type-callback-off* #f)
               r))
           )))


(define build-type-dataconstructor
  (lambda (name type generic . args)
    (if (or (not (string? type)) ;; if not already a pretty type
            (regex:match? type "^\\s*{"))
        (set! type (impc:ir:pretty-print-type type)))

    ;; (println 'build-data-construct name type generic)

    (let* ((tsplit (car (regex:type-split (symbol->string name) "_poly_")))
           (a (map (lambda (x)
                     (if (and (string=? tsplit (impc:ir:get-base-type x))
                              (= 1 (impc:ir:get-ptr-depth x)))
                         (string-append (symbol->string name) "*")
                         x))
                   (impc:ir:get-pretty-tuple-arg-strings type)))
           (compiler-suppress-on (if (equal? *impc:compiler:message:level* 'low) #f #t))
           (arglst1 *impc:alphabetlist*) ;; '(a b c d e f g h i j k l m n o p q r s t u v w x y z))
           (arglst2 *impc:alphabetidxlist*) ;; '(0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25))
           (namestr (symbol->string name))
           (ctype (string-append "["
                                 (if generic
                                     (apply string-append namestr ":" type "*"
                                            (map (lambda (x)
                                                   (string-append
                                                    ","
                                                    (regex:replace x
                                                                   (string-append namestr "([*]*)")
                                                                   (string-append namestr ":" type "$1"))))
                                                 a))
                                     (apply string-append (symbol->string name) "*"
                                            (map (lambda (x) (string-append "," x)) a)))
                                 "]*"))
           (nameandtype (string->symbol (string-append namestr "" ":" ctype)))
           (print_name (string->symbol (string-append namestr "_print" ":[void," (symbol->string name) "*]*")))
           (h_nameandtype (string->symbol (string-append namestr "_h" ":" ctype)))
           (argslist (map (lambda (a b) b) a arglst1))
           (hcopy_body (if generic #f
                           (map (lambda (a b c)
                                  (set! a (impc:ir:get-type-from-pretty-str a))
                                  (if (and (impc:ir:tuple? a)
                                           (= 1 (impc:ir:get-ptr-depth a)))
                                      `(if (not (null? (tref x ,c)))
                                           (tset! obj ,b (,(string->symbol
                                                            (string-append (substring a 1 (- (string-length a) 1)) "_hcopy"))
                                                           (tref x ,c))))
                                      `(tset! obj ,b (tref x ,c))))
                                a arglst2 (range (length a)))))
           (hfree_body (if generic #f
                           (map (lambda (a c)
                                  (set! a (impc:ir:get-type-from-pretty-str a))
                                  (if (and (impc:ir:tuple? a)
                                           (= 1 (impc:ir:get-ptr-depth a)))
                                      `(if (not (null? (tref x ,c)))
                                           (,(string->symbol
                                              (string-append (substring a 1 (- (string-length a) 1)) "_hfree"))
                                             (tref x ,c)))))
                                a (range (length a)))))
           (zcopy_body (if generic #f
                           (map (lambda (a b c)
                                  (set! a (impc:ir:get-type-from-pretty-str a))
                                  (if (and (impc:ir:tuple? a)
                                           (= 1 (impc:ir:get-ptr-depth a)))
                                      `(if (not (null? (tref x ,c)))
                                           (tset! obj ,b (,(string->symbol
                                                            (string-append (substring a 1 (- (string-length a) 1)) "_zcopy"))
                                                           (tref x ,c) fromz toz)))
                                      (if (and (impc:ir:pointer? a)
                                               (= 1 (impc:ir:get-ptr-depth a)))
                                          `(if (llvm_ptr_in_zone fromz (cast (tref x ,c) i8*))
                                               (let ((newptr (zalloc (llvm_zone_ptr_size (cast (tref x ,c) i8*)))))
                                                 (memcpy (cast newptr i8*) (cast (tref x ,c) i8*)
                                                         (llvm_zone_ptr_size (cast (tref x ,c) i8*)))
                                                 (tset! obj ,b newptr)))
                                          `(tset! obj ,b (tref x ,c)))))
                                a arglst2 (range (length a)))))
           (body (map (lambda (a b c) `(tset! obj ,b ,c)) a arglst2 arglst1)))
      ;;(println 'hcopy: hcopy_body)
      (suppress-compiler-messages #t)
      (eval `(bind-func ,nameandtype
               (lambda ,argslist
                 (let ((obj (zalloc)))
                   ,@body
                   obj)))
            (interaction-environment))
      (eval `(bind-func ,h_nameandtype
               (lambda ,argslist
                 (let ((obj (halloc)))
                   ,@body
                   obj)))
            (interaction-environment))
      (if (not generic)
          (begin
            (eval `(bind-func ,(string->symbol (string-append namestr "_hcopy:[" namestr "*," namestr "*]*"))
                     (lambda (,(string->symbol (string-append "x:" namestr "*")))
                       (let ((obj (halloc)))
                         ,@hcopy_body
                         obj)))
                  (interaction-environment))
            (eval `(bind-poly hcopy ,(string->symbol (string-append namestr "_hcopy")))
                  (interaction-environment))
            (eval `(bind-func ,(string->symbol (string-append namestr "_hfree:[void," namestr "*]*"))
                     (lambda (,(string->symbol (string-append "x:" namestr "*")))
                       ,@hfree_body
                       (free x)
                       void))
                  (interaction-environment))
            (eval `(bind-poly hfree ,(string->symbol (string-append namestr "_hfree")))
                  (interaction-environment))
            (eval `(bind-func ,(string->symbol (string-append namestr "_zcopy:[" namestr "*," namestr "*,%mzone*,%mzone*]*"))
                     (lambda (,(string->symbol (string-append "x:" namestr "*")) fromz toz)
                       (let ((obj (zalloc)))
                         ,@zcopy_body
                         obj)))
                  (interaction-environment))
            (eval `(bind-poly zcopy ,(string->symbol (string-append namestr "_zcopy")))
                  (interaction-environment))))
      ;; (println 'dc-out: name)
      (if compiler-suppress-on
          (suppress-compiler-messages #f)
          'donothing))))


(define-macro (bind-type symbol type . args)
  (if (<> (impc:ir:get-ptr-depth type) 0)
      (impc:compiler:print-bad-type-error type "cannot be a pointer"))
  `(begin
     (set! *impc:ir:get-type-callback-off* #t)
     (if (char=? (string-ref ,(symbol->string type) 0) #\<)
         (let* ((ags (impc:ir:get-pretty-tuple-arg-strings ,(symbol->string type)))
                ;; expand all non-explict generic types
                ;; i.e. expand list* into list:<!a,list*>*
                (expand-polys (map (lambda (k)
                                     (if (and (impc:ir:gpolytype-types (impc:ir:get-base-type k))
                                              (not (equal? (impc:ir:get-base-type k) ,(symbol->string symbol)))) ;; for recursive case!
                                         (apply string-append (impc:ir:get-base-type k) ":"
                                                (symbol->string (impc:ir:gpolytype-types (impc:ir:get-base-type k)))
                                                (make-list (impc:ir:get-ptr-depth k) "*"))
                                         k))
                                   ags))
                (newtype (string-append "<" (string-join expand-polys ",") ">")))
           ;; (println 'authors_type: ,(symbol->string type))
           ;; (println 'transformed_type: newtype)
           ;; and on with the show!
           (if (regex:match? newtype "!") ;; then must be poly type
               (impc:ir:add-gpolytype ',symbol (string->symbol newtype))
               (llvm:compile-ir (string-append "%" ,(symbol->string symbol) " = type "
                                               (impc:ir:get-type-str (impc:ir:get-type-from-pretty-str
                                                                      newtype
                                                                      ,(symbol->string symbol)))))))
         (impc:compiler:print-bad-type-error ',type "must be a tuple type"))
     (begin
       (impc:ti:register-new-namedtype ,(symbol->string symbol) ,(impc:ir:get-type-from-pretty-str (symbol->string type)) "")
       (impc:compiler:print-binding-details-to-log "DataType:" ',symbol ',type))
     ;; the next line is to help specialize any element types that may not already be specialized!
     (map (lambda (a) (impc:ir:get-type-from-pretty-str a)) (impc:ir:get-pretty-tuple-arg-strings ,(symbol->string type)))
     (set! *impc:ir:get-type-callback-off* #f)
     ;; (sys:wait (now))
     ;; now compile data constructor
     ,(if (or (null? args)
              (car args))
          `(build-type-dataconstructor
            ',symbol
            (if (impc:ir:gpolytype-types ',symbol)
                (symbol->string (impc:ir:gpolytype-types ',symbol))
                (impc:ti:get-namedtype-type ,(symbol->string symbol)))
            (if (impc:ir:gpolytype-types ',symbol) #t #f)))
     ))



(define-macro (bind-tvar symbol . types)
  `(begin (if (char=? (string-ref ,(symbol->string type) 0) #\<) ; (impc:ir:tuple? (impc:ir:get-type-from-pretty-str ,(symbol->string type)))
              (llvm:compile-ir (string-append "%" ,(symbol->string symbol) " = type "
                                              ,(impc:ir:get-type-str (impc:ir:get-type-from-pretty-str (symbol->string type) (symbol->string symbol)))))
              (impc:compiler:print-bad-type-error ,type "only named tuple types are supported"))
          (impc:compiler:print-type-details-to-log
           ,symbol
           (impc:ir:pretty-print-type (impc:ti:get-namedtype-type ,(symbol->string symbol))))))

(define-macro (impc:pretty-print-vars . varlist)
  (map (lambda (var)
         `(begin (println '--- (quote ,var) '---)
                 (println ,var)))
       varlist))


;; it needs to: work for
;; - primitives
;; - pointers to primitives
;; - (null)  pointers to arrays/vectors

(define-macro (bind-val symbol type . optional-value)
  (let ((value (if (null? optional-value)
                   1
                   (car optional-value))))
    (let ((t (impc:ir:get-type-from-pretty-str (atom->string type))))
      (cond ((impc:ti:globalvar-exists? (symbol->string symbol))
             `(impc:compiler:print-already-bound-error ',symbol ',type))
            ((and (equal? "i8*" (symbol->string type))
                  (string? value))
             `(begin
                (llvm:compile-ir (string-append "@" ,(symbol->string symbol)
                                                " = dllexport global i8* zeroinitializer"))
                (call-as-xtlang ,(string->sexpr (string-append "(set! " (symbol->string symbol)
                                                               " \"" value "\")")))
                ;;(llvm:bind-global-var ,(symbol->string symbol) ,(string->cptr value))
                ,(impc:ti:register-new-globalvar (symbol->string symbol) ,(impc:ir:get-type-from-pretty-str (symbol->string type)) "")))
            ((and (or (impc:ir:number? t) (impc:ir:boolean? t))
                  (not (impc:ir:pointer? t)))
             `(begin
                (llvm:compile-ir
                 (string-append "@" ,(symbol->string symbol)
                                " = dllexport global "
                                ,(impc:ir:get-type-str t) " "
                                ,(if (= t *impc:ir:fp32*)
                                     (llvm:convert-float (atom->string (eval value)))
                                     (atom->string (eval value)))))
                (impc:ti:register-new-globalvar ,(symbol->string symbol) ,(impc:ir:get-type-from-pretty-str (symbol->string type)) "")))
            ((impc:ir:pointer? t)
             (if (integer? (eval value))
                 `(begin
                    (llvm:compile-ir (string-append "@" ,(symbol->string symbol)
                                                    " = dllexport global "
                                                    ,(impc:ir:get-type-str t)
                                                    " zeroinitializer"))
                    (call-as-xtlang ,(string->sexpr
                                      (string-append "(set! " (symbol->string symbol)
                                                     " (cast (malloc "
                                                     (atom->string (* (eval value)
                                                                      (if (impc:ir:number? t)
                                                                          (impc:ir:get-type-size t)
                                                                          (/ (sys:pointer-size) 8))))
                                                     ") "
                                                     (atom->string type)
                                                     "))")))
                    ;; (llvm:bind-global-var ,(symbol->string symbol)
                    ;;                       ,(sys:make-cptr (* (eval value)
                    ;;                                          (if (impc:ir:number? t)
                    ;;                                              (impc:ir:get-type-size t)
                    ;;                                              (/ (sys:pointer-size) 8)))))
                    (impc:ti:register-new-globalvar ,(symbol->string symbol) ,(impc:ir:pretty-print-type (symbol->string type)) ""))
                 (if (list? (eval value))
                     `(begin
                        (llvm:compile-ir (string-append "@" ,(symbol->string symbol)
                                                        " = dllexport global "
                                                        ,(impc:ir:get-type-str t)
                                                        "zeroinitializer"))
                        (call-as-xtlang ,(string->sexpr (string-append "(set! " (symbol->string symbol)
                                                                       " \"" (sexpr->string value) "\")")))
                        ;;(llvm:bind-global-var ,(symbol->string symbol) ,(string->cptr value))
                        (impc:ti:register-new-globalvar ,(symbol->string symbol) ,(impc:ir:pretty-print-type (symbol->string type)) ""))
                     `(impc:compiler:print-compiler-error "when binding global pointers, third argument should be size of buffer to allocate or a valid xtlang sexpr"))))
            ((or (impc:ir:tuple? t) (impc:ir:array? t) (impc:ir:vector? t))
             `(begin
                (llvm:compile-ir
                 (string-append
                  "@" ,(symbol->string symbol)
                  " = dllexport global "
                  ,(impc:ir:get-type-str t) " zeroinitializer"))
                (impc:ti:register-new-globalvar ,(symbol->string symbol) ,(impc:ir:pretty-print-type (symbol->string type)) "")))
            (else (impc:compiler:print-missing-type-error type))))))


(define-macro (bind-poly poly_sym implementation_sym)
  (if (impc:ir:gpoly-exists? implementation_sym)
      (impc:compiler:print-compiler-error (string-append "bind-poly only accepts monomorphic functions, not " (symbol->string implementation_sym))))
  (let ((type (impc:ti:get-closure-or-nativefunc-type (symbol->string implementation_sym))))
    ;;(set! type (impc:ir:get-type-from-pretty-str (symbol->string type)))
    `(begin (impc:ir:add-poly ',poly_sym ',implementation_sym ',type)
            (impc:compiler:print-polying-details-to-log "Overload:" ',poly_sym ',implementation_sym ,(impc:ir:pretty-print-type type)))))

;; (define-macro (bind-scm symbol type value)
;;    (if (cptr? (eval value))
;;        `(begin (if (not (llvm:get-globalvar ,(symbol->string symbol)))
;;                    (llvm:compile-ir (string-append "@" ,(symbol->string symbol)
;;                                                 " = external global "
;;                                                 ,(impc:ir:get-type-str (impc:ir:convert-from-pretty-types type)))))
;; 						;,(impc:ir:get-type-str (impc:ir:get-type-from-pretty-str type)))))
;;                ;(ipc:call ,*impc:compiler:process* 'llvm:bind-global-var ,(symbol->string symbol) ,value)
;; 	       (llvm:bind-global-var ,(symbol->string symbol) ,value)
;;          (impc:compiler:print-binding-details-to-log "Foreign:" ',symbol ',type))
;;        (if (number? (eval value))
;; 	   `(bind-val ,symbol ,type ,value)
;; 	   (impc:compiler:print-compiler-error "bind-scm only accepts cptr or numeric values!"))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; this here for wrapping llvm dynamic binds
(define-macro (bind-lib library symname type . args)
  `(__dynamic-bind ',library ',symname ',type ,@(map (lambda (k) `(quote ,k)) args)))

(define __dynamic-bind
  (lambda (library symname type . args)
    (let* ((ctype (cdr (impc:ir:get-type-from-pretty-str (symbol->string type))))
           (calling_convention (if (null? args) "ccc" (symbol->string (car args))))
           (ir-string (string-append "declare "
                                     calling_convention
                                     " "
                                     (impc:ir:get-type-str (car ctype))
                                     " @"
                                     (symbol->string symname)
                                     "("
                                     (if (null? (cdr ctype))
                                         ""
                                         (apply string-append
                                                (impc:ir:get-type-str (cadr ctype))
                                                (map (lambda (v)
                                                       (string-append "," (impc:ir:get-type-str v)))
                                                     (cddr ctype))))
                                     ") nounwind")))
      (if (and (llvm:compile-ir ir-string)
               (llvm:queue-bind-symbol (eval library) (symbol->string symname)))
          (begin
            (impc:ti:register-new-nativefunc symname (impc:ir:get-type-from-pretty-str type) "")
            (impc:compiler:print-lib-binding-details-to-log library symname type))
          (impc:compiler:print-compiler-error (string-append "could not bind! " (symbol->string symname)))))))

(define-macro (remove-func symname)
  `(begin
     (llvm:remove-globalvar ,(string-append (symbol->string symname) "_var"))
     (llvm:erase-function ,(symbol->string symname))
     (llvm:erase-function ,(string-append (symbol->string symname) "_setter"))
     (llvm:erase-function ,(string-append (symbol->string symname) "_getter"))
     (llvm:erase-function ,(string-append (symbol->string symname) "_maker"))
     (llvm:erase-function ,(string-append (symbol->string symname) "_callback"))
     (llvm:erase-function ,(string-append (symbol->string symname) "_native"))
     (llvm:erase-function ,(string-append (symbol->string symname) "_maker"))
     (llvm:remove-globalvar ,(string-append (symbol->string symname) "_var_zone"))
     (if (llvm:get-function ,(string-append (symbol->string symname) "_scheme"))
         (llvm:erase-function ,(string-append (symbol->string symname) "_scheme")))))

(define-macro (bind-lib-type library name type . args)
  (let* ((a (impc:ir:get-pretty-tuple-arg-strings (symbol->string type)))
         (namestr (symbol->string name))
         (typestr (symbol->string type)))
    `(begin
       (llvm:compile-ir ,(string-append "%" namestr " = type " (impc:ir:get-type-str (impc:ir:get-type-from-pretty-str typestr namestr)))))))

;;; this here for binding to CLOSURE in dylib
;;
;; arg is for *optional* zone size arg
(define-macro (bind-lib-func library symname type . args)
  `(begin
     (bind-lib ,library ,symname ,type fastcc)
     (bind-lib ,library ,(string->symbol (string-append (symbol->string symname) "_setter")) [void,i8*]*)
     (bind-lib ,library ,(string->symbol (string-append (symbol->string symname) "_getter")) [i8*]*)
     (bind-lib ,library ,(string->symbol (string-append (symbol->string symname) "_callback")) [void,i8*]*)
     (bind-lib ,library ,(string->symbol (string-append (symbol->string symname) "_scheme")) [i8*,i8*,i8*]*)
     (bind-lib ,library ,(string->symbol (string-append (symbol->string symname) "_native")) ,type)
     (bind-lib ,library ,(string->symbol (string-append (symbol->string symname) "_maker"))
               ,(string->symbol (string-append "[" (impc:ir:get-type-str (impc:ir:get-type-from-pretty-str (symbol->string type)))
                                               ",i8*]*")))
     (llvm:compile-ir
      (string-append "@" ,(symbol->string symname) "_var = external global [1 x i8*]\n\n"
                     "@" ,(symbol->string symname) "_var_zone = external global [1 x i8*]\n\n"))
     (llvm:queue-bind-symbol ,library ,(string-append (symbol->string symname) "_var"))
     (llvm:queue-bind-symbol ,library ,(string-append (symbol->string symname) "_var_zone"))
     ;; bind scheme function
     ;;(println (llvm:get-scheme-function ,(symbol->string symname)))
     (if (llvm:get-scheme-function ,(symbol->string symname))
         (begin
           (llvm:ffi-set-name
            (llvm:get-scheme-function ,(symbol->string symname))
            ,(symbol->string symname))
           (eval (define ,symname
                   (mk-ff (llvm:get-scheme-function ,(symbol->string symname))))
                 (interaction-environment))))
     ;; setup closure
     (let ((setter (llvm:get-function ,(string-append (symbol->string symname) "_setter"))))
       (sys:push-memzone (sys:create-mzone ,(if (null? args) *impc:default-zone-size* (car args))))
       (llvm:run setter (sys:peek-memzone))
       (sys:pop-memzone) ;; don't destroy zone here - should happen next timer around _setter
       )))


;;
;; This is exactly the same as above
;; but doesn't try to bind a scheme wrapper
;;
(define-macro (bind-lib-func-no-scm library symname type . args)
  `(begin
     (bind-lib ,library ,symname ,type fastcc)
     (bind-lib ,library ,(string->symbol (string-append (symbol->string symname) "_setter")) [void,i8*]*)
     (bind-lib ,library ,(string->symbol (string-append (symbol->string symname) "_getter")) [i8*]*)
     (bind-lib ,library ,(string->symbol (string-append (symbol->string symname) "_callback")) [void,i8*]*)
     (bind-lib ,library ,(string->symbol (string-append (symbol->string symname) "_native")) ,type)
     (bind-lib ,library ,(string->symbol (string-append (symbol->string symname) "_maker"))
               ,(string->symbol (string-append "[" (impc:ir:get-type-str (impc:ir:get-type-from-pretty-str (symbol->string type)))
                                               ",i8*]*")))
     (llvm:compile-ir
      (string-append "@" ,(symbol->string symname) "_var = external global [1 x i8*]\n\n"
                     "@" ,(symbol->string symname) "_var_zone = external global [1 x i8*]\n\n"))
     (llvm:queue-bind-symbol ,library ,(string-append (symbol->string symname) "_var"))
     (llvm:queue-bind-symbol ,library ,(string-append (symbol->string symname) "_var_zone"))
     ;; bind scheme function
     ;;(println (llvm:get-scheme-function ,(symbol->string symname)))
     (if (llvm:get-scheme-function ,(symbol->string symname))
         (begin
           (llvm:ffi-set-name
            (llvm:get-scheme-function ,(symbol->string symname))
            ,(symbol->string symname))
           (eval (define ,symname
                   (mk-ff (llvm:get-scheme-function ,(symbol->string symname))))
                 (interaction-environment))))
     ;; setup closure
     (let ((setter (llvm:get-function ,(string-append (symbol->string symname) "_setter"))))
       (sys:push-memzone (sys:create-mzone ,(if (null? args) *impc:default-zone-size* (car args))))
       (llvm:run setter (sys:peek-memzone))
       (sys:pop-memzone) ;; don't destroy zone here - should happen next timer around _setter
       )))


;;; this here for binding to CLOSURE in dylib
(define-macro (bind-lib-val library symname type)
  `(let ((ground-type (impc:ir:ground-type-aliases ,(symbol->string type))))
     (llvm:compile-ir
      (string-append "@" ,(symbol->string symname) " = external global "
                     (if ground-type ground-type ,(impc:ir:get-type-str (impc:ir:get-type-from-pretty-str (symbol->string type))))))
     (llvm:queue-bind-symbol ,library ,(symbol->string symname))))

;; THIS IS A HELPER FUNCTION
;;
;; returns a (bind-lib-xtm) form for the named function
;; by using the xtm-closure-doc to get the type
;; function must already have been compiled into module
(define-macro (bind-lib-xtm-get-string name)
  (let ((res (eval `(xtm-closure-doc ,name))))
    (if (string? res)
        `(sexpr->string '(bind-lib-xtm mathlib ,name ,(string->symbol res)))
        `(sexpr->string '(bind-lib-xtm mathlib ,name ,(string->symbol (cdr res)))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; a helper for returning a scheme closure native closure (if one exists!)
(define llvm:get-native-closure
  (lambda (name)
    (if (sys:precomp:currently-compiling?)
        (impc:compiler:print-not-during-precomp-error)
        (let ((f (llvm:get-function (string-append name "_getter"))))
          (if f (llvm:run f)
              '())))))

(define llvm:get-closure-setter
  (lambda (name)
    (if (sys:precomp:currently-compiling?)
        (impc:compiler:print-not-during-precomp-error)
        (llvm:get-function-pointer (string-append name "_setter")))))

;; a helper for returning a scheme closure native closure (if one exists!)
(define llvm:get-native-function
  (lambda (name)
    (if (sys:precomp:currently-compiling?)
        (impc:compiler:print-not-during-precomp-error)
        (llvm:get-function-pointer (string-append name "_native")))))

;; a helper for returning a scheme closure native closure (if one exists!)
(define llvm:get-scheme-function
  (lambda (name)
    (if (sys:precomp:currently-compiling?)
        (impc:compiler:print-not-during-precomp-error)
        (llvm:get-function-pointer (string-append name "_scheme")))))

;; Wrap a native, bound C function, allowing it to be called from scheme
(define-macro (bind-wrapper local-sym native-sym)
  (let* ((types (cdr (impc:ti:get-closure-arg-types (symbol->string native-sym))))
         (args (map (lambda (t v) v) types *impc:alphabetlist*))) ;; '(a b c d e f g h i j k l m n o p))))
    `(bind-func ,local-sym
       (lambda ,args
         ,(cons native-sym args)))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; very dodgy
;; generic constraints
;;
;; simply forces supplied specialisations
;; add to polys and remove gpoly
;;
;; for example
;;
;; (bind-func test:[!a,!a]*
;;   (lambda (x) (* x x)))
;;
;; (constrain-generic test [i32,i32]* [float,float]*)
;;
(define _constrain-generic
  (lambda (sym . types)
    (if (not (impc:ir:gpoly-exists? (string->symbol sym)))
        (impc:compiler:print-missing-identifier-error sym "generic function")
        (let ((printspec *impc:ti:print-code-specialization-compiles*))
          (set! *impc:ti:print-code-specialization-compiles* #t)
          (for-each
           (lambda (t)
             (if (regex:match? t "_poly_")
                 (set! t (cname-decode (cadr (regex:type-split t "_poly_")))))
             (let ((etype (cname-encode t)))
               (if (not (llvm:get-function (string-append sym "_poly_" etype)))
                   (let* ((arity (- (length (impc:ir:get-pretty-closure-arg-strings t)) 1))
                          (code (caddr (cadr (impc:ir:gpoly-types (string->symbol sym) arity t))))
                          (pfunc (string->symbol (string-append sym "_poly_" etype))))
                     ;; (println 'arity: arity 'code: code 'pfunc: pfunc)
                     (set! code `(let ((,pfunc ,code)) ,pfunc))
                     (impc:ti:run pfunc code *impc:default-zone-size* (cons pfunc (string->symbol t)))
                     (impc:ir:add-poly (string->symbol sym) pfunc t)
                     (let ((setter (llvm:get-function (string-append (symbol->string pfunc) "_setter"))))
                       (sys:push-memzone (sys:create-mzone *impc:default-zone-size*))
                       (llvm:run setter (sys:peek-memzone)) ;; (sys:create-mzone *impc:default-zone-size*))
                       (sys:pop-memzone)) ;; don't destroy - this happens in _setter func
                     pfunc))))
           types)
          (set! *impc:ti:print-code-specialization-compiles* printspec)
          (set! *impc:ir:gpolys*
                (cl:remove-if (lambda (x)
                                (if (string=? (symbol->string (car x)) sym)
                                    #t #f))
                              *impc:ir:gpolys*))
          #t))))

(define-macro (constrain-generic sym . args)
  (apply _constrain-generic
         (symbol->string sym)
         (map (lambda (x)
                (if (regex:match? (symbol->string x) "^\\$")
                    (set! x (string->symbol (string-append (symbol->string sym) ":" (symbol->string x)))))
                (symbol->string (impc:ti:expand-generic-type x))) args)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; specialize generic type!
;;
(define _specialize-type
  (lambda (sym . types)
    ;; (println 'sym: sym types)
    (if (not (impc:ir:gpolytype-types (string->symbol sym)))
        (impc:compiler:print-missing-generic-type-error sym)
        (let ((printspec *impc:ti:print-code-specialization-compiles*))
          (set! *impc:ti:print-code-specialization-compiles* #t)
          (for-each
           (lambda (t)
             (if (regex:match? t ":")
                 (set! t (cadr (regex:type-split t ":"))))
             (let ((newname (string-append sym "_poly_" (cname-encode t))))
               ;; (println `(llvm:compile-ir ,(string-append "%" newname " = type " (impc:ir:get-type-str (impc:ir:get-type-from-pretty-str t)))))
               (llvm:compile-ir (string-append "%" newname " = type " (impc:ir:get-type-str (impc:ir:get-type-from-pretty-str t))))
               (build-type-dataconstructor (string->symbol newname) t #f)))
           types)
          (set! *impc:ti:print-code-specialization-compiles* printspec)
          #t))))

(define-macro (specialize-type sym . args)
  (apply _specialize-type
         (symbol->string sym)
         (map (lambda (x)
                (if (regex:match? (symbol->string x) "^\\$")
                    (set! x (string->symbol (string-append (symbol->string sym) ":" (symbol->string x)))))
                (symbol->string (impc:ti:expand-generic-type x))) args)))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; force specializations on a generic funtion
;;
;; i.e. (specialize-generic blah [i32,i32]* [i64,i64]*)
;;
(define _specialize-generic
  (lambda (sym . types)
    (if (not (impc:ir:gpoly-exists? (string->symbol sym)))
        (impc:compiler:print-missing-identifier-error sym "generic function")
        (let ((printspec *impc:ti:print-code-specialization-compiles*))
          (set! *impc:ti:print-code-specialization-compiles* #t)
          (for-each
           (lambda (t)
             (if (regex:match? t "_poly_")
                 (set! t (cname-decode (cadr (regex:type-split t "_poly_")))))
             (let ((etype (cname-encode t)))
               (if (not (llvm:get-function (string-append sym "_poly_" etype)))
                   (let* ((arity (- (length (impc:ir:get-pretty-closure-arg-strings t)) 1))
                          (code (caddr (cadr (impc:ir:gpoly-types (string->symbol sym) arity t))))
                          (pfunc (string->symbol (string-append sym "_poly_" etype))))
                     ;; (println 'makesym etype 't: t)
                     ;; (println 'arity: arity 'code: code 'pfunc: pfunc)
                     (set! code `(let ((,pfunc ,code)) ,pfunc))
                     (impc:ti:run pfunc code *impc:default-zone-size* (cons pfunc (string->symbol t)))
                     (impc:ir:add-poly (string->symbol sym) pfunc t)
                     (let ((setter (llvm:get-function (string-append (symbol->string pfunc) "_setter"))))
                       (sys:push-memzone (sys:create-mzone *impc:default-zone-size*))
                       (llvm:run setter (sys:peek-memzone)) ;; (sys:create-mzone *impc:default-zone-size*))
                       (sys:pop-memzone)) ;; don't destroy - this happens in _setter func
                     pfunc))))
           types)
          (set! *impc:ti:print-code-specialization-compiles* printspec)
          #t))))

(define-macro (specialize-generic sym . args)
  (apply _specialize-generic
         (symbol->string sym)
         (map (lambda (x)
                (if (regex:match? (symbol->string x) "^\\$")
                    (set! x (string->symbol (string-append (symbol->string sym) ":" (symbol->string x)))))
                (symbol->string (impc:ti:expand-generic-type x))) args)))
