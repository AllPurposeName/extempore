;;; beat_detection.xtm -- real-time audio onset detection

;; Author: Ben Swift
;; Keywords: extempore
;; Required dylibs: kiss_fft, libsndfile

;;; Commentary:

;; this example shows how we can use the fft functions to detect
;; note/event onsets (especially noisy ones like drum hits).

;;; Code:

;; need to create the context before loading the graphics library
(define ctx (gl:make-ctx ":0.0" #f 0.0 0.0 1080.0 720.0))

;; load the libraries we need
(load "libs/core/audio_dsp.xtm")
(load "libs/core/math.xtm")
(load "libs/external/sndfile.xtm")
(load "libs/external/fft.xtm")
(load "libs/external/opengl.xtm")

(bind-val fft_window_length i64 256)

;; add sum of L and R channels into real component
;; of time_buffer (which is a buffer of complex values)
(bind-func preprocess_audio 100000
  (let ((window_buffer:double* (zalloc fft_window_length))
	(i:i64 0))
    (window_hanning window_buffer fft_window_length)
    (lambda (in_stereo:double* out:cpxd*)
      (dotimes (i fft_window_length)
	(tset! (pref-ptr out i) 0
	       (* (+ (pref in_stereo (* 2 i))         ; L channel
		     (pref in_stereo (+ 1 (* 2 i))))  ; R channel
		  (pref window_buffer i)))))))

(bind-func rectified_difference
  (lambda (curr:cpxd* prev:cpxd*)
    (let ((i:i64 0)
	  (sum 0.0))
      (dotimes (i (/ fft_window_length 2)) ; the spectrum is real, so it will be symmetrical
	(let ((diff (* (- (magnitude_cpxd (pref-ptr curr i))
			  (magnitude_cpxd (pref-ptr prev i)))
		       (i64tod i))))
	  (if (> diff 0.0)
	      (set! sum (+ sum diff)))))
      sum)))

;; (bind-func median
;;   (let ((i:i64 0))
;;     (lambda (buff:double* len)
;;       ())))

(bind-func onset_detection 100000
  (let ((dbuf_length 1000) ; this value might need some tweaking
        (threshold 1010.0)  ; this value might need some tweaking
        (dbuf:double* (zalloc dbuf_length))
	(dbuf_offset 0)
	(sum 0.0)
        (cnt 0))
    (lambda (value)
      ;; basic ringbuffer
      (set! sum (+ sum  (- value (pref dbuf (modulo dbuf_offset dbuf_length)))))
      (set! dbuf_offset (modulo (+ dbuf_offset 1) dbuf_length))
      (pset! dbuf dbuf_offset value)
      ;; (if (= cnt 0)
      ;;     (printf "value = %10.2f threshold = %10.2f\n"
      ;;             value (* (/ sum (i64tod dbuf_length))
      ;;                      threshold)))
      (set! cnt (modulo (+ cnt 1) 400))
      (if (> value (* (/ sum (i64tod dbuf_length))
                      threshold))
          value 0.0))))

;; take the time_domain signal (time_buffer) and return the
;; (magnitude) spectrum
(bind-func spectral_difference 100000
  (let ((time_buffer:cpxd* (zalloc fft_window_length))
	;;  double length freq buffer to accomodate both current
	;;  spectrum and previous timestep's spectrum
	(fbuf_curr:cpxd* (zalloc (* 2 fft_window_length)))
	(fbuf_prev (pref-ptr fbuf_curr fft_window_length))
	(detection_func_val 0.0))
    (lambda (audio:double*)
      (preprocess_audio audio time_buffer)
      ;; take DFT, store results in freq_buffer
      (fft_cpxd time_buffer fbuf_curr fft_window_length)
      ;; (printf "fft[0] %f\n" (tref (pref fbuf_curr 0) 0))
      ;; (printf "fft length %lld\n" fft_window_length)
      (set! detection_func_val (rectified_difference fbuf_curr fbuf_prev))
      (let ((tmp:cpxd* null))
	(set! detection_func_val
	      (onset_detection detection_func_val))
	;; (if (= 1 onset_detected) (printf "%f\n" value))
	;; some pointer jiggery-pokery
	(set! tmp fbuf_curr)
	(set! fbuf_curr fbuf_prev)
	(set! fbuf_prev tmp)
	detection_func_val))))

;; set up the type alias for our dsp function
(bind-alias DSP [double,double,double,double,double*]*)
;; dsp function - this will play the sound file.  Remember to
;; change the file path to an audio file on your system
(bind-func dsp:DSP 100000000 ; make sure we allocate enough memory
  (let ((audio_length 60)
	(audio:double* (zalloc (* 44100 2 audio_length)))
	(samples_read (read-audio-data "/Users/ben/Music/samples/drums.wav"
				       audio
				       0
				       (* 44100 audio_length)))
	(playhead 0)
        (onset_val 0.0))
    (lambda (in time chan dat)
      (if (and (= (modulo playhead fft_window_length) 0)
	       (= chan 0.0))
	  (set! onset_val (spectral_difference (pref-ptr audio playhead))))
      ;; increment playhead once per (stereo) pair of samples
      (if (= chan 1.0)
	  (set! playhead (modulo (+ playhead 2) ; +2 because it's stereo
				 (* audio_length 44100))))
      ;; play audio
      (pref audio (+ (dtoi64 chan) playhead)))))

(dsp:set! dsp)

(bind-func gl-draw
  (let ((i 0.0)
        (xval 0.0)
        (audio_len (/ SAMPLERATE 30.0)))
    (lambda (audio-ptr:double* playhead:i64)
      (glClear (+ GL_COLOR_BUFFER_BIT GL_DEPTH_BUFFER_BIT))
      (glLoadIdentity)
      (glTranslated -1.0 0.0 0.0)
      (glBegin GL_TRIANGLES_STRIP)
      (dotimes (i audio_len)
        (glColor3d (random) (random) 1.0)
        (set! xval (* 2.0 (/ i audio_len)))
        (glVertex2d xval (+ (pref audio-ptr (+ (dtoi64 i) playhead)) (* 0.1 (random))))
        (glVertex2d xval (- (pref audio-ptr (+ (dtoi64 i) playhead)) (* 0.1 (random)))))
      (glEnd))))

;; the animation callback - remember this is in scheme, not xtlang
(define beat-visualisation
  (lambda (time fps)
    ;; (println "sum = " (onset_detection.sum) "onset_val = "(dsp.onset_val))
    ;; (gl-draw (/ (dsp.onset_val) 5000.0))
    (gl-draw (dsp.audio) (dsp.playhead))
    (gl:swap-buffers ctx)
    (callback (+ time (* 0.5 (/ *samplerate* fps)))
              'beat-visualisation
              (+ time (/ *samplerate* fps))
              fps)))

(beat-visualisation (now) 60)
