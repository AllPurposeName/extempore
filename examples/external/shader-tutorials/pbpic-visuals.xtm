(sys:load "examples/external/shader-tutorials/shader-setup.xtm")

;; OpenGL setup

(call-as-xtlang
 (glDisable GL_DEPTH_TEST)
 (glDepthMask GL_FALSE)
 (glEnable GL_BLEND)
 (glBlendFunc GL_SRC_ALPHA GL_ONE)
 (glEnable GL_PROGRAM_POINT_SIZE)
 (glDisable GL_LINE_SMOOTH)
 void)

;; fields

(bind-val field_vbo VBO*)
(bind-val field_vao VAO*)

(define *field-shader*
  (create_shader (file->string "examples/external/shader-tutorials/pbpic-field.vert")
                 (file->string "examples/external/shader-tutorials/pbpic-field.frag")))

;; this data should have interleaved the `bases' of the field arrows
;; (i.e. the grid) in 2D with the ndim (i.e. 3D) field components

(bind-val field_arrows float* (call-as-xtlang (* 4 nx ny)))

;; set base verts (i.e. every second vec2) to regular grid
(call-as-xtlang
 (let ((idx 0))
   (doloop (i nx)
     (doloop (j ny)
       (set! idx (* (+ (* i nx) j) 4))
       (pset! field_arrows
              idx
              (- (* (/ (convert i float) (convert nx float)) 2.0) 1.0))
       (pset! field_arrows
              (+ idx 1)
              (- (* (/ (convert j float) (convert ny float)) 2.0) 1.0))))))

(bind-func copy_field_xy_to_arrows_buffer
  (lambda (field:float* scale_factor:float)
    (let ((field_arrows_idx 0)
          (field_idx 0)
          (max_length .25))
      ;; (doloop (k (* nxe ny))
      ;;   (set! field_idx (* k ndim))
      ;;   (if (> (pref field field_idx) max_length)
      ;;       (set! max_length
      ;;             (pref field field_idx)))
      ;;   (if (> (pref field (+ field_idx 1)) max_length)
      ;;       (set! max_length
      ;;             (pref field (+ field_idx 1)))))
      (set! scale_factor (* scale_factor (/ 1.0 max_length)))
      (doloop (i nx)
        (doloop (j ny)
          (set! field_arrows_idx (* (+ (* i nx) j) 4))
          (set! field_idx (+ (* i nxe) j 1))
          (pset! field_arrows ;; x component
                 (+ field_arrows_idx 2)
                 (+ (pref field_arrows field_arrows_idx)
                    (if (< (* scale_factor (pref field field_idx)) max_length)
                        (* scale_factor (pref field field_idx))
                        max_length)))
          (pset! field_arrows ;; x component
                 (+ field_arrows_idx 3)
                 (+ (pref field_arrows (+ field_arrows_idx 1))
                    (if (< (* scale_factor (pref field (+ field_idx 1))) max_length)
                        (* scale_factor (pref field (+ field_idx 1)))
                        max_length))))))))

;; not sure why fxyze tends to get massive (junk) numbers in it, but
;; this hack cleans them out.
(bind-func remove_guff_from_arrows_buffer
  (lambda ()
    (let ((idx 0))
      (doloop (i nx)
        (doloop (j ny)
          (set! idx (* (+ (* i ny) j) 4))
          ;; (println "idx:" idx)
          (if (> (fabs (pref field_arrows (+ 2 idx))) 1.0)
              (pset! field_arrows
                     (+ 2 idx)
                     (pref field_arrows (+ 0 idx))))
          (if (> (fabs (pref field_arrows (+ 3 idx))) 1.0)
              (pset! field_arrows
                     (+ 3 idx)
                     (pref field_arrows (+ 1 idx)))))))))

;; particles

(bind-val particle_tex Texture*)
(bind-val particle_vbo VBO*)
(bind-val particle_vao VAO*)

(define *particle-shader*
  (create_shader (file->string "examples/external/shader-tutorials/pbpic-particle.vert")
                 (file->string "examples/external/shader-tutorials/pbpic-particle.frag")))

;; init all the things
(call-as-xtlang
 (set! particle_vbo (create_vbo part_all (convert (* nvp idimp npmax))))
 (set! particle_vao (create_vao))
 (bind_attribute particle_vao particle_vbo 0 2 5 0)
 (bind_attribute particle_vao particle_vbo 1 3 5 2)
 (set! particle_tex (bind_image_texture (create_texture) "assets/images/star.png"))
 (set! field_vbo (create_vbo field_arrows (convert (* 4 nx ny))))
 (set! field_vao (create_vao))
 (bind_attribute field_vao field_vbo 0 2)
 void)

;; draw all the things

(bind-func gl_draw_field
  (lambda (program)
    (copy_field_xy_to_arrows_buffer fxyze .02)
    ;; (remove_guff_from_arrows_buffer)
    (update_vbo_data field_vbo)
    (glUseProgram program)
    (draw_vertex_array field_vao GL_LINES 0 (convert (* 4 nxe ny)))
    void))

(bind-func gl_draw_particles
  (lambda (program:GLuint)
    ;; move particles, update VBO
    (update_vbo_data particle_vbo)
    ;; draw the world
    (let ((texloc (glGetUniformLocation program "particle_tex"))
          (nxnyloc (glGetUniformLocation program "nxny")))
      (glUseProgram program)
      (glUniform1i texloc 0)
      (glUniform2f nxnyloc (convert nxe) (convert ny)))
    (draw_vertex_array particle_vao GL_POINTS 0 (* nvp npmax))
    void))

(bind-func gl_clear_colour_buffer
  (lambda ()
    (glClear GL_COLOR_BUFFER_BIT)))

(define gl-loop
  (lambda (delta-t)
    (gl_clear_colour_buffer)
    (gl_draw_particles *particle-shader*)
    (gl_draw_field *field-shader*)
    (gl:swap-buffers *gl-window*)
    (callback (+ (now) (* *second* delta-t))
              'gl-loop
              delta-t)))

;; start it running
(gl-loop 1/30)
