(sys:load "libs/external/opengl.xtm")

(bind-alias GLbitfield i32)
(bind-alias GLboolean i8)
(bind-alias GLbyte i8)
(bind-alias GLclampf i32)
(bind-alias GLenum i32)
(bind-alias GLfloat i32)
(bind-alias GLint i32)
(bind-alias GLshort i16)
(bind-alias GLsizei i32)
(bind-alias GLubyte i8)
(bind-alias GLuint i32)
(bind-alias GLushort i16)
(bind-alias GLvoid i8)
(bind-alias GLintptr i64)
(bind-alias GLsizeiptr i64)

;; (bind-val GL_UNSIGNED_BYTE_3_3_2           GLenum #x8032)
(bind-val GL_UNSIGNED_SHORT_4_4_4_4        GLenum #x8033)
;; (bind-val GL_UNSIGNED_SHORT_5_5_5_1        GLenum #x8034)
(bind-val GL_UNSIGNED_INT_8_8_8_8          GLenum #x8035)
;; (bind-val GL_UNSIGNED_INT_10_10_10_2       GLenum #x8036)
(bind-val GL_UNSIGNED_BYTE_2_3_3_REV       GLenum #x8362)
;; (bind-val GL_UNSIGNED_SHORT_5_6_5          GLenum #x8363)
(bind-val GL_UNSIGNED_SHORT_5_6_5_REV      GLenum #x8364)
;; (bind-val GL_UNSIGNED_SHORT_4_4_4_4_REV    GLenum #x8365)
(bind-val GL_UNSIGNED_SHORT_1_5_5_5_REV    GLenum #x8366)
;; (bind-val GL_UNSIGNED_INT_8_8_8_8_REV      GLenum #x8367)
(bind-val GL_UNSIGNED_INT_2_10_10_10_REV   GLenum #x8368)


;; id, type, size (bytes), data
(bind-type VBO <GLuint,GLenum,GLsizeiptr,GLvoid*>)

;; accessors

(bind-func VBO_id
  (lambda (vbo:VBO*)
    (tref vbo 0)))

(bind-func VBO_type
  (lambda (vbo:VBO*)
    (tref vbo 1)))

(bind-func VBO_size
  (lambda (vbo:VBO*)
    (tref vbo 2)))

(bind-func VBO_data
  (lambda (vbo:VBO*)
    (tref vbo 3)))

(bind-func print_VBO
  (lambda (vbo:VBO*)
    (printf "VBO: <id=%d type=%s nbytes=%d data=%p>"
            (tref vbo 0)
            (let ((type (VBO_type vbo)))
              (cond ((= type GL_BYTE) "byte")
                    ((= type GL_SHORT) "short")
                    ((= type GL_INT) "int")
                    ((= type GL_FLOAT) "float")
                    (else "unknown")))
            (tref vbo 2)
            (tref vbo 3))))

(bind-poly print print_VBO)

(bind-func tostring_VBO
  (lambda (vbo:VBO*)
    (let ((s:i8* (salloc 256)))
      (sprintf s "VBO: <id=%d type=%s nbytes=%d data=%p>"
               (tref vbo 0)
               (let ((type (VBO_type vbo)))
                 (cond ((= type GL_BYTE) "byte")
                    ((= type GL_SHORT) "short")
                    ((= type GL_INT) "int")
                    ((= type GL_FLOAT) "float")
                    (else "unknown")))
               (tref vbo 2)
               (tref vbo 3))
      (Str s))))

(bind-poly tostring tostring_VBO)

(bind-func create_vbo_float
  (lambda (buf:float* buflen)
    (let ((vbo:VBO* (zalloc))
          (id:GLuint* (salloc)))
      (glGenBuffers 1 id)
      (gl_print_error "Error creating VBO")
      (tfill! vbo
              (pref id 0)
              GL_FLOAT
              (* buflen 4) ;; sizeof(float)
              (cast buf GLvoid*))
      (printf "Created ")
      (print_VBO vbo)
      (printf "\n")
      vbo)))

(bind-func create_vbo_i32
  (lambda (buf:i32* buflen)
    (let ((vbo:VBO* (zalloc))
          (id:GLuint* (salloc)))
      (glGenBuffers 1 id)
      (gl_print_error "Error creating VBO")
      (tfill! vbo
              (pref id 0)
              GL_INT
              (* buflen 4) ;; sizeof(float)
              (cast buf GLvoid*))
      (printf "Created ")
      (print_VBO vbo)
      (printf "\n")
      vbo)))

(bind-poly create_vbo create_vbo_float)
(bind-poly create_vbo create_vbo_i32)

(bind-func bind_vbo
  (lambda (vbo:VBO*)
    (glBindBuffer GL_ARRAY_BUFFER (VBO_id vbo))
    (gl_print_error "Error binding VBO")
    (glBufferData GL_ARRAY_BUFFER (VBO_size vbo) (VBO_data vbo) GL_STREAM_DRAW)
    (gl_print_error "Error setting VBO data")))

(bind-func update_vbo
  "update the full buffer"
  (lambda (vbo:VBO*)
    (glBindBuffer GL_ARRAY_BUFFER (VBO_id vbo))
    (gl_print_error "Error binding VBO")
    (glBufferSubData GL_ARRAY_BUFFER 0 (VBO_size vbo) (VBO_data vbo))
    (gl_print_error "Error updating VBO subdata")))

(bind-func delete_vbo
  (lambda (vbo:VBO*)
    (let ((id:GLuint* (salloc)))
      (pset! id 0 (VBO_id vbo))
      (glDeleteBuffers 1 id)
      (gl_print_error "Error deleting VBO")
      (free vbo))))

(bind-type VAO <GLenum>)

(bind-func VAO_id
  (lambda (vao:VAO*)
    (tref vao 0)))

(bind-func print_VAO
  (lambda (vao:VAO*)
    (printf "VAO: id %d" (tref vao 0))))

(bind-poly print print_VAO)

(bind-func tostring_VAO
  (lambda (vao:VAO*)
    (let ((s:i8* (salloc 256)))
      (sprintf s "VAO: id %d" (tref vao 0))
      (Str s))))

(bind-poly tostring tostring_VAO)

(bind-func create_vao
  (lambda ()
    (let ((vao:VAO* (zalloc))
          (id:GLuint* (salloc)))
      (glGenVertexArrays 1 id)
      (gl_print_error "Error creating VAO")
      (tset! vao 0 (pref id 0))
      vao)))

(bind-func bind_attribute_full
  (lambda (vao:VAO* vbo:VBO* index size stride offset)
    (glBindVertexArray (VAO_id vao))
    (gl_print_error "Error binding VAO")
    (glEnableVertexAttribArray index)
    (gl_print_error "Error enabling VAO attribute")
    (glBindBuffer GL_ARRAY_BUFFER (VBO_id vbo))
    (gl_print_error "Error binding VBO")
    (glVertexAttribPointer index size (VBO_type vbo) GL_FALSE stride (pref-ptr (cast null GLvoid*) offset))
    (gl_print_error "Error binding VAO attribute")))

(bind-func bind_attribute_packed
  (lambda (vao vbo index size)
    (bind_attribute_full vao vbo index size 0 0)))

(bind-poly bind_attribute bind_attribute_full)
(bind-poly bind_attribute bind_attribute_packed)

(bind-func draw_vertex_array
  (lambda (vao:VAO* draw_mode first_element count)
    (glBindVertexArray (VAO_id vao))
    (gl_print_error "Error binding vertex array")
    (glDrawArrays draw_mode first_element count)
    (gl_print_error "Error drawing vertex array")))

(bind-func delete_vao
  (lambda (vao:VAO*)
    (let ((id:GLuint* (salloc)))
      (pset! id 0 (VAO_id vao))
      (glDeleteVertexArrays 1 id)
      (gl_print_error "Error deleting VAO")
      (free vao))))

(bind-type Texture <GLenum>)

(bind-func Texture_id
  (lambda (tex:Texture*)
    (tref tex 0)))

(bind-func print_Texture
  (lambda (vao:Texture*)
    (printf "Texture: id %d" (tref vao 0))))

(bind-poly print print_Texture)

(bind-func tostring_Texture
  (lambda (vao:Texture*)
    (let ((s:i8* (salloc 256)))
      (sprintf s "Texture: id %d" (tref vao 0))
      (Str s))))

(bind-poly tostring tostring_Texture)

(bind-func create_texture
  (lambda ()
    (let ((tex:Texture* (zalloc))
          (id:GLuint* (salloc)))
      (glGenTextures 1 id)
      (gl_print_error "Error creating Texture")
      (tset! tex 0 (pref id 0))
      (printf "Created ")
      (print_Texture tex)
      (printf "\n")
      tex)))

;; (bind-func bind_texture
;;   (lambda (tex:Texture* data:GLvoid*)
;;     (glBindTexture GL_TEXTURE_2D (Texture_id tex))
;;     (glTexImage2D GL_TEXTURE_2D 0 GL_RGB 2 2 0 GL_RGB GL_FLOAT data)
;;     (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_WRAP_S GL_CLAMP_TO_EDGE)
;;     (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_WRAP_T GL_CLAMP_TO_EDGE)
;;     (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_MIN_FILTER GL_LINEAR)
;;     (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_MAG_FILTER GL_LINEAR)
;;     void))

(bind-func delete_texture
  (lambda (tex:Texture*)
    (let ((id:GLuint* (salloc)))
      (pset! id 0 (Texture_id tex))
      (glDeleteTextures 1 id)
      (gl_print_error "Error deleting Texture")
      (free tex))))

;; stb_image is a helper library for loading image data

(sys:load "libs/external/stb_image.xtm")

(bind-func bind_image_texture
  (lambda (tex filename)
    (let ((width_ptr:i32* (salloc))
          (height_ptr:i32* (salloc))
          (comp_ptr:i32* (salloc))
          (data (stbi_load filename width_ptr height_ptr comp_ptr 4)))
      (if (null? data)
          (begin (println (stbi_failure_reason))
                 null)
          (begin
            (glActiveTexture GL_TEXTURE0)
            (glBindTexture GL_TEXTURE_2D (Texture_id tex))
            (glTexImage2D GL_TEXTURE_2D 0
                          GL_RGBA
                          (pref width_ptr 0)
                          (pref height_ptr 0)
                          0
                          GL_RGBA
                          GL_UNSIGNED_BYTE
                          data)
            ;; set some parameters
            (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_WRAP_S GL_CLAMP_TO_EDGE)
            (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_WRAP_T GL_CLAMP_TO_EDGE)
            (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_MIN_FILTER GL_LINEAR)
            (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_MAG_FILTER GL_LINEAR)
            (gl_print_error "couldn't bind_image_texture")
            tex)))))

;; this should be in opengl.xtm at some stage

(bind-func create_geom_shader
  (lambda (vsource:i8* gsource:i8* fsource:i8*)
    (let ((fshader (glCreateShader GL_FRAGMENT_SHADER))
          (gshader (glCreateShader GL_GEOMETRY_SHADER))
          (vshader (glCreateShader GL_VERTEX_SHADER))
          (fcode:|1,i8*|* (salloc 1))
          (gcode:|1,i8*|* (salloc 1))
          (vcode:|1,i8*|* (salloc 1))
          (program (glCreateProgram))
          (temp:i32* (salloc 1)))
      (pset! fcode 0 fsource)
      (pset! gcode 0 fsource)
      (pset! vcode 0 vsource)
      (glShaderSource vshader 1 (cast vcode i8**) (bitcast null i32*))
      (glShaderSource gshader 1 (cast gcode i8**) (bitcast null i32*))
      (glShaderSource fshader 1 (cast fcode i8**) (bitcast null i32*))
      (glCompileShader vshader)
      (glCompileShader gshader)
      (glCompileShader fshader)
      (glAttachShader program vshader)
      (glAttachShader program gshader)
      (glAttachShader program fshader)
      (glLinkProgram program)
      (printf "Vert ")(print_shader_info_log vshader)
      (printf "Geom ")(print_shader_info_log gshader)
      (printf "Frag ")(print_shader_info_log fshader)
      (print_program_info_log program)
      program)))

;; actually do the things...

(bind-val width float 1440.0)
(bind-val height float 900.0)
(define fullscreen #t)

(define *gl-window* (gl:make-ctx-core ":0.0" fullscreen 0.0 0.0 
                                      (call-as-xtlang width) 
                                      (call-as-xtlang height)))

;; how did it all go?

(gl_print_driver_info)
