;;; nanovg.xtm -- nanovg 2D graphics example

;; Author: Ben Swift
;; Keywords: extempore
;; Required dylibs: libnanovg

;;; Commentary:

;;

;;; Code:

(sys:load "libs/external/glfw3.xtm")
(sys:load "libs/external/nanovg.xtm")

(bind-val window GLFWwindow*)
(bind-val vg NVGcontext*)

(call-as-xtlang
 (set! window (glfw_init_and_create_window 800 600)))

;; GLFW testing

(call-as-xtlang
 (let ((w:double* (salloc))
       (h:double* (salloc)))
   (glfwGetCursorPos window w h)
   (println (pref w 0)
            (pref h 0))))

(bind-func get_window_ptr
  (lambda ()
    window))

(println (get_window_ptr))

(glfw_set_key_callback (get_window_ptr)
                       (llvm:get-function-pointer "glfw_key_callback_native"))

;; more setup

(call-as-xtlang
 (set! vg (nvgCreateGL3 (+ NVG_ANTIALIAS NVG_STENCIL_STROKES NVG_DEBUG)))
 (glEnable GL_STENCIL_TEST)
 (let ((bits:i32* (salloc)))
   (glGetIntegerv GL_MAX_DEPTH_TEXTURE_SAMPLES bits)
   (println "stencil buffer bit depth: " (pref bits 0))))

(bind-val ICON_SEARCH i32 #x1F50D)
(bind-val ICON_CIRCLED_CROSS i32 #x2716)
(bind-val ICON_CHEVRON_RIGHT i32 #xE75E)
(bind-val ICON_CHECK i32 #x2713)
(bind-val ICON_LOGIN i32 #xE740)
(bind-val ICON_TRASH i32 #xE729)

(bind-func maxf
  (lambda (a:float b)
    (if (> a b) a b)))

(bind-func minf
  (lambda (a:float b)
    (if (> a b) a b)))

(bind-func mini
  (lambda (a:i32 b)
    (if (> a b) a b)))

(bind-func clampf
  (lambda (a:float mn mx)
    (if (< a mn)
        mn
        (if (> a mx)
            mx
            a))))

(bind-func isBlack
  (lambda (col:NVGcolor)
    (if (and (= (tref col 0) 0.0)
             (= (tref col 1) 0.0)
             (= (tref col 2) 0.0)
             (= (tref col 3) 0.0))
        #t
        #f)))

(bind-func cpToUTF8
  (lambda (cp:i32 str:i8*)
    (let ((n:i32 0))
      (cond ((< cp #x80) (set! n 1))
            ((< cp #x800) (set! n 2))
            ((< cp #x10000) (set! n 3))
            ((< cp #x200000) (set! n 4))
            ((< cp #x4000000) (set! n 5))
            ((<= cp #x7fffffff) (set! n 6)))
      (pset! str n 0)
      (if (= n 6) (pset! str 5 (convert (bitwise-or (convert #x80 i32) (& cp #x3f)) i8))) ;; cp = cp >> 6; cp |= 0x4000000
      (if (= n 5) (pset! str 4 (convert (bitwise-or (convert #x80 i32) (& cp #x3f)) i8))) ;; cp = cp >> 6; cp |= 0x200000
      (if (= n 4) (pset! str 3 (convert (bitwise-or (convert #x80 i32) (& cp #x3f)) i8))) ;; cp = cp >> 6; cp |= 0x10000
      (if (= n 3) (pset! str 2 (convert (bitwise-or (convert #x80 i32) (& cp #x3f)) i8))) ;; cp = cp >> 6; cp |= 0x800
      (if (= n 2) (pset! str 1 (convert (bitwise-or (convert #x80 i32) (& cp #x3f)) i8))) ;; cp = cp >> 6; cp |= 0xc0
      (if (= n 1) (pset! str 0 (convert cp i8)))
      str)))

(bind-func drawWindow
  (lambda (vg title x y w h)
    (let ((cornerRadius 3.0)
          (shadowPaint
           (nvgBoxGradient vg x (+ y 2.0) w h (* cornerRadius 2.0) 10.0 (nvgRGBA 0 0 0 128) (nvgRGBA 0 0 0 0)))
          (headerPaint
           (nvgLinearGradient vg x y x (+ y 15.0) (nvgRGBA 255 255 255 8) (nvgRGBA 0 0 0 16))))
      (nvgSave vg)
      ;; (nvgClearState vg)

      ;; Window
      (nvgBeginPath vg)
      (nvgRoundedRect vg x y w h cornerRadius)
      (nvgFillColor vg (nvgRGBA 28 30 34 192))
      ;; (nvgFillColor vg (nvgRGBA 0 0 0 128))
      (nvgFill vg)

      ;; Drop shadow
      (nvgBeginPath vg)
      (nvgRect vg (- x 10.0) (- y 10.0) (+ w 20.0) (+ h 30.0))
      (nvgRoundedRect vg x y w h cornerRadius)
      (nvgPathWinding vg NVG_HOLE)
      (nvgFillPaint vg shadowPaint)
      (nvgFill vg)

      ;; Header
      (nvgBeginPath vg)
      (nvgRoundedRect vg (+ x 1.0) (+ y 1.0) (- w 2.0) 30.0 (- cornerRadius 1.0))
      (nvgFillPaint vg headerPaint)
      (nvgFill vg)
      (nvgBeginPath vg)
      (nvgMoveTo vg (+ x 0.5) (+ y 0.5 30.0))
      (nvgLineTo vg (- (+ x 0.5 w) 1.0) (+ y 0.5 30.0))
      (nvgStrokeColor vg (nvgRGBA 0 0 0 32))
      (nvgStroke vg)

      (nvgFontSize vg 18.0)
      (nvgFontFace vg "sans-bold")
      (nvgTextAlign vg (bitwise-or NVG_ALIGN_CENTER NVG_ALIGN_MIDDLE))

      (nvgFontBlur vg 2.0)
      (nvgFillColor vg (nvgRGBA 0 0 0 128))
      (nvgText vg (/ (+ x w) 2.0) (+ y 17.0) title null)

      (nvgFontBlur vg 0.0)
      (nvgFillColor vg (nvgRGBA 220 220 220 160))
      (nvgText vg (/ (+ x w) 2.0) (+ y 16.0) title null)

      (nvgRestore vg))))

(bind-func drawSearchBox
  (lambda (vg text x y w h)
    (let ((bg (nvgBoxGradient vg x (+ y 1.5) w h (/ h 2.0) 5.0 (nvgRGBA 0 0 0 16) (nvgRGBA 0 0 0 92)))
          (icon:i8* (salloc 8))
          (cornerRadius (- (/ h 2.) 1.)))
      (nvgBeginPath vg)
      (nvgRoundedRect vg x y w h cornerRadius)
      (nvgFillPaint vg bg)
      (nvgFill vg)

      ;; /*	nvgBeginPath(vg)
      ;; 	nvgRoundedRect(vg, x+0.5,y+0.5, w-1,h-1, cornerRadius-0.5)
      ;; 	nvgStrokeColor(vg, (nvgRGBA 0,0,0,48
      ;; 	nvgStroke))(vg);*/

      (nvgFontSize vg (* h 1.3))
      (nvgFontFace vg "icons")
      (nvgFillColor vg (nvgRGBA 255 255 255 64))
      (nvgTextAlign vg (bitwise-or NVG_ALIGN_CENTER NVG_ALIGN_MIDDLE))
      (nvgText vg (+ x (* h 0.55)) (+ y (* h 0.55)) (cpToUTF8 ICON_SEARCH icon) null)

      (nvgFontSize vg 20.0)
      (nvgFontFace vg "sans")
      (nvgFillColor vg (nvgRGBA 255 255 255 32))

      (nvgTextAlign vg (bitwise-or NVG_ALIGN_LEFT NVG_ALIGN_MIDDLE))
      (nvgText vg (+ x (* h 1.05)) (+ y (* h 0.5)) text null)

      (nvgFontSize vg (* h 1.3))
      (nvgFontFace vg "icons")
      (nvgFillColor vg (nvgRGBA 255 255 255 32))
      (nvgTextAlign vg (bitwise-or NVG_ALIGN_CENTER NVG_ALIGN_MIDDLE))
      (nvgText vg (- (+ x w) (* h 0.55)) (+ y (* h 0.55)) (cpToUTF8 ICON_CIRCLED_CROSS icon) null))))

(bind-func drawDropDown
  (lambda (vg text x y w h)
    (let ((bg (nvgLinearGradient vg x y x (+ y h) (nvgRGBA 255 255 255 16) (nvgRGBA 0 0 0 16)))
          (icon:i8* (salloc 8))
          (cornerRadius 4.0))
      (nvgBeginPath vg)
      (nvgRoundedRect vg (+ x 1.) (+ y 1.) (- w 2.) (- h 2.) (- cornerRadius 1.))
      (nvgFillPaint vg bg)
      (nvgFill vg)

      (nvgBeginPath vg)
      (nvgRoundedRect vg (+ x 0.5) (+ y 0.5) (- w 1.) (- h 1.) (- cornerRadius 0.5))
      (nvgStrokeColor vg (nvgRGBA 0 0 0 48))
      (nvgStroke vg)

      (nvgFontSize vg 20.0)
      (nvgFontFace vg "sans")
      (nvgFillColor vg (nvgRGBA 255 255 255 160))
      (nvgTextAlign vg (bitwise-or NVG_ALIGN_LEFT NVG_ALIGN_MIDDLE))
      (nvgText vg (+ x (* h 0.3)) (+ y (* h 0.5)) text null)

      (nvgFontSize vg (* h 1.3))
      (nvgFontFace vg "icons")
      (nvgFillColor vg (nvgRGBA 255 255 255 64))
      (nvgTextAlign vg (bitwise-or NVG_ALIGN_CENTER NVG_ALIGN_MIDDLE))
      (nvgText vg (- (+ x w) (* h 0.5)) (+ y (* h 0.5)) (cpToUTF8 ICON_CHEVRON_RIGHT icon) null))))

(bind-func drawLabel
  (lambda (vg text x y w:float h)
    (nvgFontSize vg 18.0)
    (nvgFontFace vg "sans")
    (nvgFillColor vg (nvgRGBA 255 255 255 128))
    (nvgTextAlign vg (bitwise-or NVG_ALIGN_LEFT NVG_ALIGN_MIDDLE))
    (nvgText vg x (+ y (* h 0.5)) text null)))

(bind-func drawEditBoxBase
  (lambda (vg x y w h)
    (let ((bg (nvgBoxGradient vg (+ x 1.) (+ y 2.5) (- w 2.) (- h 2.) 3. 4. (nvgRGBA 255 255 255 32) (nvgRGBA 32 32 32 32))))
      ;; Edit
      (nvgBeginPath vg)
      (nvgRoundedRect vg (+ x 1.) (+ y 1.) (- w 2.) (- h 2.) 3.)
      (nvgFillPaint vg bg)
      (nvgFill vg)
      (nvgBeginPath vg)
      (nvgRoundedRect vg (+ x 0.5) (+ y 0.5) (- w 1.) (- h 1.) 3.5)
      (nvgStrokeColor vg (nvgRGBA 0 0 0 48))
      (nvgStroke vg))))

(bind-func drawEditBox
  (lambda (vg text x y w h)
    (drawEditBoxBase vg x y w h)
    (nvgFontSize vg 20.0)
    (nvgFontFace vg "sans")
    (nvgFillColor vg (nvgRGBA 255 255 255 64))
    (nvgTextAlign vg (bitwise-or NVG_ALIGN_LEFT NVG_ALIGN_MIDDLE))
    (nvgText vg (+ x (* h 0.3)) (+ y (* h 0.5)) text null)))

(bind-func drawEditBoxNum
  (lambda (vg text units x y w h)
  	(let ((uw (nvgTextBounds vg 0. 0. units null null)))
      (drawEditBoxBase vg x y w h)

      (nvgFontSize vg 18.0)
      (nvgFontFace vg "sans")
      (nvgFillColor vg (nvgRGBA 255 255 255 64))
      (nvgTextAlign vg (bitwise-or NVG_ALIGN_RIGHT NVG_ALIGN_MIDDLE))
      (nvgText vg (- (+ x w) (* h 0.3)) (+ y (* h 0.5)) units null)

      (nvgFontSize vg 20.0)
      (nvgFontFace vg "sans")
      (nvgFillColor vg (nvgRGBA 255 255 255 128))
      (nvgTextAlign vg (bitwise-or NVG_ALIGN_RIGHT NVG_ALIGN_MIDDLE))
      (nvgText vg (- (- (+ x w) uw) (* h 0.5)) (+ y (* h 0.5)) text null))))

(bind-func drawCheckBox
  (lambda (vg text x y w:float h)
    (let ((bg (nvgBoxGradient vg (+ x 1.) (+ y (floor (* h 0.5)) -8.) 18. 18. 3. 3. (nvgRGBA 0 0 0 32) (nvgRGBA 0 0 0 92)))
          (icon:i8* (salloc 8)))
      (nvgFontSize vg 18.0)
      (nvgFontFace vg "sans")
      (nvgFillColor vg (nvgRGBA 255 255 255 160))

      (nvgTextAlign vg (bitwise-or NVG_ALIGN_LEFT NVG_ALIGN_MIDDLE))
      (nvgText vg (+ x 28.) (+ y (* h 0.5)) text null)

      (nvgBeginPath vg)
      (nvgRoundedRect vg (+ x 1.) (+ y (floor (* h 0.5)) -9.) 18. 18. 3.)
      (nvgFillPaint vg bg)
      (nvgFill vg)

      (nvgFontSize vg 40.)
      (nvgFontFace vg "icons")
      (nvgFillColor vg (nvgRGBA 255 255 255 128))
      (nvgTextAlign vg (bitwise-or NVG_ALIGN_CENTER NVG_ALIGN_MIDDLE))
      (nvgText vg (+ x 11.) (+ y (* h 0.5)) (cpToUTF8 ICON_CHECK icon) null))))

(bind-func drawButton
  (lambda (vg preicon text x y w h col)
    (let ((bg (nvgLinearGradient vg x y x (+ y h) (nvgRGBA 255 255 255 (if (isBlack col) 16 32)) (nvgRGBA 0 0 0 (if (isBlack col) 16 32))))
          (icon:i8* (salloc 8))
          (cornerRadius 4.0)
          (iw 0.0)
          (tw (nvgTextBounds vg 0. 0. text null null)))
      (nvgBeginPath vg)
      (nvgRoundedRect vg (+ x 1.) (+ y 1.) (- w 2.) (- h 2.) (- cornerRadius 1.))
      (if (not (isBlack col))
          (begin
            (nvgFillColor vg col)
            (nvgFill vg)))
      (nvgFillPaint vg bg)
      (nvgFill vg)

      (nvgBeginPath vg)
      (nvgRoundedRect vg (+ x 0.5) (+ y 0.5) (- w 1.) (- h 1.) (- cornerRadius 0.5))
      (nvgStrokeColor vg (nvgRGBA 0 0 0 48))
      (nvgStroke vg)

      (nvgFontSize vg 20.0)
      (nvgFontFace vg "sans-bold")
      (if (<> preicon 0)
          (begin
            ;; this code has been consilidated a bit
            (nvgFontSize vg (* h 1.3))
            (nvgFontFace vg "icons")
            (set! iw (nvgTextBounds vg 0. 0. (cpToUTF8 preicon icon) null null))
            (set! iw (+ iw (* h 0.15)))
            (nvgFillColor vg (nvgRGBA 255 255 255 96))
            (nvgTextAlign vg (bitwise-or NVG_ALIGN_LEFT NVG_ALIGN_MIDDLE))
            (nvgText vg (- (- (+ x (* w 0.5)) (* tw 0.5)) (* iw 0.75)) (+ y (* h 0.5)) (cpToUTF8 preicon icon) null)))

      (nvgFontSize vg 20.0)
      (nvgFontFace vg "sans-bold")
      (nvgTextAlign vg (bitwise-or NVG_ALIGN_LEFT NVG_ALIGN_MIDDLE))
      (nvgFillColor vg (nvgRGBA 0 0 0 160))
      (nvgText vg (+ (- (+ x (* w 0.5)) (* tw 0.5)) (* iw 0.25)) (+ y (* h 0.5) -1.) text null)
      (nvgFillColor vg (nvgRGBA 255 255 255 160))
      (nvgText vg (+ (- (+ x (* w 0.5)) (* tw 0.5)) (* iw 0.25)) (+ y (* h 0.5)) text null))))

(bind-func drawSlider
  (lambda (vg pos x y w h)
    (let ((cy:float (+ y (floor (* h 0.5))))
          (kr (floor (* h 0.25)))
          (bg (nvgBoxGradient vg x (- cy 3.) w 4. 2. 2. (nvgRGBA 0 0 0 32) (nvgRGBA 0 0 0 128)))
          (knob (nvgLinearGradient vg x (- cy kr) x (+ cy kr) (nvgRGBA 255 255 255 16) (nvgRGBA 0 0 0 16))))
      (nvgSave vg)
      ;; (nvgClearState vg)

      ;; Slot
      (nvgBeginPath vg)
      (nvgRoundedRect vg x (- cy 2.) w 4. 2.)
      (nvgFillPaint vg bg)
      (nvgFill vg)

      ;; Knob Shadow
      (nvgBeginPath vg)
      (nvgRect vg (- (+ x (floor (* pos w))) kr 5.)  (- cy kr 5.) (+ (* kr 2.) 10.) (+ (* kr 2.) 13.))
      (nvgCircle vg (+ x (floor (* pos w))) cy kr)
      (nvgPathWinding vg NVG_HOLE)
      (nvgFillPaint vg bg)
      (nvgFill vg)

      ;; Knob
      (nvgBeginPath vg)
      (nvgCircle vg (+ x (floor (* pos w))) cy (- kr 1.0))
      (nvgFillColor vg (nvgRGBA 40 43 48 255))
      (nvgFill vg)
      (nvgFillPaint vg knob)
      (nvgFill vg)

      (nvgBeginPath vg)
      (nvgCircle vg (+ x (floor (* pos w))) cy (- kr 0.5))
      (nvgStrokeColor vg (nvgRGBA 0 0 0 92))
      (nvgStroke vg)

      (nvgRestore vg))))


(bind-func drawEyes
  (lambda (vg x y w h mx my t)
    (let ((ex (* w 0.23))
          (ey (* h 0.5))
          (lx (+ x ex))
          (ly (+ y ey))
          (rx (- (+ x w) ex))
          (ry (+ y ey))
          (dx (/ (- mx rx) (* ex 10.0)))
          (dy (/ (- my ry) (* ey 10.0)))
          (d (sqrt (+ (* dx dx) (* dy dy))))
          (br (* (minf ex ey) 0.5))
          (blink:float (- 1.0 (* (pow (sin (* t 0.5)) 200.0) 0.8)))
          (bg (nvgLinearGradient vg x (+ y (* h 0.5)) (+ x (* w 0.1)) (+ y h) (nvgRGBA 0 0 0 32) (nvgRGBA 0 0 0 16)))
          (gloss (nvgRadialGradient vg (- lx (* ex 0.25)) (- ly (* ey 0.5)) (* ex 0.1) (* ex 0.75) (nvgRGBA 255 255 255 128) (nvgRGBA 255 255 255 0))))

      (nvgBeginPath vg)
      (nvgEllipse vg (+ lx 3.0) (+ ly 16.0) ex ey)
      (nvgEllipse vg (+ rx 3.0) (+ ry 16.0) ex ey)
      (nvgFillPaint vg bg)
      (nvgFill vg)

      (set! bg (nvgLinearGradient vg x (+ y (* h 0.25)) (+ x (* w 0.1)) (+ y h) (nvgRGBA 220 220 220 255) (nvgRGBA 128 128 128 255)))
      (nvgBeginPath vg)
      (nvgEllipse vg lx ly ex ey)
      (nvgEllipse vg rx ry ex ey)
      (nvgFillPaint vg bg)
      (nvgFill vg)

      (if (> d 1.0)
          (begin
            (set! dx (/ dx d))
            (set! dy (/ dy d))))

      (set! dx (* dx ex 0.4))
      (set! dy (* dy ey 0.5))
      (nvgBeginPath vg)
      (nvgEllipse vg (+ lx dx) (+ ly dy (* ey 0.25 blink)) br (* br blink))
      (nvgFillColor vg (nvgRGBA 32 32 32 255))
      (nvgFill vg)

      (set! dx (/ (- mx rx) (* ex 10.0)))
      (set! dy (/ (- my ry) (* ey 10.0)))
      (set! d (sqrt (+ (* dx dx) (* dy dy))))

      (if (> d 1.0)
          (begin
            (set! dx (/ dx d))
            (set! dy (/ dy d))))

      (set! dx (* dx ex 0.4))
      (set! dy (* dy ey 0.5))

      (set! dx (* dx ex 0.4))
      (set! dy (* dy ey 0.5))
      (nvgBeginPath vg)
      (nvgEllipse vg (+ rx dx) (+ ry dy (* ey 0.25 blink)) br (* br blink))
      (nvgFillColor vg (nvgRGBA 32 32 32 255))
      (nvgFill vg)

      (nvgBeginPath vg)
      (nvgEllipse vg lx ly ex ey)
      (nvgFillPaint vg gloss)
      (nvgFill vg)

      (set! gloss (nvgRadialGradient vg (- rx (* ex 0.25)) (- ry (* ey 0.5)) (* ex 0.1) (* ex 0.75) (nvgRGBA 255 255 255 128) (nvgRGBA 255 255 255 0)))
      (nvgBeginPath vg)
      (nvgEllipse vg rx ry ex ey)
      (nvgFillPaint vg gloss)
      (nvgFill vg))))

(bind-func drawGraph
  (lambda (vg x y w h t)
    (let ((bg (nvgLinearGradient vg x y x (+ y h) (nvgRGBA 0 160 192 0) (nvgRGBA 0 160 192 64)))
          (samples:float* (salloc 6))
          (sx:float* (salloc 6))
          (sy:float* (salloc 6))
          (dx (/ w 5.0:float))
          (i 0))
      (pfill! samples
              (+ 1. (* (sin (+ (* t 1.2345) (* (cos (* t 0.33457)) 0.44))) 0.5))
              (+ 1. (* (sin (+ (* t 0.68363) (* (cos (* t 1.3)) 1.55))) 0.5))
              (+ 1. (* (sin (+ (* t 1.1642) (* (cos (* t 0.33457)) 1.24))) 0.5))
              (+ 1. (* (sin (+ (* t 0.56345) (* (cos (* t 1.63)) 0.14))) 0.5))
              (+ 1. (* (sin (+ (* t 1.6245) (* (cos (* t 0.254)) 0.3))) 0.5))
              (+ 1. (* (sin (+ (* t 0.345) (* (cos (* t 0.03)) 0.6))) 0.5)))

      (dotimes (i 6)
        (pset! sx i (+ x (* (convert i) dx)))
        (pset! sy i (* (+ y h) (pref samples i) 0.8)))

      ;; Graph background
      (nvgBeginPath vg)
      (nvgMoveTo vg (pref sx 0) (pref sy 0))

      (dotimes (i 1 5)
        (nvgBezierTo vg
                     (+ (pref sx (- i 1)) (* dx 0.5))
                     (pref sy (- i 1))
                     (- (pref sx i) (* dx 0.5))
                     (pref sy i)
                     (pref sx i)
                     (pref sy i)))
      (nvgLineTo vg (+ x w) (+ y h))
      (nvgLineTo vg x (+ y h))
      (nvgFillPaint vg bg)
      (nvgFill vg)

      ;; Graph line
      (nvgBeginPath vg)
      (nvgMoveTo vg (pref sx 0) (+ (pref sy 0) 2.))

      (dotimes (i 1 5)
        (nvgBezierTo vg
                     (+ (pref sx (- i 1)) (* dx 0.5))
                     (+ (pref sy (- i 1)) 2.)
                     (- (pref sx i) (* dx 0.5))
                     (+ (pref sy i) 2.)
                     (pref sx i)
                     (+ (pref sy i) 2.)))
      (nvgStrokeColor vg (nvgRGBA 0 0 0 32))
      (nvgStrokeWidth vg 3.0)
      (nvgStroke vg)

      (nvgBeginPath vg)
      (nvgMoveTo vg (pref sx 0) (pref sy 0))

      (dotimes (i 1 5)
        (nvgBezierTo vg
                     (+ (pref sx (- i 1)) (* dx 0.5))
                     (pref sy (- i 1))
                     (- (pref sx i) (* dx 0.5))
                     (pref sy i)
                     (pref sx i)
                     (pref sy i)))

      (nvgStrokeColor vg (nvgRGBA 0 160 192 255))
      (nvgStrokeWidth vg 3.0)
      (nvgStroke vg)

      ;; Graph sample pos
      (dotimes (i 6)
        (set! bg (nvgRadialGradient vg (pref sx i) (+ (pref sy i) 2.) 3.0 8.0 (nvgRGBA 0 0 0 32) (nvgRGBA 0 0 0 0)))
        (nvgBeginPath vg)
        (nvgRect vg (- (pref sx i) 10.) (- (pref sy i) 8.) 20. 20.)
        (nvgFillPaint vg bg)
        (nvgFill vg))

      (nvgBeginPath vg)
      (dotimes (i 6)
        (nvgCircle vg (pref sx i) (pref sy i) 4.0))
      (nvgFillColor vg (nvgRGBA 0 160 192 255))
      (nvgFill vg)
      (nvgBeginPath vg)
      (dotimes (i 6)
        (nvgCircle vg (pref sx i) (pref sy i) 2.0))
      (nvgFillColor vg (nvgRGBA 220 220 220 255))
      (nvgFill vg)

      (nvgStrokeWidth vg 1.0))))


(bind-func drawSpinner
  (lambda (vg cx cy r:float t:float)
    (let ((a0 (+ 0.0 (* t 6.)))
          (a1 (+ 3.1416 (* t 6.)))
          (r0 r)
          (r1 (* r 0.75))
          (ax (+ cx (* (cos a0) (+ r0 r1) 0.5)))
          (ay (+ cy (* (sin a0) (+ r0 r1) 0.5)))
          (bx (+ cx (* (cos a1) (+ r0 r1) 0.5)))
          (by (+ cy (* (sin a1) (+ r0 r1) 0.5)))
          (paint (nvgLinearGradient vg ax ay bx by (nvgRGBA 0 0 0 0) (nvgRGBA 0 0 0 128))))
      (nvgSave vg)

      (nvgBeginPath vg)
      (nvgArc vg cx cy r0 a0 a1 NVG_CW)
      (nvgArc vg cx cy r1 a1 a0 NVG_CCW)
      (nvgClosePath vg)
      (nvgFillPaint vg paint)
      (nvgFill vg)

      (nvgRestore vg))))


(bind-func drawThumbnails
  (lambda (vg x y w h images nimages:i32 t)
    (let ((cornerRadius 3.0)
          (shadowPaint (nvgBoxGradient vg x (+ y 4.) w h (* cornerRadius 2.) 20. (nvgRGBA 0 0 0 128) (nvgRGBA 0 0 0 0)))
          (imgPaint shadowPaint)
          (fadePaint shadowPaint)
          (ix 0.)
          (iy 0.)
          (iw 0.)
          (ih 0.)
          (thumb 60.0)
          (arry 30.5)
          (imgw_ptr:i32* (salloc))
          (imgh_ptr:i32* (salloc))
          (stackh (+ (* (convert (/ nimages 2)) (+ thumb 10.0)) 10.))
          (i:i32 0)
          (u (* (+ 1.0 (cos (* t 0.5))) 0.5))
          (u2 (* (- 1.0 (cos (* t 0.2))) 0.5))
          (scrollh (* (/ h stackh) (- h 8.)))
          (dv (/ 1.0 (convert (- nimages 1)))))
      (nvgSave vg)
      ;; (nvgClearState vg)

      ;; Drop shadow
      (nvgBeginPath vg)
      (nvgRect vg (- x 10.) (- y 10.) (+ w 20.) (+ h 30.))
      (nvgRoundedRect vg x y w h cornerRadius)
      (nvgPathWinding vg NVG_HOLE)
      (nvgFillPaint vg shadowPaint)
      (nvgFill vg)

      ;; Window
      (nvgBeginPath vg)
      (nvgRoundedRect vg x y w h cornerRadius)
      (nvgMoveTo vg (- x 10.) (+ y arry))
      (nvgLineTo vg (+ x 1.) (+ y (- arry 11.)))
      (nvgLineTo vg (+ x 1.) (+ y arry 11.))
      (nvgFillColor vg (nvgRGBA 200 200 200 255))
      (nvgFill vg)

      (nvgSave vg)
      (nvgScissor vg x y w h)
      (nvgTranslate vg 0. (* -1.0 (- stackh h) u))

      (dotimes (i nimages)
        (let ((tx (+ x 10.))
              (ty (+ y 10.))
              (v 0.)
              (a 0.))
          (set! tx (+ tx (* (convert (% i 2)) (+ thumb 10.0))))
          (set! ty (+ ty (* (convert (/ i 2)) (+ thumb 10.0))))
          (nvgImageSize vg (pref images i) imgw_ptr imgh_ptr)
          (if (< (pref imgw_ptr 0) (pref imgh_ptr 0))
              (begin
                (set! iw thumb)
                (set! ih (/ (* iw (convert (pref imgh_ptr 0) float)) (convert (pref imgw_ptr 0) float)))
                (set! ix 0.)
                (set! iy (* -1.0 (- ih thumb) 0.5)))
              (begin
                (set! ih thumb)
                (set! iw (/ (* ih (convert (pref imgw_ptr 0) float)) (convert (pref imgh_ptr 0) float)))
                (set! ix (* -1.0 (- iw thumb) 0.5))
                (set! iy 0.)))

          (set! v (* (convert i) dv))
          (set! a (clampf (/ (- u2 v) dv) 0. 1.))

          (if (< a 1.0)
              (drawSpinner vg (+ tx (/ thumb 2.)) (+ ty (/ thumb 2.)) (* thumb 0.25) t))

          (set! imgPaint (nvgImagePattern vg (+ tx ix) (+ ty iy) iw ih (/ 0.0 (* 180. 3.1416)) (pref images i) a))
          (nvgBeginPath vg)
          (nvgRoundedRect vg tx ty thumb thumb 5.)
          (nvgFillPaint vg imgPaint)
          (nvgFill vg)

          (set! shadowPaint (nvgBoxGradient vg (- tx 1.) ty (+ thumb 2.) (+ thumb 2.) 5. 3. (nvgRGBA 0 0 0 128) (nvgRGBA 0 0 0 0)))
          (nvgBeginPath vg)
          (nvgRect vg (- tx 5.) (- ty 5.) (+ thumb 10.) (+ thumb 10.))
          (nvgRoundedRect vg tx ty thumb thumb 6.)
          (nvgPathWinding vg NVG_HOLE)
          (nvgFillPaint vg shadowPaint)
          (nvgFill vg)

          (nvgBeginPath vg)
          (nvgRoundedRect vg (+ tx 0.5) (+ ty 0.5) (- thumb 1.) (- thumb 1.) 3.5)
          (nvgStrokeWidth vg 1.0)
          (nvgStrokeColor vg (nvgRGBA 255 255 255 192))
          (nvgStroke vg)))
      (nvgRestore vg)

      ;; Hide fades
      (set! fadePaint (nvgLinearGradient vg x y x (+ y 6.) (nvgRGBA 200 200 200 255) (nvgRGBA 200 200 200 0)))
      (nvgBeginPath vg)
      (nvgRect vg (+ x 4.) y (- w 8.) 6.)
      (nvgFillPaint vg fadePaint)
      (nvgFill vg)

      (set! fadePaint (nvgLinearGradient vg x (+ y h) x (+ y (- h 6.)) (nvgRGBA 200 200 200 255) (nvgRGBA 200 200 200 0)))
      (nvgBeginPath vg)
      (nvgRect vg (+ x 4.) (+ y (- h 6.)) (- w 8.) 6.)
      (nvgFillPaint vg fadePaint)
      (nvgFill vg)

      ;; Scroll bar
      (set! shadowPaint (nvgBoxGradient vg (+ x (- w 11.)) (+ y 5.) 8. (- h 8.) 3. 4. (nvgRGBA 0 0 0 32) (nvgRGBA 0 0 0 92)))
      (nvgBeginPath vg)
      (nvgRoundedRect vg (+ x (- w 12.)) (+ y 4.) 8. (- h 8.) 3.)
      (nvgFillPaint vg shadowPaint)
      ;; (nvgFillColor vg (nvgRGBA 255 0 0 128))
      (nvgFill vg)

      (set! shadowPaint (nvgBoxGradient vg (+ x (- w 11.)) (+ y 3. (* (- h 8. scrollh) u)) 8. scrollh 3. 4. (nvgRGBA 220 220 220 255) (nvgRGBA 128 128 128 255)))
      (nvgBeginPath vg)
      (nvgRoundedRect vg (+ x (- w 11.)) (+ y 5. (* (- h 8. scrollh) u)) 6. (- scrollh 2.) 2.)
      (nvgFillPaint vg shadowPaint)
      ;; (nvgFillColor vg (nvgRGBA 0 0 0 128))
      (nvgFill vg)

      (nvgRestore vg))))


(bind-func drawColorwheel
  (lambda (vg x y w h t)
    (let ((i 0)
          (r1 (- (* (minf w h) 0.5) 5.0))
          (r0 (- r1 20.0))
          (ax 0.0)
          (ay 0.0)
          (bx 0.0)
          (by 0.0)
          (cx (+ x (* w 0.5)))
          (cy (+ y (* h 0.5)))
          (aeps (/ 0.5 r1)) ;; half a pixel arc length in radians (2pi cancels out)
          (r (- r0 6.))
          (hue (sin (* t 0.12)))
          (paint (nvgLinearGradient vg ax ay bx by (nvgRGBA 0 0 0 0) (nvgRGBA 0 0 0 0))))
      (nvgSave vg)

      ;; /*	nvgBeginPath(vg)
      ;; 	nvgRect(vg, x,y,w,h)
      ;; 	nvgFillColor(vg, (nvgRGBA 255,0,0,128
      ;; 	nvgFill))(vg);*/

      (dotimes (i 6)
        (let ((a0 (- (* (/ (convert i) 6.0) 3.1416 2.0) aeps))
              (a1 (+ (* (/ (+ (convert i) 1.0) 6.0) 3.1416 2.0) aeps)))
          (nvgBeginPath vg)
          (nvgArc vg cx cy r0 a0 a1 NVG_CW)
          (nvgArc vg cx cy r1 a1 a0 NVG_CCW)
          (nvgClosePath vg)
          (set! ax (+ cx (* (cos a0) (+ r0 r1) 0.5)))
          (set! ay (+ cy (* (sin a0) (+ r0 r1) 0.5)))
          (set! bx (+ cx (* (cos a1) (+ r0 r1) 0.5)))
          (set! by (+ cy (* (sin a1) (+ r0 r1) 0.5)))
          (set! paint (nvgLinearGradient vg ax ay bx by (nvgHSLA (/ a0 (* 3.1416 2.)) 1.0 0.55 255)  (nvgHSLA (/ a1 (* 3.1416 2.)) 1.0 0.55 255)))
          (nvgFillPaint vg paint)
          (nvgFill vg)))

      (nvgBeginPath vg)
      (nvgCircle vg cx cy (- r0 0.5))
      (nvgCircle vg cx cy (+ r1 0.5))
      (nvgStrokeColor vg (nvgRGBA 0 0 0 64))
      (nvgStrokeWidth vg 1.0)
      (nvgStroke vg)

      ;; Selector
      (nvgSave vg)
      (nvgTranslate vg cx cy)
      (nvgRotate vg (* hue 3.1416 2.))

      ;; Marker on
      (nvgStrokeWidth vg 2.0)
      (nvgBeginPath vg)
      (nvgRect vg (- r0 1.) -3. (- r1 (+ r0 2.)) 6.)
      (nvgStrokeColor vg (nvgRGBA 255 255 255 192))
      (nvgStroke vg)

      (set! paint (nvgBoxGradient vg (- r0 3.) -5. (- r1 (+ r0 6.)) 10. 2. 4. (nvgRGBA 0 0 0 128) (nvgRGBA 0 0 0 0)))
      (nvgBeginPath vg)
      (nvgRect vg (- r0 12.) -14. (- r1 (+ r0 24.)) 28.)
      (nvgRect vg (- r0 2.) -4. (- r1 (+ r0 4.)) 8.)
      (nvgPathWinding vg NVG_HOLE)
      (nvgFillPaint vg paint)
      (nvgFill vg)

      ;; Center triangle
      (set! ax (* (cos (* (/ 120.0 180.0) 3.1416)) r))
      (set! ay (* (sin (* (/ 120.0 180.0) 3.1416)) r))
      (set! bx (* (cos (* (/ -120.0 180.0) 3.1416)) r))
      (set! by (* (sin (* (/ -120.0 180.0) 3.1416)) r))
      (nvgBeginPath vg)
      (nvgMoveTo vg r 0.)
      (nvgLineTo vg ax ay)
      (nvgLineTo vg bx by)
      (nvgClosePath vg)
      (set! paint (nvgLinearGradient vg r 0. ax ay (nvgHSLA hue 1.0 0.5 255) (nvgRGBA 255 255 255 255)))
      (nvgFillPaint vg paint)
      (nvgFill vg)
      (set! paint (nvgLinearGradient vg (* (+ r ax) 0.5) (* (+ 0. ay) 0.5) bx by (nvgRGBA 0 0 0 0) (nvgRGBA 0 0 0 255)))
      (nvgFillPaint vg paint)
      (nvgFill vg)
      (nvgStrokeColor vg (nvgRGBA 0 0 0 64))
      (nvgStroke vg)

      ;; Select circle on triangle
      (set! ax (* (cos (* (/ 120.0 180.0) 3.1416)) r 0.3))
      (set! ay (* (sin (* (/ 120.0 180.0) 3.1416)) r 0.4))
      (nvgStrokeWidth vg 2.0)
      (nvgBeginPath vg)
      (nvgCircle vg ax ay 5.)
      (nvgStrokeColor vg (nvgRGBA 255 255 255 192))
      (nvgStroke vg)

      (set! paint (nvgRadialGradient vg ax ay 7. 9. (nvgRGBA 0 0 0 64) (nvgRGBA 0 0 0 0)))
      (nvgBeginPath vg)
      (nvgRect vg (- ax 20.) (- ay 20.) 40. 40.)
      (nvgCircle vg ax ay 7.)
      (nvgPathWinding vg NVG_HOLE)
      (nvgFillPaint vg paint)
      (nvgFill vg)

      (nvgRestore vg)
      (nvgRestore vg))))


(bind-func drawLines
  (lambda (vg x y w h:float t)
    (let ((i:i32 0)
          (j:i32 0)
          (pad 5.0)
          (s (- (/ w 9.0) (* pad 2.)))
          (pts:float* (salloc 8))
          (fx 0.)
          (fy 0.)
          (joins:i32* (salloc 3))
          (caps:i32* (salloc 3)))
      (pfill! joins NVG_MITER NVG_ROUND NVG_BEVEL)
      (pfill! caps NVG_BUTT NVG_ROUND NVG_SQUARE)
      (nvgSave vg)
      (pfill! pts
              (+ (* -1.0 s 0.25) (* (cos (* t 0.3)) s 0.5))
              (* (sin (* t 0.3)) s 0.5)
              (* -1.0 s 0.25)
              0.0
              (* s 0.25)
              0.0
              (+ (* s 0.25) (* (cos (* t -0.3)) (* s 0.5)))
              (* (sin (* t -0.3)) (* s 0.5)))

      (dotimes (i 3)
        (dotimes (j 3)
          (set! fx (+ x (* s 0.5) (* (/ (convert (+ (* i 3) j)) 9.0) w) pad))
          (set! fy (+ (- y (* s 0.5)) pad))

          (nvgLineCap vg (pref caps i))
          (nvgLineJoin vg (pref joins j))

          (nvgStrokeWidth vg (* s 0.3))
          (nvgStrokeColor vg (nvgRGBA 0 0 0 160))
          (nvgBeginPath vg)
          (nvgMoveTo vg (+ fx (pref pts 0)) (+ fy (pref pts 1)))
          (nvgLineTo vg (+ fx (pref pts 2)) (+ fy (pref pts 3)))
          (nvgLineTo vg (+ fx (pref pts 4)) (+ fy (pref pts 5)))
          (nvgLineTo vg (+ fx (pref pts 6)) (+ fy (pref pts 7)))
          (nvgStroke vg)

          (nvgLineCap vg NVG_BUTT)
          (nvgLineJoin vg NVG_BEVEL)

          (nvgStrokeWidth vg 1.0)
          (nvgStrokeColor vg (nvgRGBA 0 192 255 255))
          (nvgBeginPath vg)
          (nvgMoveTo vg (+ fx (pref pts 0)) (+ fy (pref pts 1)))
          (nvgLineTo vg (+ fx (pref pts 2)) (+ fy (pref pts 3)))
          (nvgLineTo vg (+ fx (pref pts 4)) (+ fy (pref pts 5)))
          (nvgLineTo vg (+ fx (pref pts 6)) (+ fy (pref pts 7)))
          (nvgStroke vg)))

      (nvgRestore vg))))

;; need to fix up paths

;; struct DemoData {
;; 	int fontNormal, fontBold, fontIcons;
;; 	int images[12];
;; };

(bind-type DemoData <i32,i32,i32,|12,i32|>)

(bind-func loadDemoData
  (lambda (vg data:DemoData*)
    (let ((i 0)
          (file:i8* (salloc 128))
          (ret 0))
      (if (null? vg)
          (set! ret -1))
      (dotimes (i 12)
        (sprintf file "../example/images/image%d.jpg" (+ i 1))
        (aset! (tref-ptr data 3) i (nvgCreateImage vg file 0))
        (if (= (aref (tref-ptr data 3) i) 0)
            (begin (printf "Could not load %s.\n" file)
                   (set! ret -1))))
      (tset! data 0 (nvgCreateFont vg "sans" "../example/Roboto-Regular.ttf"))
      (if (= (tref data 0) -1)
          (begin (printf "Could not add font italic.\n")
                 (set! ret -1)))
      (tset! data 1 (nvgCreateFont vg "sans-bold" "../example/Roboto-Bold.ttf"))
      (if (= (tref data 1) -1)
          (begin (printf "Could not add font bold.\n")
                 (set! ret -1)))
      (tset! data 2 (nvgCreateFont vg "icons" "../example/entypo.ttf"))
      (if (= (tref data 2) -1)
          (begin (printf "Could not add font icons.\n")
                 (set! ret -1)))
      ret)))


(bind-func freeDemoData
  (lambda (vg data:DemoData*)
    (if (not (null? vg))
        (doloop (i 12)
          (nvgDeleteImage vg (aref (tref-ptr data 3) i))))))


(bind-func drawParagraph
  (lambda (vg x y width height:float mx my)
    (let ((rows:NVGtextRow* (salloc 3))
          (row:NVGtextRow* null)
          (glyphs:NVGglyphPosition* (salloc 100))
          (text "This is longer chunk of text.\n  \n  Would have used lorem ipsum but she    was busy jumping over the lazy dog with the fox and all the men who came to the aid of the party.")
          (start:i8* null)
          (end:i8* null)
          (nrows 0)
          (hit:i1 0)
          (i:i32 0)
          (nglyphs:i32 0)
          (j:i32 0)
          (lnum 0)
          (lineh_ptr:float* (salloc))
          (caretx:float 0.0)
          (px 0.0)
          (bounds:float* (salloc 4))
          (a 0.0)
          (x0 0.0)
          (x1 0.0)
          (gx 0.0)
          (gy 0.0)
          (gutter 0))

      (nvgSave vg)

      (nvgFontSize vg 18.0)
      (nvgFontFace vg "sans")
      (nvgTextAlign vg (bitwise-or NVG_ALIGN_LEFT NVG_ALIGN_TOP))
      (nvgTextMetrics vg null null lineh_ptr)

      ;; The text break API can be used to fill a large buffer of rows,
      ;; or to iterate over the text just few lines (or just one) at a time.
      ;; The "next" variable of the last returned item tells where to continue.
      (set! start text)
      (set! end (pref-ptr text (strlen text)))
      (set! nrows (nvgTextBreakLines vg start end width rows 3))
      (while (<> nrows 0)
        (set! nrows (nvgTextBreakLines vg start end width rows 3))
        (dotimes (i nrows)
          (set! row (pref-ptr rows i))
          (set! hit
                (and (> mx x) (< mx (+ x width)) (>= my y) (< my (+ y (pref lineh_ptr 0)))))

          (nvgBeginPath vg)
          (nvgFillColor vg (nvgRGBA 255 255 255 (if hit 64 16)))
          (nvgRect vg x y (tref row 3) (pref lineh_ptr 0))
          (nvgFill vg)

          (nvgFillColor vg (nvgRGBA 255 255 255 255))
          (nvgText vg x y (tref row 0) (tref row 1))

          (if hit
              (begin
                (set! caretx
                      (if (< mx (+ x (/ (tref row 3) 2.)))
                          x
                          (+ x (tref row 3))))
                (set! px x)
                (set! nglyphs (nvgTextGlyphPositions vg x y (tref row 0) (tref row 1) glyphs 100))
                (dotimes (j nglyphs)
                  (set! x0 (tref (pref-ptr glyphs j) 1))
                  (set! x1 (if (< (+ j 1) nglyphs)
                               (tref (pref-ptr glyphs (+ j 1)) 1)
                               (+ x (tref row 3))))
                  (set! gx (+ (* x0 0.3) (* x1 0.7)))
                  (if (and (>= mx px) (< mx gx))
                      (set! caretx (tref (pref-ptr glyphs j) 1)))
                  (set! px gx))
                (nvgBeginPath vg)
                (nvgFillColor vg (nvgRGBA 255 192 0 255))
                (nvgRect vg caretx y 1. (pref lineh_ptr 0))
                (nvgFill vg)

                (set! gutter (+ lnum 1))
                (set! gx (- x 10.))
                (set! gy (+ y (/ (pref lineh_ptr 0) 2.)))))
          (set! lnum (+ lnum 1))
          (pset! lineh_ptr 0 (+ (pref lineh_ptr 0) y)))
        ;; Keep going...
        (set! start (tref (pref-ptr rows (- nrows 1)) 2)))

      (if (= gutter 1)
          (begin
            (let ((txt:i8* (salloc 16)))

              (sprintf txt "%d" gutter)
              (nvgFontSize vg 13.0)
              (nvgTextAlign vg (bitwise-or NVG_ALIGN_RIGHT NVG_ALIGN_MIDDLE))

              (nvgTextBounds vg gx gy txt null bounds)
              (nvgBeginPath vg)
              (nvgFillColor vg (nvgRGBA 255 192 0 255))
              (nvgRoundedRect vg
                              (- (floor (pref bounds 0)) 4.)
                              (- (floor (pref bounds 1)) 2.)
                              (+ (- (floor (pref bounds 2))
                                    (floor (pref bounds 1)))
                                 8.)
                              (+ (- (floor (pref bounds 3))
                                    (floor (pref bounds 1)))
                                 4.)
                              (- (/ (+ (- (floor (pref bounds 3))
                                          (floor (pref bounds 1)))
                                       4.)
                                    2.)
                                 1.))
              (nvgFill vg)

              (nvgFillColor vg (nvgRGBA 32 32 32 255))
              (nvgText vg gx gy txt null))))
      (set! y (+ y 20.0))

      (nvgFontSize vg 13.0)
      (nvgTextAlign vg (bitwise-or NVG_ALIGN_LEFT NVG_ALIGN_TOP))
      (nvgTextLineHeight vg 1.2)

      (nvgTextBoxBounds vg x y 150. "Hover your mouse over the text to see calculated caret position." null bounds)

      ;; Fade the tooltip out when close to it.
      (set! gx (fabs (- mx (/ (* (pref bounds 0) (+ (pref bounds 2) 0.5)) (- (pref bounds 0) (pref bounds 2))))))
      (set! gy (fabs (- my (/ (* (pref bounds 1) (+ (pref bounds 3) 0.5)) (- (pref bounds 1) (pref bounds 3))))))
      (set! a (- (maxf gx gy) 0.5))
      (set! a (clampf a 0.0 1.0))
      (nvgGlobalAlpha vg a)

      (nvgBeginPath vg)
      (nvgFillColor vg (nvgRGBA 220 220 220 255))
      (nvgRoundedRect vg
                      (- (pref bounds 0) 2.0)
                      (- (pref bounds 1) 2.0)
                      (+ (- (floor (pref bounds 2))
                            (floor (pref bounds 0)))
                         4.)
                      (+ (- (floor (pref bounds 3))
                            (floor (pref bounds 1)))
                         4.)
                      3.)
      (set! px (/ (+ (pref bounds 2)
                     (pref bounds 0))
                  2.0))
      (nvgMoveTo vg px (- (pref bounds 1) 10.))
      (nvgLineTo vg (+ px 7.) (+ (pref bounds 1) 1.))
      (nvgLineTo vg (- px 7.) (+ (pref bounds 1) 1.))
      (nvgFill vg)

      (nvgFillColor vg (nvgRGBA 0 0 0 220))
      (nvgTextBox vg x y 150. "Hover your mouse over the text to see calculated caret position." null)

      (nvgRestore vg))))


(bind-func drawWidths
  (lambda (vg x y width)
    (nvgSave vg)

    (nvgStrokeColor vg (nvgRGBA 0 0 0 255))

    (doloop (i 20)
      (let ((w (* (+ (convert i) 0.5) 0.1)))
        (nvgStrokeWidth vg w)
        (nvgBeginPath vg)
        (nvgMoveTo vg x y)
        (nvgLineTo vg (+ x width) (+ y (* width 0.3)))
        (nvgStroke vg)
        (set! y (+ y 10.0))))
    (nvgRestore vg)))


(bind-func drawCaps
  (lambda (vg x y width)
    (let ((caps:i32* (salloc 3))
          (lineWidth 8.0))
      (pfill! caps NVG_BUTT NVG_ROUND NVG_SQUARE)

      (nvgSave vg)

      (nvgBeginPath vg)
      (nvgRect vg (- x (/ lineWidth 2.)) y (+ width lineWidth) 40.)
      (nvgFillColor vg (nvgRGBA 255 255 255 32))
      (nvgFill vg)

      (nvgBeginPath vg)
      (nvgRect vg x y width 40.)
      (nvgFillColor vg (nvgRGBA 255 255 255 32))
      (nvgFill vg)

      (nvgStrokeWidth vg lineWidth)
      (doloop (i 3)
        
        (nvgLineCap vg (pref caps i))
        (nvgStrokeColor vg (nvgRGBA 0 0 0 255))
        (nvgBeginPath vg)
        (nvgMoveTo vg x (+ y (convert (* i 10)) 5.))
        (nvgLineTo vg (+ x width) (+ y (convert (* i 10)) 5.))
        (nvgStroke vg))

      (nvgRestore vg))))


(bind-func drawScissor
  (lambda (vg x y t)
    (nvgSave vg)

    ;; Draw first rect and set scissor to it's area.
    (nvgTranslate vg x y)
    (nvgRotate vg (nvgDegToRad 5.0))
    (nvgBeginPath vg)
    (nvgRect vg -20. -20. 60. 40.)
    (nvgFillColor vg (nvgRGBA 255 0 0 255))
    (nvgFill vg)
    (nvgScissor vg -20. -20. 60. 40.)

    ;; Draw second rectangle with offset and rotation.
    (nvgTranslate vg 40. 0.)
    (nvgRotate vg t)

    ;; Draw the intended second rectangle without any scissoring.
    (nvgSave vg)
    (nvgResetScissor vg)
    (nvgBeginPath vg)
    (nvgRect vg -20. -10. 60. 30.)
    (nvgFillColor vg (nvgRGBA 255 128 0 64))
    (nvgFill vg)
    (nvgRestore vg)

    ;; Draw second rectangle with combined scissoring.
    (nvgIntersectScissor vg -20. -10. 60. 30.)
    (nvgBeginPath vg)
    (nvgRect vg -20. -10. 60. 30.)
    (nvgFillColor vg (nvgRGBA 255 128 0 255))
    (nvgFill vg)

    (nvgRestore vg)))

(bind-func renderDemo
  (lambda (vg mx my width height t blowup data:DemoData*)
    (let ((x 0.)
          (y 0.)
          (popy 0.))

      (drawEyes vg (- width 250.) 50. 150. 100. mx my t)
      (drawParagraph vg (- width 450.) 50. 150. 100. mx my)
      (drawGraph vg 0. (/ height 2.) width (/ height 2.) t)
      (drawColorwheel vg (- width 300.) (- height 300.) 250.0 250.0 t)

      ;; Line joints
      (drawLines vg 120. (- height 50.) 600. 50. t)

      ;; Line caps
      (drawWidths vg 10. 50. 30.)

      ;; Line caps
      (drawCaps vg 10. 300. 30.)

      (drawScissor vg 50. (- height 80.) t)

      (nvgSave vg)
      (if (= blowup 1)
          (begin
            (nvgRotate vg (* (/ (* (sin (* t 0.3)) 5.0) 180.0) 3.1416))
            (nvgScale vg 2.0 2.0)))

      ;; Widgets
      (drawWindow vg "Widgets n Stuff" 50. 50. 300. 400.)
      (set! x 60.)
      (set! y 95.)
      (drawSearchBox vg "Search" x y 280. 25.)
      (set! y (+ y 40.))
      (drawDropDown vg "Effects" x y 280. 28.)
      (set! popy (+ y 14.))
      (set! y (+ y 45.))

      ;; Form
      (drawLabel vg "Login" x y 280. 20.)
      (set! y (+ y 25.))
      (drawEditBox vg "Email" x y 280. 28.)
      (set! y (+ y 35.))
      (drawEditBox vg "Password" x y 280. 28.)
      (set! y (+ y 38.))
      (drawCheckBox vg "Remember me" x y 140. 28.)
      (drawButton vg ICON_LOGIN "Sign in" (+ x 138.) y 140. 28. (nvgRGBA 0 96 128 255))
      (set! y (+ y 45.))

      ;; Slider
      (drawLabel vg "Diameter" x y 280. 20.)
      (set! y (+ y 25.))
      (drawEditBoxNum vg "123.00" "px" (+ x 180.) y 100. 28.)
      (drawSlider vg 0.4 x y 170. 28.)
      (set! y (+ y 55.))

      (drawButton vg ICON_TRASH "Delete" x y 160. 28. (nvgRGBA 128 16 8 255))
      (drawButton vg 0 "Cancel" (+ x 170.) y 110. 28. (nvgRGBA 0 0 0 0))

      ;; Thumbnails box
      (drawThumbnails vg 365. (- popy 30.) 160. 300. (convert (tref-ptr data 3) i32*) 12 t)

      (nvgRestore vg))))

(bind-func unpremultiplyAlpha
  (lambda (image w h stride)
    (let ((x:i32 0)
          (y:i32 0)
          (row:i8* null)
          (r:i32 0)
          (g:i32 0)
          (b:i32 0)
          (a:i32 0)
          (n:i32 0))
      ;; Unpremultiply
      (dotimes (y h)
        (set! row (pref-ptr image (* y stride)))
        (dotimes (x w)
          (set! r (convert (pref row 0)))
          (set! g (convert (pref row 1)))
          (set! b (convert (pref row 2)))
          (set! a (convert (pref row 3)))
          (if (<> a 0)
              (begin
                (pset! row 0 (convert (mini (/ (* r 255) a) 255) i8))
                (pset! row 1 (convert (mini (/ (* g 255) a) 255) i8))
                (pset! row 2 (convert (mini (/ (* b 255) a) 255) i8))))
          (set! row (pref-ptr row 4))))

      ;; Defringe
      (dotimes (y h)
        (set! row (pref-ptr image (* y stride)))
        (dotimes (x w)
          (set! r 0)
          (set! g 0)
          (set! b 0)
          (set! a (convert (pref row 3)))
          (if (= a 0)
              (begin
                (if (and (> (- x 1) 0) (<> (pref row -1) 0))
                    (begin
                      (set! r (+ r (convert (pref row -4))))
                      (set! g (+ g (convert (pref row -3))))
                      (set! b (+ b (convert (pref row -2))))
                      (set! n (+ n 1))))
                (if (and (< (+ x 1) w) (<> (pref row 7) 0))
                    (begin
                      (set! r (+ r (convert (pref row 4))))
                      (set! g (+ g (convert (pref row 5))))
                      (set! b (+ b (convert (pref row 6))))
                      (set! n (+ n 1))))
                (if (and (> (- y 1) 0) (<> (pref row (+ (* -1 stride) 3)) 0))
                    (begin
                      (set! r (+ r (convert (pref row (* -1 stride)))))
                      (set! g (+ g (convert (pref row (+ (* -1 stride) 1)))))
                      (set! b (+ b (convert (pref row (+ (* -1 stride) 2)))))
                      (set! n (+ n 1))))
                (if (and (< (+ y 1) h) (<> (pref row (+ stride 3)) 0))
                    (set! r (+ r (convert (pref row stride))))
                    (set! g (+ g (convert (pref row (+ stride 1)))))
                    (set! b (+ b (convert (pref row (+ stride 2)))))
                    (set! n (+ n 1)))
                (if (> n 0)
                    (begin
                      (pset! row 0 (convert (/ r n) i8))
                      (pset! row 1 (convert (/ g n) i8))
                      (pset! row 2 (convert (/ b n) i8))))))
          (set! row (pref-ptr row 4)))))))


(bind-func setAlpha
  (lambda (image w:i32 h:i32 stride a)
    (let ((x:i32 0)
          (y:i32 0)
          (row:i8* null))
      (dotimes (y h)
        (set! row (pref-ptr image (* y stride)))
        (dotimes (x w)
          (pset! row (+ (* x 4) 3) a))))))


(bind-func flipHorizontal
  (lambda (image w:i32 h:i32 stride)
    (let ((i 0)
          (j (- h 1))
          (k:i32 0)
          (ri:i8* null)
          (rj:i8* null)
          (t:i8 0))
      (while (< i j)
        (set! ri (pref-ptr image (* i stride)))
        (set! rj (pref-ptr image (* j stride)))
        (dotimes (k (* w 4))
          (set! t (pref ri k))
          (pset! ri k (pref rj k))
          (pset! rj k t))
        (set! i (+ i 1))
        (set! j (+ j 1))))))


(bind-func saveScreenShot
  (lambda (w:i32 h premult name)
    (let ((image:i8* (halloc (* w h 4))))
      (if (not (null? image))
          (begin
            (glReadPixels 0 0 w h GL_RGBA GL_UNSIGNED_BYTE image)))
      (if (= premult 1)
          (unpremultiplyAlpha image w h (* w 4))
          (setAlpha image w h (* w 4:i32) 255))
      (flipHorizontal image w h (* w 4:i32))
      (stbi_write_png name w h 4 image (* w 4:i32))
      (free image))))


(bind-val winWidth i32)
(bind-val winHeight i32)
(bind-val fbWidth i32)
(bind-val fbHeight i32)

(call-as-xtlang
 (let ((w:i32* (alloc))
       (h:i32* (alloc)))
   (glfwGetWindowSize window w h)
   (set! winWidth (pref w 0))
   (set! winHeight (pref h 0))
   (glfwGetFramebufferSize window w h)
   (set! fbWidth (pref w 0))
   (set! fbHeight (pref h 0))
   0))



(bind-func draw_test_rect
  (lambda (x y)
    (nvgBeginPath vg)
    (nvgRect vg x y 520. 430.)
    (nvgFillColor vg (nvgRGBA 255 255 0 255))
    (nvgFill vg)))

(bind-val open_sans i32)

(call-as-xtlang
 (set! open_sans (nvgCreateFont vg "open-sans" "/Users/ben/Library/Fonts/OpenSans-Light.ttf")))

(bind-func draw_test_text
  (lambda ()
    (nvgFontSize vg 120.)
    (nvgFillColor vg (nvgRGBA 0 255 0 255))
    (nvgText vg
             (+ (* (cos (/ (convert (now)) 44100.)) 500.) 500.)
             (+ (* (cos (/ (convert (now)) 56100.)) 200.) 300.)
             "This is a test string." null)
    0.:float))

;; TODO fix eldoc! what a pain in the arse.

(bind-func nanovg_draw
  (lambda ()
    (glViewport 0 0 fbWidth fbHeight)
    (glClear (+ GL_COLOR_BUFFER_BIT
                GL_DEPTH_BUFFER_BIT
                GL_STENCIL_BUFFER_BIT))
    (nvgBeginFrame vg
                   (convert fbWidth) (convert fbHeight)
                   (/ (convert fbWidth float)
                      (convert winWidth float)))
		(nvgBeginFrame vg winWidth winHeight 2.0)

		(renderDemo vg 100.:float 20.:float (convert winWidth float) (convert winHeight float) (convert (glfwGetTime)) 0 null)
    ;; (draw_test_rect 300. 300.)
    ;; (draw_test_text)
    (nvgEndFrame vg)
    (glfwSwapBuffers window)))

(define gl-loop
  (lambda (time delta-t)
    (let ((late-by (- (now) time))
          (next-frame-time (+ time (* *second* delta-t))))
      (if (> late-by 0)
          (print "Late by " (* 1.0 (/ late-by *second*)) "seconds\n")
          (nanovg_draw))
      (callback (* 0.9 next-frame-time)
                'gl-loop
                next-frame-time
                delta-t))))

(gl-loop (now) 1/4)
