;;; nanovg.xtm:examples -- nanovg example

;; Author: Ben Swift
;; Keywords: extempore
;; Required dylibs: libnanovg

;;; Commentary:

;;

;;; Code:

(sys:load "libs/external/glfw3.xtm")
(sys:load "libs/external/nanovg.xtm")

(bind-val window GLFWwindow*)
(bind-val vg NVGcontext*)

(call-as-xtlang
 (set! window (glfw_init_and_create_window 800 600)))

(call-as-xtlang
 (set! vg (nvgCreateGL3 (+ NVG_ANTIALIAS NVG_STENCIL_STROKES NVG_DEBUG)))
 (glEnable GL_STENCIL_TEST)
 (let ((bits:i32* (salloc)))
   (glGetIntegerv GL_MAX_DEPTH_TEXTURE_SAMPLES bits)
   (println "stencil buffer bit depth: " (pref bits 0))))

(bind-val ICON_SEARCH i32 #x1F50D)
(bind-val ICON_CIRCLED_CROSS i32 #x2716)
(bind-val ICON_CHEVRON_RIGHT i32 #xE75E)
(bind-val ICON_CHECK i32 #x2713)
(bind-val ICON_LOGIN i32 #xE740)
(bind-val ICON_TRASH i32 #xE729)

(bind-func maxf
  (lambda (a:float b)
    (if (> a b) a b)))

(bind-func mini
  (lambda (a:i32 b)
    (if (> a b) a b)))

(bind-func clampf
  (lambda (a:float mn mx)
    (if (< a mn)
        mn
        (if (> a mx)
            mx
            a))))

(bind-func isBlack
  (lambda (col:NVGcolor)
    (if (and (= (tref col 0) 0.0)
             (= (tref col 1) 0.0)
             (= (tref col 2) 0.0)
             (= (tref col 3) 0.0))
        1:i32
        0:i32)))

static char* cpToUTF8(int cp, char* str)
{
	int n = 0
	if (cp < 0x80) n = 1
	else if (cp < 0x800) n = 2
	else if (cp < 0x10000) n = 3
	else if (cp < 0x200000) n = 4
	else if (cp < 0x4000000) n = 5
	else if (cp <= 0x7fffffff) n = 6
	str[n] = '\0'
	switch (n) {
	case 6: str[5] = 0x80 | (cp & 0x3f); cp = cp >> 6; cp |= 0x4000000
	case 5: str[4] = 0x80 | (cp & 0x3f); cp = cp >> 6; cp |= 0x200000
	case 4: str[3] = 0x80 | (cp & 0x3f); cp = cp >> 6; cp |= 0x10000
	case 3: str[2] = 0x80 | (cp & 0x3f); cp = cp >> 6; cp |= 0x800
	case 2: str[1] = 0x80 | (cp & 0x3f); cp = cp >> 6; cp |= 0xc0
	case 1: str[0] = cp
	}
	return str
}

(bind-func cpToUTF8
  (lambda (cp:i32 str:i8*)
    (let ((n 0))
      (cond ((< cp #x80) (set! n 1))
            ((< cp #x800) (set! n 2))
            ((< cp #x10000) (set! n 3))
            ((< cp #x200000) (set! n 4))
            ((< cp #x4000000) (set! n 5))
            ((<= cp #x7fffffff) (set! n 6)))
      (pset! str n 0)
      (if (= n 6) (pset! str 5 (bitwise-or #x80 (& cp #x3f)))) ;; cp = cp >> 6; cp |= 0x4000000
      (if (= n 5) (pset! str 4 (bitwise-or #x80 (& cp #x3f)))) ;; cp = cp >> 6; cp |= 0x200000
      (if (= n 4) (pset! str 3 (bitwise-or #x80 (& cp #x3f)))) ;; cp = cp >> 6; cp |= 0x10000
      (if (= n 3) (pset! str 2 (bitwise-or #x80 (& cp #x3f)))) ;; cp = cp >> 6; cp |= 0x800
      (if (= n 2) (pset! str 1 (bitwise-or #x80 (& cp #x3f)))) ;; cp = cp >> 6; cp |= 0xc0
      (if (= n 1) (pset! str 0 cp))
      str)))

(bind-func drawWindow
  (lambda (vg title x y w h)
    (let ((cornerRadius 3.0)
          (shadowPaint:NVGpaint
           (nvgBoxGradient vg x (+ y 2) w h (* cornerRadius 2) 10 (nvgRGBA 0 0 0 128) (nvgRGBA 0 0 0 0)))
          (headerPaint:NVGpaint
           (nvgLinearGradient vg x y x (+ y 15) (nvgRGBA 255 255 255 8) (nvgRGBA 0 0 0 16))))
      (nvgSave vg)
      ;; (nvgClearState vg)

      ;; Window
      (nvgBeginPath vg)
      (nvgRoundedRect vg x y w h cornerRadius)
      (nvgFillColor vg (nvgRGBA 28 30 34 192))
      ;; (nvgFillColor vg (nvgRGBA 0 0 0 128))
      (nvgFill vg)

      ;; Drop shadow
      (nvgBeginPath vg)
      (nvgRect vg (- x 10) (- y 10) (+ w 20) (+ h 30))
      (nvgRoundedRect vg x y w h cornerRadius)
      (nvgPathWinding vg NVG_HOLE)
      (nvgFillPaint vg shadowPaint)
      (nvgFill vg)

      ;; Header
      (nvgBeginPath vg)
      (nvgRoundedRect vg (+ x 1) (+ y 1) (- w 2) 30 (- cornerRadius 1))
      (nvgFillPaint vg headerPaint)
      (nvgFill vg)
      (nvgBeginPath vg)
      (nvgMoveTo vg (+ x 0.5) (+ y 0.5 30.0))
      (nvgLineTo vg (- (+ x 0.5 w) 1) (+ y 0.5 30.0))
      (nvgStrokeColor vg (nvgRGBA 0 0 0 32))
      (nvgStroke vg)

      (nvgFontSize vg 18.0)
      (nvgFontFace vg "sans-bold")
      (nvgTextAlign vg (bitwise-or NVG_ALIGN_CENTER NVG_ALIGN_MIDDLE))

      (nvgFontBlur vg 2)
      (nvgFillColor vg (nvgRGBA 0 0 0 128))
      (nvgText vg (/ (+ x w) 2) (+ y 16 1) title null)

      (nvgFontBlur vg 0)
      (nvgFillColor vg (nvgRGBA 220 220 220 160))
      (nvgText vg (/ (+ x w) 2) (+ y 16) title null)

      (nvgRestore vg))))

(bind-func drawSearchBox
  (lambda (vg text x y w h)
    (let ((bg (nvgBoxGradient vg x (+ y 1.5) w h (/ h 2) 5 (nvgRGBA 0 0 0 16) (nvgRGBA 0 0 0 92)))
          (icon:i8* (salloc 8))
          (cornerRadius (- (/ h 2) 1)))
      (nvgBeginPath vg)
      (nvgRoundedRect vg x y w h cornerRadius)
      (nvgFillPaint vg bg)
      (nvgFill vg)

      ;; /*	nvgBeginPath(vg)
      ;; 	nvgRoundedRect(vg, x+0.5,y+0.5, w-1,h-1, cornerRadius-0.5)
      ;; 	nvgStrokeColor(vg, (nvgRGBA 0,0,0,48
      ;; 	nvgStroke))(vg);*/

      (nvgFontSize vg h*1.3)
      (nvgFontFace vg "icons")
      (nvgFillColor vg (nvgRGBA 255 255 255 64))
      (nvgTextAlign vg (bitwise-or NVG_ALIGN_CENTER NVG_ALIGN_MIDDLE))
      (nvgText vg (+ x (* h 0.55)) (+ y (* h 0.55)) (cpToUTF8 ICON_SEARCH icon) null)

      (nvgFontSize vg 20.0)
      (nvgFontFace vg "sans")
      (nvgFillColor vg (nvgRGBA 255 255 255 32))

      (nvgTextAlign vg (bitwise-or NVG_ALIGN_LEFT NVG_ALIGN_MIDDLE))
      (nvgText vg (+ x (* h 1.05)) (+ y (* h 0.5)) text null)

      (nvgFontSize vg (* h 1.3))
      (nvgFontFace vg "icons")
      (nvgFillColor vg (nvgRGBA 255 255 255 32))
      (nvgTextAlign vg (bitwise-or NVG_ALIGN_CENTER NVG_ALIGN_MIDDLE))
      (nvgText vg (- (+ x w) (* h 0.55)) (+ y (* h 0.55)) (cpToUTF8 ICON_CIRCLED_CROSS icon) null))))

(bind-func drawDropDown
  (lambda (vg text x y w h)
    (let ((bg bg (nvgLinearGradient vg x y x (+ y h) (nvgRGBA 255 255 255 16) (nvgRGBA 0 0 0 16)))
          (icon:i8* (salloc 8))
          (cornerRadius 4.0))
      (nvgBeginPath vg)
      (nvgRoundedRect vg (+ x 1) (+ y 1) (- w 2) (- h 2) (- cornerRadius 1))
      (nvgFillPaint vg bg)
      (nvgFill vg)

      (nvgBeginPath vg)                  
      (nvgRoundedRect vg (+ x 0.5) (+ y 0.5) (- w 1) (- h 1) (- cornerRadius 0.5))
      (nvgStrokeColor vg (nvgRGBA 0 0 0 48)) 
      (nvgStroke vg)                         

      (nvgFontSize vg 20.0)                       
      (nvgFontFace vg "sans")                      
      (nvgFillColor vg (nvgRGBA 255 255 255 160))   
      (nvgTextAlign vg (bitwise-or NVG_ALIGN_LEFT NVG_ALIGN_MIDDLE)) 
      (nvgText vg (+ x (* h 0.3)) (+ y (* h 0.5)) text null)        

      (nvgFontSize vg (* h 1.3))                        
      (nvgFontFace vg "icons")                       
      (nvgFillColor vg (nvgRGBA 255 255 255 64))      
      (nvgTextAlign vg (bitwise-or NVG_ALIGN_CENTER NVG_ALIGN_MIDDLE)) 
      (nvgText vg (- (+ x w) (* h 0.5)) (+ y (* h 0.5)) (cpToUTF8 ICON_CHEVRON_RIGHT icon) null))))

(bind-func drawLabel
  (lambda (vg text x y w h)
    (nvgFontSize vg 18.0)
    (nvgFontFace vg "sans")
    (nvgFillColor vg (nvgRGBA 255 255 255 128))
    (nvgTextAlign vg (bitwise-or NVG_ALIGN_LEFT NVG_ALIGN_MIDDLE))
    (nvgText vg x (+ y (* h 0.5)) text null)))

(bind-func drawEditBoxBase
  (lambda (vg x y w h))
  (let ((bg (nvgBoxGradient vg (+ x 1) (+ y 2.5) (- w 2) (- h 2) 3 4 (nvgRGBA 255 255 255 32) (nvgRGBA 32 32 32 32))))
    ;; Edit
    (nvgBeginPath vg)                        
    (nvgRoundedRect vg (+ x 1) (+ y 1) (- w 2) (- h 2) (- 4 1)) 
    (nvgFillPaint vg bg)                      
    (nvgFill vg)                               
    (nvgBeginPath vg)                                 
    (nvgRoundedRect vg (+ x 0.5) (+ y 0.5) (- w 1) (- h 1) (- 4.0 0.5)) 
    (nvgStrokeColor vg (nvgRGBA 0 0 0 48))              
    (nvgStroke vg)))

(bind-func drawEditBox
  (lambda (vg text x y w h)
    (drawEditBoxBase vg x y w h)                  
    (nvgFontSize vg 20.0)                         
    (nvgFontFace vg "sans")                        
    (nvgFillColor vg (nvgRGBA 255 255 255 64))       
    (nvgTextAlign vg (bitwise-or NVG_ALIGN_LEFT NVG_ALIGN_MIDDLE)) 
    (nvgText vg (+ x (* h 0.3)) (+ y (* h 0.5)) text null)))

(bind-func drawEditBoxNum
  (lambda (vg text units x y w h)
  	(let ((uw (nvgTextBounds vg 0 0 units null null)))
      (drawEditBoxBase vg x y w h)

      (nvgFontSize vg 18.0)
      (nvgFontFace vg "sans")
      (nvgFillColor vg (nvgRGBA 255 255 255 64))
      (nvgTextAlign vg (bitwise-or NVG_ALIGN_RIGHT NVG_ALIGN_MIDDLE))
      (nvgText vg (- (+ x w) (* h 0.3)) (+ y (* h 0.5)) units null)

      (nvgFontSize vg 20.0)
      (nvgFontFace vg "sans")
      (nvgFillColor vg (nvgRGBA 255 255 255 128))
      (nvgTextAlign vg (bitwise-or NVG_ALIGN_RIGHT NVG_ALIGN_MIDDLE))
      (nvgText vg (- (- (+ x w) uw) (* h 0.5)) (+ y (* h 0.5)) text null)))) 

(bind-func drawCheckBox
  (lambda (vg text x y w h)
    (let ((bg (nvgBoxGradient vg (+ x 1) (+ y (floor (* h 0.5)) (+ -9 1)) 18 18 3 3 (nvgRGBA 0 0 0 32) (nvgRGBA 0 0 0 92)))
          (icon:i8* (salloc 8)))
      (nvgFontSize vg 18.0)                    
      (nvgFontFace vg "sans")                  
      (nvgFillColor vg (nvgRGBA 255 255 255 160)) 

      (nvgTextAlign vg (bitwise-or NVG_ALIGN_LEFT NVG_ALIGN_MIDDLE)) 
      (nvgText vg (+ x 28) (+ y (* h 0.5)) text null)                          

      (nvgBeginPath vg)                                 
      (nvgRoundedRect vg (+ x 1) (+ y (floor (* h 0.5)) -9) 18 18 3) 
      (nvgFillPaint vg bg)                               
      (nvgFill vg)                                        

      (nvgFontSize vg 40)                                        
      (nvgFontFace vg "icons")                                   
      (nvgFillColor vg (nvgRGBA 255 255 255 128))                 
      (nvgTextAlign vg (bitwise-or NVG_ALIGN_CENTER NVG_ALIGN_MIDDLE))         
      (nvgText vg (+ x 9 2) (+ y (* h 0.5)) (cpToUTF8 ICON_CHECK icon) null))))

(bind-func drawButton
  (lambda (vg preicon text x y w h col)
    (let ((bg (nvgBoxGradient vg (+ x 1) (+ y (floor (* h 0.5)) (+ -9 1)) 18 18 3 3 (nvgRGBA 0 0 0 32) (nvgRGBA 0 0 0 92)))
          (icon:i8* (salloc 8))
          (cornerRadius 4.0)
          (tw 0.0)
          (iw 0.0)
          (tw (nvgTextBounds vg 0 0 text null null)))

      (nvgLinearGradient vg x y x (+ y h) (nvgRGBA 255 255 255 (if (isBlack col) 16 32)) (nvgRGBA 0 0 0 (if (isBlack col) 16 32)))
      (nvgBeginPath vg)
      (nvgRoundedRect vg (+ x 1) (+ y 1) (- w 2) (- h 2) (- cornerRadius 1))
      (if (not (isBlack col))
          (begin
            (nvgFillColor vg col)
            (nvgFill vg)))
      (nvgFillPaint vg bg)
      (nvgFill vg)

      (nvgBeginPath vg)
      (nvgRoundedRect vg (+ x 0.5) (+ y 0.5) (- w 1) (- h 1) (- cornerRadius 0.5))
      (nvgStrokeColor vg (nvgRGBA 0 0 0 48))
      (nvgStroke vg)

      (nvgFontSize vg 20.0)
      (nvgFontFace vg "sans-bold")
      (if (<> preicon 0)
          (begin
            ;; this code has been consilidated a bit
            (nvgFontSize vg h*1.3)
            (nvgFontFace vg "icons")
            (set! iw (nvgTextBounds vg 0 0 (cpToUTF8 preicon icon) null null))
            (set! iw (+ iw (* h 0.15f)))
            (nvgFillColor vg (nvgRGBA 255 255 255 96))
            (nvgTextAlign vg (bitwise-or NVG_ALIGN_LEFT NVG_ALIGN_MIDDLE))
            (nvgText vg (- (- (+ x (* w 0.5)) (* tw 0.5)) (* iw 0.75)) (+ y (* h 0.5)) (cpToUTF8 preicon icon) null)))

      (nvgFontSize vg 20.0)
      (nvgFontFace vg "sans-bold")
      (nvgTextAlign vg (bitwise-or NVG_ALIGN_LEFT NVG_ALIGN_MIDDLE))
      (nvgFillColor vg (nvgRGBA 0 0 0 160))
      (nvgText vg (+ (- (+ x (* w 0.5)) (* tw 0.5)) (* iw 0.25)) (+ y (* h 0.5) -1) text null)
      (nvgFillColor vg (nvgRGBA 255 255 255 160))
      (nvgText vg (+ (- (+ x (* w 0.5)) (* tw 0.5)) (* iw 0.25)) (+ y (* h 0.5)) text null))))

(bind-func drawSlider
  (lambda (vg pos x y w h)
    (let ((bg (nvgBoxGradient vg x (- cy 3) w 4 2 2 (nvgRGBA 0 0 0 32) (nvgRGBA 0 0 0 128)))
          (knob (nvgLinearGradient vg x (- cy kr) x (+ cy kr) (nvgRGBA 255 255 255 16) (nvgRGBA 0 0 0 16)))
          (cy (+ y (floor (* h 0.5))))
          (kr (floor (* h 0.25))))
      (nvgSave vg)                       
      ;; (nvgClearState vg)
  
      ;; Slot
      (nvgBeginPath vg)                  
      (nvgRoundedRect vg x (- cy 2) w 4 2) 
      (nvgFillPaint vg bg)               
      (nvgFill vg)                        

      ;; Knob Shadow
      nvgBeginPath(vg)                                         
      (nvgRect vg (- (+ x (floor (* pos w))) kr 5)  (- cy kr 5) (+ (* kr 2) 10) (+ (* kr 2) 13)) 
      (nvgCircle vg (+ x (floor (* pos w))) cy kr)                         
      (nvgPathWinding vg NVG_HOLE)                                 
      (nvgFillPaint vg bg)                                         
      (nvgFill vg)                                                  

      ;; Knob
      (nvgBeginPath vg)                    
      (nvgCircle vg (+ x (floor (* pos w))) cy (- kr 1)) 
      (nvgFillColor vg (nvgRGBA 40 43 48 255)) 
      (nvgFill vg)                             
      (nvgFillPaint vg knob)                  
      (nvgFill vg)                             

      (nvgBeginPath vg)                     
      (nvgCircle vg (+ x (floor (* pos w))) cy (- kr 0.5)) 
      (nvgStrokeColor vg (nvgRGBA 0 0 0 92))    
      (nvgStroke vg)                            

      (nvgRestore vg))))


(bind-func drawEyes
  (lambda (vg x y w h mx my t)
    (let ((gloss:NVGpaint (salloc))
          (bg:NVGpaint (salloc)))
      (ex (* w 0.23))
      (ey (* h 0.5))
      (lx (+ x ex))
      (ly (+ y ey))
      (rx (- (+ x w) ex))
      (ry (+ y ey))
      (dx (/ (- mx rx) (* ex 10.0)))
      (dy (/ (- my ry) (* ey 10.0)))
      (d (sqrt (+ (* dx dx) (* dy dy))))
      (br (* (minf ex ey) 0.5))
      (blink (- 1.0 (* (pow (sin (* t 0.5) 200.0)) 0.8)))

      (set! bg (nvgLinearGradient vg x (+ y (* h 0.5)) (+ x (* w 0.1)) (+ y h) (nvgRGBA 0 0 0 32) (nvgRGBA 0 0 0 16)))
      (nvgBeginPath vg)
      (nvgEllipse vg (+ lx 3.0) (+ ly 16.0) ex ey)
      (nvgEllipse vg (+ rx 3.0) (+ ry 16.0) ex ey)
      (nvgFillPaint vg bg)
      (nvgFill vg)

      (set! bg (nvgLinearGradient vg x (+ y (* h 0.25)) (+ x (* w 0.1)) (+ y h) (nvgRGBA 220 220 220 255) (nvgRGBA 128 128 128 255)))
      (nvgBeginPath vg)
      (nvgEllipse vg lx ly ex ey)
      (nvgEllipse vg rx ry ex ey)
      (nvgFillPaint vg bg)
      (nvgFill vg)

      (if (> d 1.0)
          (begin
            (set! dx (/ dx d))
            (set! dy (/ dy d))))

      (set! dx (* dx ex 0.4))
      (set! dy (* dy ey 0.5))
      (nvgBeginPath vg)
      (nvgEllipse vg (+ lx dx) (+ ly dy (* ey 0.25 blink)) br (* br blink))
      (nvgFillColor vg (nvgRGBA 32 32 32 255))
      (nvgFill vg)

      (set! dx (/ (- mx rx) (* ex 10.0)))
      (set! dy (/ (- my ry) (* ey 10.0)))
      (set! d (sqrt (+ (* dx dx) (* dy dy))))

      (if (> d 1.0)
          (begin
            (set! dx (/ dx d))
            (set! dy (/ dy d))))

      (set! dx (* dx ex 0.4))
      (set! dy (* dy ey 0.5))

      (set! dx (* dx ex 0.4))
      (set! dy (* dy ey 0.5))
      (nvgBeginPath vg)
      (nvgEllipse vg (+ rx dx) (+ ry dy (* ey 0.25 blink)) br (* br blink))
      (nvgFillColor vg (nvgRGBA 32 32 32 255))
      (nvgFill vg)

      (set! gloss (nvgRadialGradient vg (- lx (* ex 0.25)) (- ly (* ey 0.5)) (* ex 0.1) (* ex 0.75) (nvgRGBA 255 255 255 128) (nvgRGBA 255 255 255 0)))
      (nvgBeginPath vg)
      (nvgEllipse vg lx ly ex ey)
      (nvgFillPaint vg gloss)
      (nvgFill vg)

      (set! gloss (nvgRadialGradient vg (- rx (* ex 0.25)) (- ry (* ey 0.5)) (* ex 0.1) (* ex 0.75) (nvgRGBA 255 255 255 128) (nvgRGBA 255 255 255 0)))
      (nvgBeginPath vg)
      (nvgEllipse vg rx ry ex ey)
      (nvgFillPaint vg gloss)
      (nvgFill vg))))

(bind-func drawGraph
  (lambda (vg x y w h t)
    (let ((bg:NVGpaint (salloc))
          (samples:float* (salloc 6))
          (sx:float* (salloc 6))
          (sy:float* (salloc 6))
          (dx (/ w 5.0))
          (i:i32 0)) 
      (pfill! samples
              (+ 1 (* (sin (+ (* t 1.2345) (* (cos (* t 0.33457)) 0.44)))) 0.5)
              (+ 1 (* (sin (+ (* t 0.68363) (* (cos (* t 1.3)) 1.55)))) 0.5)
              (+ 1 (* (sin (+ (* t 1.1642) (* (cos (* t 0.33457)) 1.24)))) 0.5)
              (+ 1 (* (sin (+ (* t 0.56345) (* (cos (* t 1.63)) 0.14)))) 0.5)
              (+ 1 (* (sin (+ (* t 1.6245) (* (cos (* t 0.254)) 0.3)))) 0.5)
              (+ 1 (* (sin (+ (* t 0.345) (* (cos (* t 0.03)) 0.6)))) 0.5))

      (dotimes (i 6)
        (pset! sx i (+ x (* i dx)))
        (pset! sy i (* (+ y h) (pref samples i) 0.8)))

      ;; Graph background
      (set! bg (nvgLinearGradient vg x y x y+h (nvgRGBA 0 160 192 0) (nvgRGBA 0 160 192 64)))
      (nvgBeginPath vg)
      (nvgMoveTo vg (pref sx 0) (pref sy 0))


      (dotimes (i 1 5)
        (nvgBezierTo vg (+ (pref sx (- i 1)) (* dx 0.5)) (pref sy (- i 1)) (- (pref sx i) (* dx 0.5)) (pref sy i) (pref sx i) (pref sy i)))
      (nvgLineTo vg (+ x w) (+ y h))
      (nvgLineTo vg x (+ y h))
      (nvgFillPaint vg bg)
      (nvgFill vg)

      ;; Graph line
      (nvgBeginPath vg)
      (nvgMoveTo vg (pref sx 0) (+ (pref sy 0) 2))

      (dotimes (i 1 5)
        (nvgBezierTo vg
                     (+ (pref sx (- i 1)) (* dx 0.5))
                     (+ (pref sy (- i 1)) 2)
                     (- (pref sx i) (* dx 0.5))
                     (+ (pref sy i) 2)
                     (pref sx i)
                     (+ (pref sy i) 2)))
      (nvgStrokeColor vg (nvgRGBA 0 0 0 32))
      (nvgStrokeWidth vg 3.0)
      (nvgStroke vg)

      (nvgBeginPath vg)
      (nvgMoveTo vg (pref sx 0) (pref sy 0))
      (dotimes (i 1 5)
        (nvgBezierTo vg
                     (+ (pref sx (- i 1)) (* dx 0.5))
                     (pref sy (- i 1))
                     (- (pref sx i) (* dx 0.5))
                     (pref sy i)
                     (pref sx i)
                     (pref sy i)))
      (nvgStrokeColor vg (nvgRGBA 0 160 192 255))
      (nvgStrokeWidth vg 3.0)
      (nvgStroke vg)

      ;; Graph sample pos
      (dotimes (i 6)
        (set! bg (nvgRadialGradient vg (pref sx i) (+ (pref sy i) 2) 3.0 8.0 (nvgRGBA 0 0 0 32) (nvgRGBA 0 0 0 0)))
        nvgBeginPath(vg)
        nvgRect(vg (- (pref sx i) 10) (- (pref sy i) 8) 20 20)
        (nvgFillPaint vg bg)
        (nvgFill vg))

      (nvgBeginPath vg)
      (dotimes (i 6)
        (nvgCircle vg (pref sx i) (pref sy i) 4.0))
      (nvgFillColor vg (nvgRGBA 0 160 192 255))
      (nvgFill vg)
      (nvgBeginPath vg)
      (dotimes (i 6)
        (nvgCircle vg (pref sx i) (pref sy i) 2.0))
      (nvgFillColor vg (nvgRGBA 220 220 220 255))
      (nvgFill vg)

      (nvgStrokeWidth vg 1.0))))


(bind-func drawSpinner
  (lambda (vg cx cy r t)
    (let ((a0 (+ 0.0 (* t 6)))
          (a1 (+ NVG_PI (* t 6)))
          (r0 r)
          (r1 (* r 0.75))
          (ax (+ cx (* (cos a0) (+ r0 r1) 0.5)))
          (ay (+ cy (* (sin a0) (+ r0 r1) 0.5)))
          (bx (+ cx (* (cos a1) (+ r0 r1) 0.5)))
          (by (+ cy (* (sin a1) (+ r0 r1) 0.5)))
          (paint:NVGpaint (nvgLinearGradient vg ax ay bx by (nvgRGBA 0 0 0 0) (nvgRGBA 0 0 0 128))))
      (nvgSave vg)

      (nvgBeginPath vg)
      (nvgArc vg cx cy r0 a0 a1 NVG_CW)
      (nvgArc vg cx cy r1 a1 a0 NVG_CCW)
      (nvgClosePath vg)
      (nvgFillPaint vg paint)
      (nvgFill vg)

      (nvgRestore vg))))


(bind-func drawThumbnails
  (lambda (NVGcontext* vg, float x, float y, float w, float h, const int* images, int nimages, float t)
    (let ((cornerRadius 3.0)
          (shadowPaint:NVGpaint (salloc))
          (imgPaint:NVGpaint (salloc))
          (fadePaint:NVGpaint (salloc))
          (ix)
          (iy)
          (iw)
          (ih)
          (thumb 60.0)
          (arry 30.5)
          (imgw_ptr:i32* (salloc))
          (imgh_ptr:i32* (salloc))
          (stackh (+ (* (/ nimages 2) (+ thumb 10)) 10))
          (i 0)
          (u (* (+ 1.0 (cos (* t 0.5))) 0.5))
          (u2 (* (- 1.0 (cos (* t 0.2))) 0.5))
          (scrollh (* (/ h stackh) (- h 8)))
          (dv (/ 1.0 (convert (- nimages 1)))))
      (nvgSave vg)
      ;; (nvgClearState vg)

      ;; Drop shadow
      (set! shadowPaint (nvgBoxGradient vg x (+ y 4) w h (* cornerRadius 2) 20 (nvgRGBA 0 0 0 128) (nvgRGBA 0 0 0 0)))
      (nvgBeginPath vg)
      (nvgRect vg (- x 10) (- y 10) (+ w 20) (+ h 30))
      (nvgRoundedRect vg x y w h cornerRadius)
      (nvgPathWinding vg NVG_HOLE)
      (nvgFillPaint vg shadowPaint)
      (nvgFill vg)

      ;; Window
      (nvgBeginPath vg)
      (nvgRoundedRect vg x y w h cornerRadius)
      (nvgMoveTo vg (- x 10) (+ y arry))
      (nvgLineTo vg (+ x 1) (+ y (- arry 11)))
      (nvgLineTo vg (+ x 1) (+ y arry 11))
      (nvgFillColor vg (nvgRGBA 200 200 200 255))
      (nvgFill vg)

      (nvgSave vg)
      (nvgScissor vg x y w h)
      (nvgTranslate vg 0 (* -1.0 (- stackh h) u))

      (dotimes (i nimages)
        (let  ((tx (+ x 10))
               (ty (+ y 10))
               (v 0)
               (a)))
        (set! tx (+ tx (* (% i 2) (+ thumb 10))))
        (set! ty (+ ty (* (/ i 2) (+ thumb 10))))
        (nvgImageSize vg (pref images i) imgw_ptr imgh_ptr)
        (if (< (pref imgw_ptr 0) (pref imgh_ptr 0))
            (begin
              (set! iw thumb)
              (set! ih (/ (* iw (convert (pref imgh_ptr 0) float)) (convert (pref imgw_ptr 0) float)))
              (set! ix 0)
              (set! iy (* -1.0 (- ih thumb) 0.5)))
            (begin
              (set! ih thumb)
              (set! iw (/ (* ih (convert (pref imgw_ptr 0) float)) (convert (pref imgh_ptr 0) float)))
              (set! ix (* -1.0 (- iw thumb) 0.5))
              (set! iy 0)))

        (set! v (* (convert i) dv))
        (set! a (clampf (/ (- u2 v) dv) 0 1))

        (if (< a 1.0)
            (drawSpinner vg (+ tx (/ thumb 2)) (+ ty (/ thumb 2)) (* thumb 0.25) t))

        (set! imgPaint (nvgImagePattern vg (+ tx ix) (+ ty iy) iw ih (/ 0.0 (* 180. NVG_PI)) (pref images i) a))
        (nvgBeginPath vg)
        (nvgRoundedRect vg tx ty thumb thumb 5)
        (nvgFillPaint vg imgPaint)
        (nvgFill vg)

        (set! shadowPaint (nvgBoxGradient vg (- tx 1) ty (+ thumb 2) (+ thumb 2) 5 3 (nvgRGBA 0 0 0 128) (nvgRGBA 0 0 0 0)))
        (nvgBeginPath vg)
        (nvgRect vg (- tx 5) (- ty 5) (+ thumb 10) (+ thumb 10))
        (nvgRoundedRect vg tx ty thumb thumb 6)
        (nvgPathWinding vg NVG_HOLE)
        (nvgFillPaint vg shadowPaint)
        (nvgFill vg)

        (nvgBeginPath vg)
        (nvgRoundedRect vg (+ tx 0.5) (+ ty 0.5) (- thumb 1) (- thumb 1) (- 4.0 0.5))
        (nvgStrokeWidth vg 1.0)
        (nvgStrokeColor vg (nvgRGBA 255 255 255 192))
        (nvgStroke vg))
      (nvgRestore vg)

      ;; Hide fades
      (set! fadePaint (nvgLinearGradient vg x y x (+ y 6) (nvgRGBA 200 200 200 255) (nvgRGBA 200 200 200 0)))
      (nvgBeginPath vg)
      (nvgRect vg (+ x 4) y (- w 8) 6)
      (nvgFillPaint vg fadePaint)
      (nvgFill vg)

      (set! fadePaint (nvgLinearGradient vg x (+ y h) x (+ y (- h 6)) (nvgRGBA 200 200 200 255) (nvgRGBA 200 200 200 0)))
      (nvgBeginPath vg)
      (nvgRect vg (+ x 4) (+ y (- h 6)) (- w 8) 6)
      (nvgFillPaint vg fadePaint)
      (nvgFill vg)

      ;; Scroll bar
      (set! shadowPaint (nvgBoxGradient vg (+ x (- w 11)) (+ y 5) 8 (- h 8) 3 4 (nvgRGBA 0 0 0 32) (nvgRGBA 0 0 0 92)))
      (nvgBeginPath vg)
      (nvgRoundedRect vg (+ x (- w 12)) (+ y 4) 8 (- h 8) 3)
      (nvgFillPaint vg shadowPaint)
      ;; (nvgFillColor vg (nvgRGBA 255 0 0 128))
      (nvgFill vg)

      (set! shadowPaint (nvgBoxGradient vg (+ x (- w 11)) (+ y 3 (* (- h 8 scrollh) u)) 8 scrollh 3 4 (nvgRGBA 220 220 220 255) (nvgRGBA 128 128 128 255)))
      nvgBeginPath(vg)
      nvgRoundedRect(vg (+ x (- w 11)) (+ y 5 (* (- h 8 scrollh) u)) 6 (- scrollh 2) 2)
      (nvgFillPaint vg shadowPaint)
      ;; (nvgFillColor vg (nvgRGBA 0 0 0 128))
      (nvgFill vg)

      (nvgRestore vg))))


(bind-func drawColorwheel
  (lambda (NVGcontext* vg, float x, float y, float w, float h, float t)
    (let ((i 0)
          (r1 (- (* (minf w h) 0.5) 5.0))
          (r0 (- r1 20.0))
          (ax 0.0)
          (ay 0.0)
          (bx 0.0)
          (by 0.0)
          (cx (+ x (* w 0.5)))
          (cy (+ y (* h 0.5)))
          (aeps (/ 0.5 r1)) ;; half a pixel arc length in radians (2pi cancels out)
          (r (- r0 6))
          (hue (sin (* t 0.12)))
          (paint:NVGpaint (salloc)))
      (nvgSave vg)

      ;; /*	nvgBeginPath(vg)
      ;; 	nvgRect(vg, x,y,w,h)
      ;; 	nvgFillColor(vg, (nvgRGBA 255,0,0,128
      ;; 	nvgFill))(vg);*/

      (dotimes (i 6)
        (let ((a0 (- (* (/ (convert i) 6.0) NVG_PI 2.0) aeps))
              (a1 (+ (* (/ (+ (convert i) 1.0) 6.0) NVG_PI 2.0) aeps)))
          (nvgBeginPath vg)
          (nvgArc vg cx cy r0 a0 a1 NVG_CW)
          (nvgArc vg cx cy r1 a1 a0 NVG_CCW)
          (nvgClosePath vg)
          (set! ax (+ cx (* (cos a0) (+ r0 r1) 0.5)))
          (set! ay (+ cy (* (sin a0) (+ r0 r1) 0.5)))
          (set! bx (+ cx (* (cos a1) (+ r0 r1) 0.5)))
          (set! by (+ cy (* (sin a1) (+ r0 r1) 0.5)))
          (set! paint (nvgLinearGradient vg ax ay bx by (nvgHSLA (/ a0 (* NVG_PI 2)) 1.0 0.55 255)  (nvgHSLA (/ a1 (* NVG_PI 2)) 1.0 0.55 255)))
          (nvgFillPaint vg paint)
          (nvgFill vg)))

      (nvgBeginPath vg)
      (nvgCircle vg cx cy (- r0 0.5))
      (nvgCircle vg cx cy (+ r1 0.5))
      (nvgStrokeColor vg (nvgRGBA 0 0 0 64))
      (nvgStrokeWidth vg 1.0)
      (nvgStroke vg)

      ;; Selector
      (nvgSave vg)
      (nvgTranslate vg cx cy)
      (nvgRotate vg (* hue NVG_PI 2))

      ;; Marker on
      (nvgStrokeWidth vg 2.0)
      (nvgBeginPath vg)
      (nvgRect vg (- r0 1) -3 (- r1 (+ r0 2)) 6)
      (nvgStrokeColor vg (nvgRGBA 255 255 255 192))
      (nvgStroke vg)

      (set! paint (nvgBoxGradient vg (- r0 3) -5 (- r1 (+ r0 6)) 10 2 4 (nvgRGBA 0 0 0 128) (nvgRGBA 0 0 0 0)))
      (nvgBeginPath vg)
      (nvgRect vg (- r0 12) -14 (- r1 (+ r0 24)) 28)
      (nvgRect vg (- r0 2) -4 (- r1 (+ r0 4)) 8)
      (nvgPathWinding vg NVG_HOLE)
      (nvgFillPaint vg paint)
      (nvgFill vg)

      ;; Center triangle
      (set! ax (* (cos (* (/ 120.0 180.0) NVG_PI)) r))
      (set! ay (* (sin (* (/ 120.0 180.0) NVG_PI)) r))
      (set! bx (* (cos (* (/ -120.0 180.0) NVG_PI)) r))
      (set! by (* (sin (* (/ -120.0 180.0) NVG_PI)) r))
      (nvgBeginPath vg)
      (nvgMoveTo vg r 0)
      (nvgLineTo vg ax ay)
      (nvgLineTo vg bx by)
      (nvgClosePath vg)
      (set! paint (nvgLinearGradient vg r 0 ax ay (nvgHSLA hue 1.0 0.5 255) (nvgRGBA 255 255 255 255)))
      (nvgFillPaint vg paint)
      (nvgFill vg)
      (set! paint) (nvgLinearGradient vg (* (+ r ax) 0.5) (* (+ 0 ay) 0.5) bx by (nvgRGBA 0 0 0 0) (nvgRGBA 0 0 0 255))
      (nvgFillPaint vg paint)
      (nvgFill vg)
      (nvgStrokeColor vg (nvgRGBA 0 0 0 64))
      (nvgStroke vg)

      ;; Select circle on triangle
      (set! ax (* (cos (* (/ 120.0 180.0) NVG_PI)) r 0.3))
      (set! ay (* (sin (* (/ 120.0 180.0) NVG_PI)) r 0.4))
      (nvgStrokeWidth vg 2.0)
      (nvgBeginPath vg)
      (nvgCircle vg ax ay 5)
      (nvgStrokeColor vg (nvgRGBA 255 255 255 192))
      (nvgStroke vg)

      (set! paint (nvgRadialGradient vg ax ay 7 9 (nvgRGBA 0 0 0 64) (nvgRGBA 0 0 0 0)))
      (nvgBeginPath vg)
      (nvgRect vg (- ax 20) (- ay 20) 40 40)
      (nvgCircle vg ax ay 7)
      (nvgPathWinding vg NVG_HOLE)
      (nvgFillPaint vg paint)
      (nvgFill vg)

      (nvgRestore vg)
      (nvgRestore vg))))


(bind-func drawLines
  (lambda (vg x y w h t)
    (let ((i 0)
          (j 0)
          (pad 5.0)
          (s (- (/ w 9.0) (* pad 2)))
          (pts:float* (salloc 8))
          (fx 0.)
          (fy 0.)
          (joins:i32* (salloc 3))
          (caps:i32* (salloc 3)))
      (pfill! joins NVG_MITER NVG_ROUND NVG_BEVEL)
      (pfill! caps NVG_BUTT NVG_ROUND NVG_SQUARE)
      (nvgSave vg)
      (pfill! pts
              (+ (* -1.0 s 0.25) (* (cosf (* t 0.3)) s 0.5))
              (* (sinf (* t 0.3)) s 0.5)
              (* -1.0 s 0.25)
              0.0
              (* s 0.25)
              0.0
              (+ (* s 0.25) (* (cos (* t -0.3)) (* s 0.5)))
              (* (sin (* t -0.3)) (* s 0.5)))

      (dotimes (i 3)
        (dotimes (j 3)
          (set! fx (+ x (* s 0.5) (* (/ (+ (* i 3) j) 9.0) w) pad))
          (set! fy (+ (- y (* s 0.5)) pad))

          (nvgLineCap vg (pref caps i))
          (nvgLineJoin vg (pref joins j))

          (nvgStrokeWidth vg (* s 0.3))
          (nvgStrokeColor vg (nvgRGBA 0 0 0 160))
          (nvgBeginPath vg)
          (nvgMoveTo vg (+ fx (pref pts 0)) (+ fy (pref pts 1)))
          (nvgLineTo vg (+ fx (pref pts 2)) (+ fy (pref pts 3)))
          (nvgLineTo vg (+ fx (pref pts 4)) (+ fy (pref pts 5)))
          (nvgLineTo vg (+ fx (pref pts 6)) (+ fy (pref pts 7)))
          (nvgStroke vg)

          (nvgLineCap vg NVG_BUTT)
          (nvgLineJoin vg NVG_BEVEL)

          (nvgStrokeWidth vg 1.0)
          (nvgStrokeColor vg (nvgRGBA 0 192 255 255))
          (nvgBeginPath vg)
          (nvgMoveTo vg (+ fx (pref pts 0)) (+ fy (pref pts 1)))
          (nvgLineTo vg (+ fx (pref pts 2)) (+ fy (pref pts 3)))
          (nvgLineTo vg (+ fx (pref pts 4)) (+ fy (pref pts 5)))
          (nvgLineTo vg (+ fx (pref pts 6)) (+ fy (pref pts 7)))
          (nvgStroke vg)))

      (nvgRestore vg))))

;; need to fix up paths

;; struct DemoData {
;; 	int fontNormal, fontBold, fontIcons; 
;; 	int images[12];
;; };

(bind-type DemoData <i32,i32,i32,|12,i32|>)

(bind-func loadDemoData
  (lambda (vg data:DemoData*)
    (let ((i 0)
          (file:i8* (salloc 128))
          (ret 0))
      (if (null? vg)
          (set! ret -1))
      (dotimes (i 12)
        (snprintf file 128 "../example/images/image%d.jpg" (+ i 1))
        (aset! (tref-ptr data 3) i (nvgCreateImage vg file 0))
        (if (= (aref (tref-ptr data 3) i) 0)
            (begin (printf "Could not load %s.\n" file)
                   (set! ret -1))))
      (tset! data 0 (nvgCreateFont vg "sans" "../example/Roboto-Regular.ttf"))
      (if (= (tref data 0) -1)
          (begin (printf "Could not add font italic.\n")
                 (set! ret -1)))
      (tset! data 1 (nvgCreateFont vg "sans-bold" "../example/Roboto-Bold.ttf"))
      (if (= (tref data 1) -1)
          (begin (printf "Could not add font bold.\n")
                 (set! ret -1)))
      (tset! data 2 (nvgCreateFont vg "icons" "../example/entypo.ttf"))
      (if (= (tref data 2) -1)
          (begin (printf "Could not add font icons.\n")
                 (set! ret -1)))
      ret)))


(bind-func freeDemoData
  (lambda (vg data)
    (if (not (null? vg))
        (doloop (i 12)
          (nvgDeleteImage vg (aref (tref-ptr data 3) i))))))


(bind-func drawParagraph
  (lambda (vg x y width height mx my)
    (let ((rows:NVGtextrow* (salloc 3))
          (row:NVGtextrow* null)
          (glyphs:NVGglyphposition* (salloc 100))
          (text "This is longer chunk of text.\n  \n  Would have used lorem ipsum but she    was busy jumping over the lazy dog with the fox and all the men who came to the aid of the party.")
          (start:i8* null)
          (end:i8* null)
          (nrows 0)
          (hit 0)
          (i 0)
          (nglyphs 0)
          (j 0)
          (lnum 0)
          (lineh_ptr:float* (salloc))
          (caretx 0.0)
          (px 0.0)
          (bounds:float (salloc 4))
          (a 0.0)
          (gx 0.0)
          (gy 0.0)
          (gutter 0))

      (nvgSave vg)

      (nvgFontSize vg 18.0)
      (nvgFontFace vg "sans")
      (nvgTextAlign vg (bitwise-or NVG_ALIGN_LEFT NVG_ALIGN_TOP))
      (nvgTextMetrics vg null null lineh_ptr)

      ;; The text break API can be used to fill a large buffer of rows,
      ;; or to iterate over the text just few lines (or just one) at a time.
      ;; The "next" variable of the last returned item tells where to continue.
      (set! start text)
      (set! end (pref-ptr text (strlen text)))
      (set! nrows (nvgTextBreakLines vg start end width rows 3))
      (while (nrows)
        (dotimes (i nrows)
          (set! row (pref-ptr rows i))
          (set! hit
                (and (> mx x) (< mx (+ x width)) (>= my y) (< my (+ y lineh))))

          (nvgBeginPath vg)
          (nvgFillColor vg (nvgRGBA 255 255 255 (if hit 64 16)))
          (nvgRect vg x y (tref row 3) lineh)
          (nvgFill vg)

          (nvgFillColor vg (nvgRGBA 255 255 255 255))
          (nvgText vg x y (tref row 0) (tref row 1))

          (if hit
              (begin
                (set! caretx
                      (if (< mx (+ x (/ (tref row 3) 2)))
                          x
                          (+ x (tref row 3))))
                (set! px x)
                (set! nglyphs (nvgTextGlyphPositions vg x y (tref row 0) (tref row 1) glyphs 100))
                (dotimes (j nglyphs)
                  (set! x0 (tref (pref-ptr glyphs j) 1))
                  (set! x1 (if (< (+ j 1) nglyphs)
                               (tref (pref-ptr glyphs (+ j 1)) 1)
                               (+ x (tref row 3))))
                  (set! gx (+ (* x0 0.3) (* x1 0.7)))
                  (if (and (>= mx px) (< mx gx))
                      (set! caretx (tref (pref-ptr glyphs j) 1)))
                  (set! px gx))
                (nvgBeginPath vg)
                (nvgFillColor vg (nvgRGBA 255 192 0 255))
                (nvgRect vg caretx y 1 lineh)
                (nvgFill vg)

                (set! gutter (+ lnum 1))
                (set! gx (- x 10))
                (set! gy (+ y (/ lineh 2)))))
          (set! lnum (+ lnum 1))
          (set! lineh (+ lineh y)))
        ;; Keep going...
        (set! start (tref (pref-ptr rows (- nrows 1)) 2)))

      (if (= gutter 1)
          (begin
            (let ((txt:|16,i8| (salloc)))
              
              (snprintf txt 16 "%d" gutter)
              (nvgFontSize vg 13.0)
              (nvgTextAlign vg (bitwise-or NVG_ALIGN_RIGHT NVG_ALIGN_MIDDLE))

              (nvgTextBounds vg gx gy txt null bounds)
              (nvgBeginPath vg)
              (nvgFillColor vg (nvgRGBA 255 192 0 255))
              (nvgRoundedRect vg
                              (- (convert (pref bounds 0) i32) 4)
                              (- (convert (pref bounds 1) i32) 2)
                              (+ (- (convert (pref bounds 2) i32)
                                    (convert (pref bounds 1) i32))
                                 8)
                              (+ (- (convert (pref bounds 3) i32)
                                    (convert (pref bounds 1) i32))
                                 4)
                              (- (/ (+ (- (convert (pref bounds 3) i32)
                                          (convert (pref bounds 1) i32))
                                       4)
                                    2)
                                 1))
              (nvgFill vg)

              (nvgFillColor vg (nvgRGBA 32 32 32 255))
              (nvgText vg gx gy txt null))))
      (set! y (+ y 20.0))

      (nvgFontSize vg 13.0)
      (nvgTextAlign vg (bitwise-or NVG_ALIGN_LEFT NVG_ALIGN_TOP))
      (nvgTextLineHeight vg 1.2)

      (nvgTextBoxBounds vg x y 150 "Hover your mouse over the text to see calculated caret position." null bounds)

      ;; Fade the tooltip out when close to it.
      (set! gx (fabs (- mx (/ (+ (* (pref bounds 0) (pref bounds 2) 0.5))) (- (pref bounds 0) (pref bounds 2)))))
      (set! gy (fabs (- my (/ (+ (* (pref bounds 1) (pref bounds 3) 0.5))) (- (pref bounds 1) (pref bounds 3)))))
      (set! a (- (maxf gx gy) 0.5))
      (set! a (clampf a 0.0 1.0))
      (nvgGlobalAlpha vg a)

      (nvgBeginPath vg)
      (nvgFillColor vg (nvgRGBA 220 220 220 255))
      nvgRoundedRect(vg, bounds[0]-2,bounds[1]-2, (int)(bounds[2]-bounds[0])+4, (int)(bounds[3]-bounds[1])+4, 3)
      (nvgRoundedRect vg
                      (- (pref bounds 0) 2.0)
                      (- (pref bounds 1) 2.0)
                      (+ (- (convert (pref bounds 2) i32)
                            (convert (pref bounds 0) i32))
                         4)
                      (+ (- (convert (pref bounds 3) i32)
                            (convert (pref bounds 1) i32))
                         4)
                      3)
      (set! px (/ (+ (pref bounds 2)
                     (pref bounds 0))
                  2.0))
      (nvgMoveTo vg px (- (pref bounds 1) 10))
      (nvgLineTo vg (+ px 7) (+ (pref bounds 1) 1))
      (nvgLineTo vg (- px 7) (+ (pref bounds 1) 1))
      (nvgFill vg)

      (nvgFillColor vg (nvgRGBA 0 0 0 220))
      (nvgTextBox vg x y 150 "Hover your mouse over the text to see calculated caret position." null)

      (nvgRestore vg))))


(bind-func drawWidths
  (lambda (vg x y width)
    (nvgSave vg)

    (nvgStrokeColor vg (nvgRGBA 0 0 0 255))

    (doloop (i 20)
      (let ((w (* (+ (convert i) 0.5) 0.1)))
        (nvgStrokeWidth vg w)
        (nvgBeginPath vg)
        (nvgMoveTo vg x y)
        (nvgLineTo vg (+ x width) (+ y (* width 0.3)))
        (nvgStroke vg)
        (set! y (+ y 10.0))))
    (nvgRestore vg)))


(bind-func drawCaps
  (lambda (NVGcontext* vg, float x, float y, float width)
    (let ((caps:i32* (salloc 3))
          (lineWidth 8.0))
      (pfill! caps NVG_BUTT NVG_ROUND NVG_SQUARE)

      (nvgSave vg)

      (nvgBeginPath vg)
      (nvgRect vg (- x (/ lineWidth 2)) y (+ width lineWidth) 40)
      (nvgFillColor vg (nvgRGBA 255 255 255 32))
      (nvgFill vg)

      (nvgBeginPath vg)
      (nvgRect vg x y width 40)
      (nvgFillColor vg (nvgRGBA 255 255 255 32))
      (nvgFill vg)

      (nvgStrokeWidth vg lineWidth)
      (doloop (i 3)
        )
      (nvgLineCap vg (pref caps i))
      (nvgStrokeColor vg (nvgRGBA 0 0 0 255))
      (nvgBeginPath vg)
      (nvgMoveTo vg x (+ y (* i 10) 5))
      (nvgLineTo vg x+width (+ y (* i 10) 5))
      (nvgStroke vg)

      (nvgRestore vg))))


(bind-func drawScissor
  (lambda (vg x y t)
    (nvgSave vg)

    ;; Draw first rect and set scissor to it's area.
    (nvgTranslate vg x y)
    (nvgRotate vg (nvgDegToRad 5.0))
    (nvgBeginPath vg)
    (nvgRect vg -20 -20 60 40)
    (nvgFillColor vg (nvgRGBA 255 0 0 255))
    (nvgFill vg)
    (nvgScissor vg -20 -20 60 40)

    ;; Draw second rectangle with offset and rotation.
    (nvgTranslate vg 40 0)
    (nvgRotate vg t)

    ;; Draw the intended second rectangle without any scissoring.
    (nvgSave vg)
    (nvgResetScissor vg)
    (nvgBeginPath vg)
    (nvgRect vg -20 -10 60 30)
    (nvgFillColor vg (nvgRGBA 255 128 0 64))
    (nvgFill vg)
    (nvgRestore vg)

    ;; Draw second rectangle with combined scissoring.
    (nvgIntersectScissor vg -20 -10 60 30)
    (nvgBeginPath vg)
    (nvgRect vg -20 -10 60 30)
    (nvgFillColor vg (nvgRGBA 255 128 0 255))
    (nvgFill vg)

    (nvgRestore vg)))

(bind-func renderDemo
  (lambda (vg mx my width height t blowup data:DemoData*) 
    (let ((x)
          (y)
          (popy)))

    (drawEyes vg (- width) 250 50 150 100 mx my t)
    (drawParagraph vg (- width) 450 50 150 100 mx my)
    (drawGraph vg 0 (/ height 2) width (/ height 2) t)
    (drawColorwheel vg (- width) 300 (- height 300) 250.0 250.0 t)

    ;; Line joints
    (drawLines vg 120 (- height 50) 600 50 t)

    ;; Line caps
    (drawWidths vg 10 50 30)

    ;; Line caps
    (drawCaps vg 10 300 30)

    (drawScissor vg 50 (- height 80) t)

    (nvgSave vg)
    (if (= blowup 1)
        (begin
          (nvgRotate vg (* (/ (* (sin (* t 0.3)) 5.0) 180.0) NVG_PI))
          (nvgScale vg 2.0 2.0)))

    ;; Widgets
    (drawWindow vg "Widgets n Stuff" 50 50 300 400)
    (set! x 60)
    (set! y 95)
    (drawSearchBox vg "Search" x y 280 25)
    (set! y (+ y 40))
    (drawDropDown vg "Effects" x y 280 28)
    (set! popy (+ y 14))
    (set! y (+ y 45))

    ;; Form
    (drawLabel vg "Login" x y 280 20)
    (set! y (+ y 25))
    (drawEditBox vg "Email" x y 280 28)
    (set! y (+ y 35))
    (drawEditBox vg "Password" x y 280 28)
    (set! y (+ y 38))
    (drawCheckBox vg "Remember me" x y 140 28)
    (drawButton vg ICON_LOGIN "Sign in" (+ x 138) y 140 28 (nvgRGBA 0 96 128 255))
    (set! y (+ y 45))

    ;; Slider
    (drawLabel vg "Diameter" x y 280 20)
    (set! y (+ y 25))
    (drawEditBoxNum vg "123.00" "px" (+ x 180) y 100 28)
    (drawSlider vg 0.4 x y 170 28)
    (set! y (+ y 55))

    (drawButton vg ICON_TRASH "Delete" x y 160 28 (nvgRGBA 128 16 8 255))
    (drawButton vg 0 "Cancel" (+ x 170) y 110 28 (nvgRGBA 0 0 0 0))

    ;; Thumbnails box
    (drawThumbnails vg 365 (- popy 30) 160 300 (tref data 3) 12 t)

    (nvgRestore vg)))

(bind-func unpremultiplyAlpha
  (lambda (image w h stride)
    (let ((x:i32 0)
          (y:i32 0)
          (row:i8* null)
          (r:i32 0)
          (g:i32 0)
          (b:i32 0)
          (a:i32 0)
          (n:i32 0))
      ;; Unpremultiply
      (dotimes (y h)
        (set! row (pref-ptr image (* y stride)))
        (dotimes (x w)
          (set! r (convert (pref row 0))) 
          (set! g (convert (pref row 1))) 
          (set! b (convert (pref row 2))) 
          (set! a (convert (pref row 3)))
          (if (<> a 0)
              (begin
                (pset! row 0 (convert (mini (/ (* r 255) a) 255)))
                (pset! row 1 (convert (mini (/ (* g 255) a) 255)))
                (pset! row 2 (convert (mini (/ (* b 255) a) 255)))))
          (set! row (+ row 4))))

      ;; Defringe
      (dotimes (y h)
        (set! row (pref-ptr image (* y stride)))
        (dotimes (x w)
          (set! r 0) 
          (set! g 0) 
          (set! b 0) 
          (set! a (pref row 3))
          (if (= a 0)
              (begin
                (if (and (> (- x 1) 0) (<> (pref row -1) 0))
                    (begin
                      (set! r (+ r (pref row -4)))
                      (set! g (+ g (pref row -3)))
                      (set! b (+ b (pref row -2)))
                      (set! n (+ n 1))))
                (if (and (< (+ x 1) w) (<> (pref row 7) 0))
                    (begin
                      (set! r (+ r (pref row 4)))
                      (set! g (+ g (pref row 5)))
                      (set! b (+ b (pref row 6)))
                      (set! n (+ n 1))))
                (if (and (> (- y 1) 0) (<> (pref row (+ (* -1 stride) 3)) 0))
                    (begin
                      (set! r (+ r (pref row (* -1 stride))))
                      (set! g (+ g (pref row (+ (* -1 stride) 1))))
                      (set! b (+ b (pref row (+ (* -1 stride) 2))))
                      (set! var (+ var ))))
                (if (and (< (+ y 1) h) (<> (pref row (+ stride 3)) 0))
                    ()
                    (set! r (+ r (pref row stride)))
                    (set! g (+ g (pref row (+ stride 1))))
                    (set! b (+ b (pref row (+ stride 2))))
                    (set! n (+ n 1)))
                (if (> n 0)
                    (begin
                      (pset! row 0 (/ r n))
                      (pset! row 1 (/ g n))
                      (pset! row 2 (/ b n))))))
          (set! row (+ row 4)))))))


(bind-func setAlpha
  (lambda (image w h stride a)
    (let ((x:i32 0)
          (y:i32 0)
          (row:i8* null))
      (dotimes (y h)
        (set! row (pref-ptr image (* y stride)))
        (dotimes (x w)
          (pset! row (+ (* x 4) 3) a))))))


(bind-func flipHorizontal
  (lambda (image w h stride)
    (let ((i 0)
          (j (- h 1))
          (k 0)
          (ri:i8* null)
          (rj:i8* null)
          (t:i8 0)))
    (while (< i j)
      (set! ri (pref-ptr image (* i stride)))
      (set! rj (pref-ptr image (* j stride)))
      (dotimes (k (* w 4))
        (set! t (pref ri k))
        (pset! ri k (pref rj k))
        (pset! rj k t))
      (set! i (+ i 1))
      (set! j (+ j 1)))))


(bind-func saveScreenShot
  (lambda (w h premult name)
    (let ((image:i8* (halloc (* w h 4))))
      (if (not (null? image))
          (begin
            (glReadPixels 0 0 w h GL_RGBA GL_UNSIGNED_BYTE image))))
    (if (= premult 1)
        (unpremultiplyAlpha image w h (* w 4))
        (setAlpha image w h (* w 4) 255))
    (flipHorizontal image w h (* w 4))
    (stbi_write_png name w h 4 image (* w 4))
    (free image)))

(bind-val winWidth i32)
(bind-val winHeight i32)
(bind-val fbWidth i32)
(bind-val fbHeight i32)

(call-as-xtlang
 (let ((w:i32* (alloc))
       (h:i32* (alloc)))
   (glfwGetWindowSize window w h)
   (set! winWidth (pref w 0))
   (set! winHeight (pref h 0))
   (glfwGetFramebufferSize window w h)
   (set! fbWidth (pref w 0))
   (set! fbHeight (pref h 0))
   0))

(bind-func draw_test_rect
  (lambda (x y)
    (nvgBeginPath vg)
    (nvgRect vg x y 520. 430.)
    (nvgFillColor vg (nvgRGBA 255 255 0 255))
    (nvgFill vg)))

(bind-val open_sans i32)

(call-as-xtlang
 (set! open_sans (nvgCreateFont vg "open-sans" "/Users/ben/Library/Fonts/OpenSans-Light.ttf")))

(bind-func draw_test_text
  (lambda ()
    (nvgFontSize vg 120.)
    (nvgFillColor vg (nvgRGBA 0 255 0 255))    
    (nvgText vg
             (+ (* (cos (/ (convert (now)) 44100.)) 500.) 500.)
             (+ (* (cos (/ (convert (now)) 56100.)) 200.) 300.)
             "This is a test string." null)
    0.:float))

(bind-func nanovg_draw
  (lambda ()
    (glViewport 0 0 fbWidth fbHeight)
    (glClear (+ GL_COLOR_BUFFER_BIT
                GL_DEPTH_BUFFER_BIT
                GL_STENCIL_BUFFER_BIT))
    (nvgBeginFrame vg
                   (convert fbWidth) (convert fbHeight)
                   (/ (convert fbWidth float)
                      (convert winWidth float)))
    (draw_test_rect 300. 300.)
    (draw_test_text)
    (nvgEndFrame vg)
    (glfwSwapBuffers window)))

(define gl-loop
  (lambda (time delta-t)
    (let ((late-by (- (now) time))
          (next-frame-time (+ time (* *second* delta-t))))
      (if (> late-by 0)
          (print "Late by " (* 1.0 (/ late-by *second*)) "seconds\n")
          (nanovg_draw))
      (callback (* 0.9 next-frame-time)
                'gl-loop
                next-frame-time
                delta-t))))

(gl-loop (now) 1/40)
