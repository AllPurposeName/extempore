;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; spectral metering example
;;
;; This example uses the fft/ifft bindings from math.xtm to draw a
;; real-time visualisation of the magnitude spectrum of an audio
;; signal.

;; First, we need to set up some functions to play a sound file.  This
;; code is all taken from the sndfile.xtm example

(define libsndfile
  (let ((platform (sys:platform)))
    (cond ((string=? platform "Linux") (sys:open-dylib "libsndfile.so"))
          ((string=? platform "Windows") (sys:open-dylib "libsndfile.dll"))
          ((string=? platform "OSX") (sys:open-dylib "libsndfile.dylib"))
          (else (print "Unknown platform: " platform)))))

;; bind 4 sndfile lib functions.  for more detail about what these
;; functions do, look at the sndfile.h header file which came with
;; your libsndfile src/package
(bind-lib libsndfile sf_open [i8*,i8*,i32,<i64,i32,i32,i32,i32,i32>*]*)
(bind-lib libsndfile sf_read_double [i64,i8*,double*,i64]*)
(bind-lib libsndfile sf_seek [i64,i8*,i64,i32]*)
(bind-lib libsndfile sf_strerror [i8*,i8*]*)

;; an audio buffer reader
(bind-func read-audio-file
  (lambda (fname dat offset num)
    (let ((info:<i64,i32,i32,i32,i32,i32>* (zalloc))
	  (audiofile (sf_open fname 16 info))
	  (channels (i32toi64 (tref info 2)))
	  (num-to-read (* num channels))
	  (num-to-offset (* offset channels))
	  (cnt (sf_seek audiofile num-to-offset 0))
	  (samples-read (sf_read_double audiofile dat num-to-read)))
      (if (<> null audiofile)
          (begin
            (printf "file name: %s\n" fname)
            (printf "samplerate: %d\n" (tref info 1))
            (printf "channels: %d\n" (tref info 2))
            (printf "samples read: %lld\n" samples-read))
          (printf "errors:\t\t %s\n" (sf_strerror audiofile)))
      dat)))

;; setup a closure to hold audio data.  This lambda takes one argument:
;; the (string) path to the audio file

(bind-func create_audio_closure
  (lambda (fname len)
    (let ((offset 0.0) ; offset into sound file
          (adat:double* (zalloc (* 44100 2 (dtoi64 len)))))
      (lambda ()
        (read-audio-file fname
                         adat
                         (dtoi64 (* 44100.0 offset))
                         (dtoi64 (* 44100.0 len)))
        adat))))

;; now, onto the fft/graphics stuff

(define ctx (gl:make-ctx ":0.0" #f 0.0 0.0 900.0 600.0))

(load "libs/cairo_lib.xtm")
(load "libs/opengl_lib.xtm")

;; draw animated circles to an opengl context
(bind-func spectrum_visualiser
  (let ((width:i32 900)
        (height:i32 600)
        (surface (cairo_image_surface_create CAIRO_FORMAT_RGB24 width height))
	(cr (cairo_create surface))
	(i 0))
    (lambda (spec_bins:|16,double|*)
      (cairo_set_source_rgb cr 0.0 0.0 0.0)
      (dotimes (i 16)
      	(cairo_set_source_rgba cr 0.0 0.2 0.7 1.0)
      	(cairo_rectangle cr
                         (+ (* (i64tod i) 30.0) 100.0) 100.0
                         25.0 (/ (aref spec_bins i) 10.0))
      	(cairo_fill cr))
      ;(cairo_surface_flush surface)
      (cairo_image_surface_get_data surface))))

;; draw surface data returned from test2
(bind-func gl-draw 1000000
  (lambda (spec_bins:|16,double|*)
    (glLoadIdentity)
    ;; (glClear (+ GL_COLOR_BUFFER_BIT GL_DEPTH_BUFFER_BIT))
    ;; ;; use tex num 5 repeatedly
    ;; (gl-load-tex-bgr 900 600 4 GL_UNSIGNED_BYTE (spectrum_visualiser spec_bins) 5)
    ;; (gl-draw-img-reverse -1.0 -1.0 2.0 2.0 180.0 5)
    void))

(load "libs/math.xtm")

;; set up the type alias for our dsp function
(bind-alias DSP [double,double,double,double,double*]*)
;; dsp function - this will play the sound file.  Remember to
;; change the file path to an audio file on your system
(bind-func dsp:DSP 100000000 ; make sure we allocate enough memory
  (let ((audio_length 60.0)
        (audio_closure (create_audio_closure "/Users/ben/Desktop/peg.wav"
                                             audio_length))
        (audio (audio_closure))
        (playhead 0)
        (window_size 4096)
        (time_buffer:cpxd* (zalloc window_size))
        (freq_buffer:cpxd* (zalloc window_size))
        (spec_bins:|16,double|* (zalloc)) ;use 16 bins for spectrogram
        (i 0))
    (lambda (in time chan dat)
      (if (and (= (modulo playhead window_size) 0)
               (= chan 0.0))
          (begin (dotimes (i window_size)
                   ;; add sum of L and R channels into real component
                   ;; of time_buffer (which is a buffer of complex values
                   (tset! (pref-ptr time_buffer i) 0
                          (+ (pref audio (+ (* 2 i) playhead)) ; L channel
                             (pref audio (+ (+ 1 (* 2 i)) playhead))))) ; R channel
                 ;; take FFT, store results in freq_buffer
                 (fft-cpxd time_buffer freq_buffer window_size)
                 (let ((j 0)
                       (sum 0.0)
                       (bin_width (/ (/ window_size 16) 2)))
                   (dotimes (i 16)
                     (set! sum 0.0)
                     (dotimes (j (* i bin_width) bin_width)
                       (set! sum (+ sum (magnitude-cpxd (pref-ptr freq_buffer j)))))
                     (aset! spec_bins i (/ sum (i64tod bin_width)))
                     ;; (printf "s[%lld]: %3.1f " i sum)
                     ))
                 ;; (printf "\n")
                 (gl-draw spec_bins)
                 ))
      (if (= chan 1.0) ; increment playhead once per (stereo) pair of samples
          (set! playhead (modulo (+ playhead 1)
                                 (* (dtoi64 audio_length) 44100))))
      (pref audio (+ (dtoi64 chan) (* 2 playhead))))))

(dsp:set! dsp)

;; note to self - maybe need to call glLoadIdentity from scheme?
;; statefulness and all that

;; standard callback
(define spectrum-animation
  (lambda (beat dur)
    (gl-draw)
    (gl:swap-buffers ctx)
    (callback (*metro* (+ beat (* .5 dur))) 'cairo-animation (+ beat dur) dur)))

(cairo-animation (*metro* 'get-beat 4) 1/12)
