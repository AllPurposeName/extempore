;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; spectral metering example
;;
;; This example uses the fft/ifft bindings from math.xtm to draw a
;; real-time visualisation of the magnitude spectrum of an audio
;; signal.

;; First, we need to set up some functions to play a sound file.  This
;; code is all taken from the sndfile.xtm example

(define libsndfile
  (let ((platform (sys:platform)))
    (cond ((string=? platform "Linux") (sys:open-dylib "libsndfile.so"))
          ((string=? platform "Windows") (sys:open-dylib "libsndfile.dll"))
          ((string=? platform "OSX") (sys:open-dylib "libsndfile.dylib"))
          (else (print "Unknown platform: " platform)))))

;; bind 4 sndfile lib functions.  for more detail about what these
;; functions do, look at the sndfile.h header file which came with
;; your libsndfile src/package
(bind-lib libsndfile sf_open [i8*,i8*,i32,<i64,i32,i32,i32,i32,i32>*]*)
(bind-lib libsndfile sf_read_double [i64,i8*,double*,i64]*)
(bind-lib libsndfile sf_seek [i64,i8*,i64,i32]*)
(bind-lib libsndfile sf_strerror [i8*,i8*]*)

;; an audio buffer reader
(bind-func read-audio-file
  (lambda (fname dat offset num)
    (let ((info:<i64,i32,i32,i32,i32,i32>* (zalloc))
	  (audiofile (sf_open fname 16 info))
	  (channels (i32toi64 (tref info 2)))
	  (num-to-read (* num channels))
	  (num-to-offset (* offset channels))
	  (cnt (sf_seek audiofile num-to-offset 0))
	  (samples-read (sf_read_double audiofile dat num-to-read)))
      (if (<> null audiofile)
          (begin
            (printf "file name: %s\n" fname)
            (printf "samplerate: %d\n" (tref info 1))
            (printf "channels: %d\n" (tref info 2))
            (printf "samples read: %lld\n" samples-read))
          (printf "errors:\t\t %s\n" (sf_strerror audiofile)))
      dat)))

;; setup a closure to hold audio data.  This lambda takes one argument:
;; the (string) path to the audio file

(bind-func create_audio_closure
  (lambda (fname len)
    (let ((offset 0.0) ; offset into sound file
          (adat:double* (zalloc (* 44100 2 (dtoi64 len)))))
      (lambda ()
        (read-audio-file fname
                         adat
                         (dtoi64 (* 44100.0 offset))
                         (dtoi64 (* 44100.0 len)))
        adat))))

;; now, onto the fft/graphics stuff

(define ctx (gl:make-ctx ":0.0" #f 0.0 0.0 1080.0 720.0))

(load "libs/math.xtm")
(load "libs/cairo_lib.xtm")
(load "libs/opengl_lib.xtm")

;; let's make a helper type for holding rgb 3-tuples
(bind-alias rgb_colour <double,double,double>)

(bind-func set_cairo_source_with_colour
  (lambda (cr colour:rgb_colour*)
    (cairo_set_source_rgba cr
                           (tref colour 0)
                           (tref colour 1)
                           (tref colour 2)
                           0.8)))

(bind-func draw_spectral_bar
  (let ((orange_break 500.0)  ;marks transition to orange levels
        (red_break 650.0)
        (colour_array:|3,rgb_colour|* (alloc)))   ;marks transition to red levels
    ;; fill the colours for the spectral levels
    (tfill! (aref-ptr colour_array 0) 0.0 0.8 0.1) ;green
    (tfill! (aref-ptr colour_array 1) 0.6 0.5 0.0) ;orange
    (tfill! (aref-ptr colour_array 2) 1.0 0.2 0.0) ;red
    (lambda (cr bar_index bar_width bar_height)
      (let ((bar_width_jittered (+ bar_width
                                   (round (* (* bar_width 0.5)
                                             (- (random) 0.5)))))
            (bar_xpos (* (i64tod bar_index)
                         bar_width)))
        ;; draw red bars
        (if (> bar_height red_break)
            (begin
              (set_cairo_source_with_colour cr (aref-ptr colour_array 2))
              (cairo_rectangle cr
                               bar_xpos
                               0.0
                               bar_width_jittered
                               bar_height)
              (cairo_fill cr)))
        ;; draw orange bars
        (if (> bar_height orange_break)
            (begin
              (set_cairo_source_with_colour cr (aref-ptr colour_array 1))
              (cairo_rectangle cr
                               bar_xpos
                               0.0
                               bar_width_jittered
                               (if (> bar_height red_break)
                                   red_break bar_height))
              (cairo_fill cr)))
        ;; draw green bars
        (set_cairo_source_with_colour cr (aref-ptr colour_array 0))
        (cairo_rectangle cr
                         bar_xpos
                         0.0
                         bar_width_jittered
                         (if (> bar_height orange_break)
                             orange_break bar_height))
        (cairo_fill cr)))))

(bind-func draw_spectrum_key
  (let ((num_ticks:i64 8)
        (str_buf:i8* (alloc 100))
        (i:i64 0))
    (lambda (cr nbins bar_width)
      (cairo_set_source_rgb cr 1.0 1.0 1.0)
      (dotimes (i nbins)
        (if (= (modulo i (/ nbins num_ticks)) 2)
            (let ((freq (* 22050.0 (/ (i64tod i) (i64tod nbins)))))
              (cairo_move_to cr (- (* bar_width (i64tod i)) 30.0) 300.0)
              (if (< freq 1000.0)
                  (sprintf str_buf "%3.0fHz" freq)
                  (sprintf str_buf "%3.1fkHz" (/ freq 1000.0)))
              (cairo_show_text cr str_buf)))))))

(bind-func spectrum_visualiser 1000000
  (let ((width 1080)
        (height 720)
        (surface (cairo_image_surface_create CAIRO_FORMAT_RGB24
                                             (i64toi32 width) (i64toi32  height)))
	(cr (cairo_create surface))
	(i:i64 0))
    ;; for drawing the frequency markings
    (cairo_select_font_face cr
                         "Helvetica"
                         CAIRO_FONT_SLANT_NORMAL
                         CAIRO_FONT_WEIGHT_NORMAL)
    (cairo_set_font_size cr 20.0)
    (lambda (spectrum:double* nbins)
      (let ((bar_width (i64tod (/ width nbins))))
        (cairo_set_source_rgb cr 0.0 0.0 0.0)
        (cairo_paint_with_alpha cr 0.25)
        (dotimes (i nbins)
          (draw_spectral_bar cr i
                             bar_width
                             (* 20.0 (pref spectrum i))))
        (draw_spectrum_key cr nbins bar_width)
        (cairo_image_surface_get_data surface)))))

(bind-func bin_spectrum
  (let ((i:i64 0)
        (j:i64 0)
        (sum 0.0))
    (lambda (spectrum:double* freq_buffer window_size nbins)
      (let ((bin_width (/ (/ window_size nbins) 2)))
        (dotimes (i nbins)
          (set! sum 0.0)
          (dotimes (j (* i bin_width) bin_width)
            (set! sum (+ sum (magnitude-cpxd (pref-ptr freq_buffer j)))))
          (pset! spectrum i (* 2.0 (/ sum (i64tod bin_width)))))))))

(bind-func mag_spectrum
  (let ((nbins 64) ; number of bins for spectrogram
        (spectrum:double* (zalloc nbins))
        (i:i64 0))
    (lambda (audio:double* window_size time_buffer freq_buffer)
      (dotimes (i window_size)
        ;; add sum of L and R channels into real component
        ;; of time_buffer (which is a buffer of complex values
        (tset! (pref-ptr time_buffer i) 0
               (+ (pref audio (* 2 i)) ; L channel
                  (pref audio (+ 1 (* 2 i)))))) ; R channel
      ;; take DFT, store results in freq_buffer
      (fft-cpxd time_buffer freq_buffer window_size)
      (bin_spectrum spectrum freq_buffer window_size nbins))))

;; draw surface data returned from test2
(bind-func gl-draw 1000000
  (lambda (spectrum:double* nbins)
    (glLoadIdentity)
    (glClear (+ GL_COLOR_BUFFER_BIT GL_DEPTH_BUFFER_BIT))
    ;; ;; use tex num 5 repeatedly
    (gl-load-tex-bgr 1080 720 4 GL_UNSIGNED_BYTE (spectrum_visualiser spectrum nbins) 5)
    (gl-draw-img-reverse -1.0 -1.0 2.0 2.0 180.0 5)
    void))

;; set up the type alias for our dsp function
(bind-alias DSP [double,double,double,double,double*]*)
;; dsp function - this will play the sound file.  Remember to
;; change the file path to an audio file on your system
(bind-func dsp:DSP 100000000 ; make sure we allocate enough memory
  (let ((audio_length 60.0)
        (audio_closure (create_audio_closure "/Users/ben/Desktop/peg.wav"
                                             audio_length))
        (audio (audio_closure))
        (playhead 0)
        (window_size 128)
        (time_buffer:cpxd* (zalloc window_size))
        (freq_buffer:cpxd* (zalloc window_size))
        (i:i64 0))
    (lambda (in time chan dat)
      (if (and (= (modulo playhead window_size) 0)
               (= chan 0.0))
          (mag_spectrum (pref-ptr audio playhead) window_size
                        time_buffer freq_buffer))
      ;; increment playhead once per (stereo) pair of samples
      (if (= chan 1.0)
          (set! playhead (modulo (+ playhead 1)
                                 (* (dtoi64 audio_length) 44100))))
      ;; play audio
      (pref audio (+ (dtoi64 chan) (* 2 playhead))))))

(dsp:set! dsp)

;; note to self - maybe need to call glLoadIdentity from scheme?
;; statefulness and all that

;; standard callback
(define spectrum-animation
  (lambda (beat dur)
    (gl-draw (mag_spectrum.spectrum) (mag_spectrum.nbins))
    (gl:swap-buffers ctx)
    (callback (*metro* (+ beat (* .5 dur))) 'spectrum-animation (+ beat dur) dur)))

(spectrum-animation (*metro* 'get-beat 4) 1/10)
